<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PostSharp</name>
    </assembly>
    <members>
        <member name="T:PostSharp.Aspects.AdviceArgs">
            <summary>
              Base class for arguments of all advices.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.AdviceArgs.#ctor(System.Object)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AdviceArgs" />.
            </summary>
            <param name = "instance">The instance related to the advice invocation, or
              <c>null</c> if the advice is associated to a static element of code.</param>
        </member>
        <member name="P:PostSharp.Aspects.AdviceArgs.Instance">
            <summary>
              Gets or sets the object instance on which the method is being executed.
            </summary>
            <remarks> 
              <para>This may be set by user code only when the instance is a value type.
              As usual, user code is responsible for setting an object of the
              right type.</para> 
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.AdviceArgs.DeclarationIdentifier">
            <summary>
              Gets the <see cref="P:PostSharp.Aspects.AdviceArgs.DeclarationIdentifier" /> of the declaration to which the
              advice has been applied.
            </summary>
            <remarks>
              <para>For usage information, see the remarks of the <see cref="P:PostSharp.Aspects.AdviceArgs.DeclarationIdentifier" /> type documentation.</para>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.Advice">
            <summary>
              Base class for all custom attributes representing an advice.
            </summary>
            <remarks>
              <para>Advices are behaviors added to aspects by the way of custom
                attributes. Other ways to add behaviors is to implement interface methods.
              </para>
              <para>
                Advice custom attributes are typically used on aspect classes,
                or on members of aspect classes.
              </para>
            </remarks>
            <seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Advices.Advice.Description">
            <summary>
            A human-readable description of the current advice.
            </summary>
            <remarks>
            Set this property only on the master advice of the advice group.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.Advice.LinesOfCodeAvoided">
            <summary>
            Reduction in the code lines count achieved by applying the advice instance to one code element.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.AdviceInstance">
            <summary>
            Base class for advice instances, which can be provided dynamically by the aspect thanks to the <see cref="T:PostSharp.Aspects.Advices.IAdviceProvider"/> interface.
            </summary>
            <remarks>
            <para>The only supported dynamic advice currently is <see cref="T:PostSharp.Aspects.Advices.ImportLocationAdviceInstance"/>.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.AdviceInstance.MasterAspectMember">
            <summary>
            Gets the main field or method of the aspect class that the current <see cref="T:PostSharp.Aspects.Advices.AdviceInstance"/> relates to.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.AdviceInstance.Description">
            <summary>
            A human-readable description of the current advice instance.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.AdviceInstance.LinesOfCodeAvoided">
            <summary>
            The number of lines of hand-written code avoided by this specific <see cref="T:PostSharp.Aspects.Advices.AdviceInstance"/>.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.AdviceParameterAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Advices.AdviceParameterAttribute.#ctor">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Advices.ArgumentAttribute">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.ArgumentAttribute.Index">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Advices.ArgumentAttribute.#ctor(System.Int32)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.ArgumentsAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.AspectInitializationReason">
            <summary>
            Enumerates the reasons why the target method of the <see cref="T:PostSharp.Aspects.Advices.InitializeAspectInstanceAdvice"/> has been invoked.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.AspectInitializationReason.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.AspectInitializationReason.Manual">
            <summary>
            Manual call of the <c>InitializeAspects</c> method.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.AspectInitializationReason.Constructor">
            <summary>
            Call from the instance constructor.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.AspectInitializationReason.Clone">
            <summary>
            Call from <c>MemberwiseClone</c>.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.AspectInitializationReason.Deserialize">
            <summary>
            Call during deserialization.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.AsyncCallIdAttribute">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Advices.AwaitedMethodAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.AwaitedTaskAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.AwaiterAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.BindingAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute">
            <summary>
              Custom attribute that, when applied on an aspect class, requires custom
              attributes present on the aspect class to be copied to the target of this class.
              When applied on an introduced member (see <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" />),
              this custom attribute requires custom attributes present on the aspect member
              to be copied to the introduced member.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" />
            <seealso href="@members" target="_self">
      Conceptual: Introducing, Overriding and Importing Members
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.#ctor(System.Type)">
            <summary>
              Requires custom attributes present on the aspect class or aspect class member
              to be copied to the aspect target or to the introduced member, respectively.
            </summary>
            <param name = "type">Base type of custom attributes to be copied.</param>
        </member>
        <member name="M:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.#ctor(System.Type[])">
            <summary>
              Requires custom attributes present on the aspect class or aspect class member
              to be copied to the aspect target or to the introduced member, respectively.
            </summary>
            <param name = "types">Base types of custom attributes to be copied.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.OverrideAction">
            <summary>
              Determines what should happen when a custom attribute of the same
              type is already present on the target declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute.Types">
            <summary>
              Gets the list of custom attribute types to be copied.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.CurrentTaskAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.CustomAttributeOverrideAction">
            <summary>
              Behavior of <see cref = "T:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute" /> when a custom
              attribute of the same type already exists on the target declaration.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute" />
        </member>
        <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Default">
            <summary>
              Default (<see cref = "F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Fail" />).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Fail">
            <summary>
              Emits an error message.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Ignore">
            <summary>
              Silently ignore this custom attribute (does not copy it, without
              error message).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.Add">
            <summary>
              Adds a new copy (possibly duplicate) of the custom attribute.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.MergeAddProperty">
            <summary>
              Merges the existing custom attribute with the template custom attribute
              by adding properties and fields. If the existing custom attribute defines
              the same properties and fields as the template custom attribute, 
              they are not overridden.
            </summary>
            <remarks>
              Constructors arguments of the template custom attribute are 
              ignored during merging.
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.Advices.CustomAttributeOverrideAction.MergeReplaceProperty">
            <summary>
              Merges the existing custom attribute with the template custom attribute
              by adding and replacing properties and fields. If the existing custom
              attribute defines the same properties and fields as the template custom
              attribute, they are replaced by the values defined in the template
              custom attribute.
            </summary>
            <remarks>
              Constructors arguments of the template custom attribute are 
              ignored during merging.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.DeclarationIdentifierAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.DeclarationNameAttribute">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.DeclarationNameAttribute.IncludeTypeName">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.Event`1">
            <summary>
            Exposes the semantics of an event for use with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" /> aspect extension.
            </summary>
            <typeparam name="TDelegate">Handler type (derived from <see cref="T:System.Delegate" />).</typeparam>
            <remarks>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
            <seealso href="@members" target="_self">
      Conceptual: Introducing, Overriding and Importing Members
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Advices.Event`1.#ctor(PostSharp.Aspects.Advices.EventAccessor{`0},PostSharp.Aspects.Advices.EventAccessor{`0})">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.Event`1.Add">
            <summary>
              Gets a delegate enabling to invoke the <b>add</b> accessor
              of the imported event.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.Event`1.Remove">
            <summary>
              Gets a delegate enabling to invoke the <b>remove</b> accessor
              of the imported event.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.EventAccessor`1">
            <summary>
              Defines the signature of methods implementing the <see cref = "P:PostSharp.Aspects.Advices.Event`1.Add" />
              and <see cref = "P:PostSharp.Aspects.Advices.Event`1.Remove" /> semantics of an event.
            </summary>
            <typeparam name = "TDelegate">Handler type (derived from <see cref = "T:System.Delegate" />).</typeparam>
            <param name = "delegate">Handler.</param>
            <seealso cref = "T:PostSharp.Aspects.Advices.Event`1" />
        </member>
        <member name="T:PostSharp.Aspects.Advices.FlowBehaviorAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.GroupingAdvice">
            <summary>
              Base class for all advices that are possibly composed of
              multiple advices that can be grouped together using the <see cref = "P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
              property.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.GroupingAdvice.Master">
            <summary>
              Name of the master advice method. If this property is not set,
              the current method is itself the master of the group. Only
              master methods can define selectors (<see cref = "T:PostSharp.Aspects.Advices.Pointcut" />)
              and dependencies (<see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" />).
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.IAdviceProvider">
            <summary>
            Interface that allows an aspect to provide aspects dynamically, instead of declaratively using custom attributes.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Advices.IAdviceProvider.ProvideAdvices(System.Object)">
            <summary>
            Provides an enumeration of advices, represented as instances of the <see cref="T:PostSharp.Aspects.Advices.AdviceInstance"/> class, for the current aspect instance.
            </summary>
            <param name="targetElement">Element of code to which the current aspect has been applied.</param>
            <returns>A collection of advices to be added to the current aspect instance.</returns>
        </member>
        <member name="T:PostSharp.Aspects.Advices.ImportLocationAdviceInstance">
            <summary>
            Represents an advice that imports a field or property (represented by a <see cref="T:PostSharp.Reflection.LocationInfo"/>) of the target class
            into a field of the aspect class. This class is the imperative equivalent of the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/> declarative advise.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.IAdviceProvider"/>
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportLocationAdviceInstance.#ctor(System.Reflection.FieldInfo,PostSharp.Reflection.LocationInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.ImportLocationAdviceInstance"/> class and specifies which field or property should be imported by giving its reflection representation.
            </summary>
            <param name="aspectField">A field of the aspect class to which <paramref name="location"/> should be bound at runtime.
                This field can be of type <see cref="T:PostSharp.Aspects.ILocationBinding"/>, <see cref="T:PostSharp.Aspects.Advices.Property`1"/>, or a type that is both (a) derived from <c>ICollection&lt;ILocationBinding&gt;</c> and (b) has a parameterless constructor.</param>
            <param name="location">The field or property to import.</param>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportLocationAdviceInstance.#ctor(System.Reflection.FieldInfo,System.String,System.Boolean,PostSharp.Aspects.Advices.ImportMemberOrder)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.ImportLocationAdviceInstance"/> class and specifies the name of the property to be imported; the type of this
            property will be matched according to the type of the aspect field.
            </summary>
            <param name="aspectField">A field of the aspect class to which the field or property should be bound at build time.
                This field must be of type <see cref="T:PostSharp.Aspects.Advices.Property`1"/>.</param>
            <param name="propertyName">The name of the property to import.</param>
            <param name="isRequired">Determines whether a build-time error should be emitted if the member cannot be found.
            If <c>false</c>, the binding field will be <c>null</c> in case the imported member is absent.
            </param>
            <param name="order">Determines whether the <paramref name="aspectField"/> should be bound to the member
            as resolved before or after introduction of new members into the target class by the current advise.</param>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportLocationAdviceInstance.#ctor(System.Reflection.FieldInfo,System.String[],System.Boolean,PostSharp.Aspects.Advices.ImportMemberOrder)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.ImportLocationAdviceInstance"/> class and specifies the name of the property to be imported; the type of this
            property will be matched according to the type of the aspect field.
            </summary>
            <param name="aspectField">A field of the aspect class to which the field or property should be bound at build time.
                This field must be of type <see cref="T:PostSharp.Aspects.Advices.Property`1"/>.</param>
            <param name="propertyNames">Fallback list of possible names of the property to import.</param>
            <param name="isRequired">Determines whether a build-time error should be emitted if the member cannot be found.
            If <c>false</c>, the binding field will be <c>null</c> in case the imported member is absent.
            </param>
            <param name="order">Determines whether the <paramref name="aspectField"/> should be bound to the member
            as resolved before or after introduction of new members into the target class by the current advise.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportLocationAdviceInstance.Location">
            <summary>
            Gets the field or property of the target class that needs to be imported into the aspect.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportLocationAdviceInstance.Member">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportLocationAdviceInstance.MemberNames">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Advices.ImportMemberAdviceInstance">
            <summary>
            Base class for <see cref="T:PostSharp.Aspects.Advices.ImportLocationAdviceInstance"/> and <see cref="T:PostSharp.Aspects.Advices.ImportMethodAdviceInstance"/>.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.IAdviceProvider"/>
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.AspectField">
            <summary>
            Gets the field of the aspect class to which the field or property needs to be bound.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.IsRequired">
            <summary>
            Determines whether a build-time error should be emitted if the member cannot be found.
            If <c>false</c>, the binding field will be <c>null</c> in case the imported member is absent.
            </summary>
            <remarks>
            <para>This property is always <c>true</c> when the <see cref="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.Member"/> property is set.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.Member">
            <summary>
            Gets the reflection object (<see cref="T:PostSharp.Reflection.LocationInfo"/> or <see cref="T:System.Reflection.MethodInfo"/>) that needs to be
            imported, or <c>null</c> if the exact member is unknown and must be matched by name and signature.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.MemberNames">
            <summary>
            Gets the fallback list of possible names of the member to be imported.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.Order">
            <summary>
            Determines whether the <see cref="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.AspectField"/> should be bound to the member
            as resolved before or after introduction of new members into the target class by the current advise.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAdviceInstance.MasterAspectMember">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Advices.ImportMemberAttribute">
            <summary>
              Custom attribute that, when applied to an instance field of an aspect class, determines
              that this field should be bound to a method, event or property, of the
              target class of this aspect. Valid types for fields are
              a concrete <see cref="T:System.Delegate" /> (to bind to a method),
              <see cref="T:PostSharp.Aspects.Advices.Property`1" /> or <see cref="T:PostSharp.Aspects.Advices.Property`2" />
              (to bind to a property), or <see cref="T:PostSharp.Aspects.Advices.Event`1" /> (to bind to an event).
            </summary>
            <remarks>
              <para>Fields annotated with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
                custom attribute must be public and must not be read only.</para>
              <para>At runtime, these fields are assigned to a delegate (in case
                of method binding) or a pair of delegates (in case of event or property
                binding) allowing to invoke the imported member.</para>
              <para>When <see cref="P:PostSharp.Aspects.Advices.ImportMemberAttribute.IsRequired" /> property is set to <c>true</c> and the target type does not contain a member of the required
                name and signature, then a build error will be raised.</para>
              <para>When multiple member names are specified, the first existing member satisfying all conditions is used.
              </para>
            </remarks>
            <seealso href="@members" target="_self">
      Conceptual: Introducing, Overriding and Importing Members
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportMemberAttribute.#ctor(System.String[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Advices.ImportMemberAttribute" /> and specifies several possible names for the member to import.
            </summary>
            <param name = "memberNames">Possible names of the member to import in the order of precedence.</param>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportMemberAttribute.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/> and specifies a single name for the member to import.
            </summary>
            <param name="memberName">The name of the member to import.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAttribute.IsRequired">
            <summary>
              Determines whether a build time error must be issued if the member to be
              imported is absent. If <c>false</c>, the binding field will be <c>null</c>
              in case the imported member is absent.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAttribute.MemberNames">
            <summary>
              Array of possible names of imported member in the order of precedence.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMemberAttribute.Order">
            <summary>
              Determines when the member should be imported: either before (<see cref = "F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions" />)
              or after (<see cref = "F:PostSharp.Aspects.Advices.ImportMemberOrder.AfterIntroductions" />) members have been introduced by the current aspect.
              Default is <see cref = "F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions" />.
            </summary>
            <remarks>
              Sometimes it makes sense for an aspect to import a member <i>after</i> the same aspect has introduced member.
              This allows the aspect to invoke a member that could be overridden by later aspects.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.ImportMemberOrder">
            <summary>
              Enumeration of moments when members should be imported into an aspect.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
        </member>
        <member name="F:PostSharp.Aspects.Advices.ImportMemberOrder.Default">
            <summary>
              <see cref = "F:PostSharp.Aspects.Advices.ImportMemberOrder.AfterIntroductions" />
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.ImportMemberOrder.BeforeIntroductions">
            <summary>
              Before the aspect introduces its own members. This is similar to calling the overridden method using the
              <c>base</c> keyword in C#. The overridden method implementation is always selected, even if the method
              is virtual.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.ImportMemberOrder.AfterIntroductions">
            <summary>
              After the aspect introduces its own members. Note that importing a member introduced by the current
              aspect makes sense only if the member has been introduced as virtual; in this case, the
              the imported member is dynamically resolved using the virtual table of the target object.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.ImportMethodAdviceInstance">
            <summary>
            Represents an advises that import a method of the target class into the aspect class.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportMethodAdviceInstance.#ctor(System.Reflection.FieldInfo,System.String,System.Boolean,PostSharp.Aspects.Advices.ImportMemberOrder)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.ImportMethodAdviceInstance"/>.
            </summary>
            <param name="aspectField">A field of the aspect class into that will be assigned to a delegate of the imported method at runtime. The field type should be a delegate of the same signature than the method to import.</param>
            <param name="methodName">Name of the method to import.</param>
            <param name="isRequired"><c>true</c> if the build should fail if there no matching method in the target class, <c>false</c> to set <paramref name="aspectField"/> to <c>null</c> in this case.</param>
            <param name="order">Determines whether the <paramref name="aspectField"/> should be bound to the member
            as resolved before or after introduction of new members into the target class by the current advise.
            </param>
        </member>
        <member name="M:PostSharp.Aspects.Advices.ImportMethodAdviceInstance.#ctor(System.Reflection.FieldInfo,System.String[],System.Boolean,PostSharp.Aspects.Advices.ImportMemberOrder)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.ImportMethodAdviceInstance"/>.
            </summary>
            <param name="aspectField">A field of the aspect class into that will be assigned to a delegate of the imported method at runtime. The field type should be a delegate of the same signature than the method to import.</param>
            <param name="methodNames">Fallback list of possible names of the member to be imported.</param>
            <param name="isRequired"><c>true</c> if the build should fail if there no matching method in the target class, <c>false</c> to set <paramref name="aspectField"/> to <c>null</c> in this case.</param>
            <param name="order">Determines whether the <paramref name="aspectField"/> should be bound to the member
            as resolved before or after introduction of new members into the target class by the current advise.
            </param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMethodAdviceInstance.Member">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Aspects.Advices.ImportMethodAdviceInstance.MemberNames">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Advices.InitializeAspectInstanceAdvice">
            <summary>
            Custom attribute that, when applied to a method of an aspect class, specifies that this method
            should be invoked whenever the aspect instance needs to be initialized. The target method
            must have a <c>void</c> return value and have a single parameter of type <see cref="T:PostSharp.Aspects.Advices.AspectInitializationReason"/>.
            This method is equivalent to <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.RuntimeInitializeInstance"/>
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.InterfaceOverrideAction">
            <summary>
              Enumeration of actions to be overtaken when an interface that should be introduced into a type is already
              implemented by that type.
            </summary>
            <remarks>
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute" />
        </member>
        <member name="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Default">
            <summary>
              <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" />.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail">
            <summary>
              Fails and emits an error message.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore">
            <summary>
              Silently ignore this interface (does not introduce it).
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance">
            <summary>
            Represents an advise that introduces an interface into the target class. The interface must be implemented by the aspect class.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.IAdviceProvider"/>
            <seealso cref="T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute"/>
        </member>
        <member name="M:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.#ctor(System.Type,PostSharp.Aspects.Advices.InterfaceOverrideAction,PostSharp.Aspects.Advices.InterfaceOverrideAction)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance"/> class.
            </summary>
            <param name="interfaceType">Interface to introduce to the target class. Must be implemented by the aspect class itself.</param>
            <param name="overrideAction">Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when the interface specified in the constructor of this custom attribute
              is already implemented by the type to which the current aspect is applied.</param>
            <param name="ancestorOverrideAction"> Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when an <i>ancestor</i> of the interface specified in the constructor of this custom attribute
              is already implemented by the type to which the current aspect is applied.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.InterfaceType">
            <summary>
            Gets the interface to be introduced into the target class.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.OverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when the interface specified in the constructor of this custom attribute
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.AncestorOverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.AncestorOverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when an <i>ancestor</i> of the interface specified in the constructor of this custom attribute
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.OverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAdviceInstance.MasterAspectMember">
            <inhericdoc />
        </member>
        <member name="T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute">
            <summary>
              Custom attribute that, when applied to an aspect class, specifies that the aspect should
              introduce a given interface into the type to which the aspect is applied.
            </summary>
            <seealso href="@interface-introduction" target="_self">
      Conceptual: Introducing Interfaces
    </seealso>
            <remarks>
            <para>The introduced interface will be implemented explicitly by the type to which the aspect is applied.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.#ctor(System.Type)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute" />.
            </summary>
            <param name = "interfaceType">Interface that should be introduced into the types
              to which the aspect is applied.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.OverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when the interface specified in the constructor of this custom attribute
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.AncestorOverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.AncestorOverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when an <i>ancestor</i> of the interface specified in the constructor of this custom attribute
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute.OverrideAction" />
        </member>
        <member name="T:PostSharp.Aspects.Advices.IntroduceMemberAdviceInstance">
            <summary>
            Base class for <see cref="T:PostSharp.Aspects.Advices.IntroduceMethodAdviceInstance"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAdviceInstance.Visibility">
            <summary>
            Gets the visibility of the introduced member.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAdviceInstance.IsVirtual">
            <summary>
            Determines whether the introduced member should be virtual. 
            </summary>
            <remarks>
              <para>
                When this property is <c>false</c> and the member already exists in a base type
                and is virtual, the member is overridden and marked as <c>sealed</c>.
              </para>
              <para>
                When this property is set to <c>null</c>, the introduced member is <c>virtual</c> if it exists in a base
                type as a virtual member, otherwise non-virtual.
              </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAdviceInstance.OverrideAction">
            <summary>
              Determines the action to be overtaken when the member to be introduced already exists
              in the type to which the aspect is applied, or to a base type.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute">
            <summary>
              Custom attribute that, when applied on a method, event or property of an aspect class, specifies
              that this method, event or property should be introduced into the types to which the aspect is applied.
            </summary>
            <remarks>
            <para>
              Methods, properties and events annotated with <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" /> must be public.
            </para>
            <para>
             If the method, event or property is in a C# 8.0 nullable annotations context, its nullability information will
            be copied into the types as well. 
            </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Advices.CopyCustomAttributesAttribute" />
            <seealso href="@members" target="_self">
      Conceptual: Introducing, Overriding and Importing Members
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.Visibility">
            <summary>
              Determines the visibility (<see cref = "F:PostSharp.Reflection.Visibility.Public" />, (<see cref = "F:PostSharp.Reflection.Visibility.Family" />, ...)
              of the introduced member.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.IsVirtual">
            <summary>
              Determines whether the introduced member should be virtual.
            </summary>
            <remarks>
              <para>
                Value of this property is ignored when the member to be introduced already exists in the aspect target type or its base type.
              </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.IsIsVirtualSpecified">
            <summary>
              Determines whether the <see cref = "P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.IsVirtual" /> property has been specified.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMemberAttribute.OverrideAction">
            <summary>
              Determines the action to be overtaken when the member to be introduced already exists
              in the type to which the aspect is applied, or to a base type.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.IntroduceMethodAdviceInstance">
            <summary>
            Represents an advice that introduces a method of the aspect class into the target class.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.IAdviceProvider"/>
            <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute"/>
        </member>
        <member name="M:PostSharp.Aspects.Advices.IntroduceMethodAdviceInstance.#ctor(System.Reflection.MethodInfo,PostSharp.Reflection.Visibility,System.Nullable{System.Boolean},PostSharp.Aspects.Advices.MemberOverrideAction)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.Advices.IntroduceMethodAdviceInstance"/> class.
            </summary>
            <param name="method">A public method of the aspect class.</param>
            <param name="visibility">Visibility of the introduced method.</param>
            <param name="isVirtual"><c>true</c> if the introduced method should be virtual, <c>false</c> if it should be non-virtual (or sealed, if the method is overriding another one),
            or <c>null</c> if the method should be virtual only if the overridden method is also virtual. See <see cref="P:PostSharp.Aspects.Advices.IntroduceMemberAdviceInstance.IsVirtual"/> for details.</param>
            <param name="overrideAction">Determines the action to be overtaken when the member to be introduced already exists
              in the type to which the aspect is applied, or to a base type.
            </param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.IntroduceMethodAdviceInstance.MasterAspectMember">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Advices.IProperty">
            <summary>
            A weakly-typed interface for the <seealso cref="T:PostSharp.Aspects.Advices.Property`1"/> class.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Advices.IProperty.GetValue">
            <summary>
            Gets the property value.
            </summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Advices.IProperty.SetValue(System.Object)">
            <summary>
            Sets the property value.
            </summary>
            <param name="value">The new property value.</param>
        </member>
        <member name="T:PostSharp.Aspects.Advices.LocationValidationAdvice">
            <summary>
            Custom attribute that, when applied on a method of an aspect class, specifies that this method
            has the same semantic as the <see cref="M:PostSharp.Aspects.ILocationValidationAspect`1.ValidateValue(`0,System.String,PostSharp.Reflection.LocationKind,PostSharp.Aspects.LocationValidationContext)" /> method
            of the <see cref="T:PostSharp.Aspects.ILocationValidationAspect`1" /> interface.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.ILocationValidationAspect`1.ValidateValue(`0,System.String,PostSharp.Reflection.LocationKind,PostSharp.Aspects.LocationValidationContext)" />, where <c>T</c> can be any type. However, the method can be static.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.ILocationValidationAspect`1" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Advices.LocationValidationAdvice.Priority">
            <summary>
            Determines a priority for selecting a validation method from a group when more than one method matches the target element type.
            A method with a lower value has priority over a method with a higher value.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.LocationValueAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.MatchPointcut">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Advices.MatchPointcut.#ctor(System.String)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.MatchPointcut.MatchParameterCount">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.MatchPointcut.MethodName">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.MemberOverrideAction">
            <summary>
              Enumeration of actions to be overtaken by the <see cref = "T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" /> aspect extension
              when the member to be introduced already exists in the aspect target type or its base type.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.Default">
            <summary>
              <see cref = "F:PostSharp.Aspects.Advices.MemberOverrideAction.Fail" />
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.Fail">
            <summary>
              Emits a build time error.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.Ignore">
            <summary>
              Silently ignore the member introduction.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.OverrideOrFail">
            <summary>
              Tries to override the member, and fails if it is impossible (i.e. if the existing member is defined
              in a base type and is sealed or non-virtual).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Advices.MemberOverrideAction.OverrideOrIgnore">
            <summary>
              Tries to override the member, and silently ignore if it is impossible (i.e. if the existing member is defined
              in a base type and is sealed or non-virtual).
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.MethodPointcut">
            <summary>
              Custom attribute that, when applied on an advice method, specifies the name of
              the method that will be invoked at build-time to return the set of elements of code
              to which the advice applies.
            </summary>
            <remarks>
              <para>
                This method should have the signature
                <c>IEnumerable&lt;AdviceTargetType&gt; SelectCodeElements(AspectTargetType target)</c> ,
                where <c>AspectTargetType</c> is either <c>object</c> either a reflection type
                corresponding to the kind of targets of the <i>aspect</i> (for instance <c>System.Type</c>
                for a type-level aspect), and <c>AdviceTargetType</c> is either <c>object</c> either
                a reflection type of the kind of targets of the <i>advice</i> (for instance <c>System.MethodInfo</c> for a method-level advice).
              </para>
            </remarks>
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Advices.MethodPointcut.#ctor(System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Advices.MethodPointcut" />.
            </summary>
            <param name = "methodName">Name of the method returning the set of targets. This method should have
              a specific signature as discussed in the <see cref = "T:PostSharp.Aspects.Advices.MethodPointcut">class documentation</see>.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.MethodPointcut.MethodName">
            <summary>
              Gets the name of the method returning the set of code elements.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.MulticastPointcut">
            <summary>
              Custom attribute that, when applied on an advice method, specifies to which elements of
              code this advice applies, based on the kind, name and attributes of code elements.
              Works similarly as <see cref="T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
            <remarks>
            </remarks>
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Advices.MulticastPointcut.MemberName">
            <summary>
              Gets or sets the expression specifying to which members 
              the aspect extension applies.
            </summary>
            <value>
              A wildcard or regular expression specifying to which members
              this instance applies, or <c>null</c> this instance
              applies either to all members whose kind is given in <see cref = "P:PostSharp.Aspects.Advices.MulticastPointcut.Targets" />.
              Regular expressions should start with the <c>regex:</c> prefix.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.Advices.MulticastPointcut.Targets">
            <summary>
              Gets or sets the kind of elements to which this aspect extension applies.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.MulticastPointcut.Attributes">
            <summary>
              Gets or sets the visibilities, scopes, virtualities, and implementation
              of members to which this attribute applies.
            </summary>
            <remarks>
              <para>
                The <see cref = "T:PostSharp.Extensibility.MulticastAttributes" /> enumeration is a multi-part flag: there is one
                part for visibility, one for scope, one for virtuality, and one for implementation.
                If you specify one part, it will override the values defined on the custom attribute definition.
              </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnAspectsInitializedAdvice">
            <summary>
            Custom attribute that, when applied to a method of an aspect class, specifies that this method
            should be invoked after the instances of all the aspects applied on the same target has been initialized. The target method
            must have a <c>void</c> return value and have a single parameter of type <see cref="T:PostSharp.Aspects.Advices.AspectInitializationReason"/>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />. However, it can be static.
              </para>
              <para>
               This advice does not intercept the initializer of a field-like event. If you want to intercept the adding of all handlers,
            do not use event initializers and instead add the initial handler in the constructor.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
      ) that are meant to be applied to the same events with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note><seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" /><seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" /><seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
              <br />
              <note>
      Because of the way how the C# compiler implements
      <b>field-like events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.EventInterceptionAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />. However, it can be static.
              </para>
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
      ) that are meant to be applied to the same events with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note><seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" /><seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" /><seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
              <br />
              <note>
      Because of the way how the C# compiler implements
      <b>field-like events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.EventInterceptionAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies that this method is an advice
              having the same semantics as <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnEventRemoveHandlerAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
      ) that are meant to be applied to the same events with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note><seealso cref="T:PostSharp.Aspects.IEventInterceptionAspect" /><seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" /><seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
              <br />
              <note>
      Because of the way how the C# compiler implements
      <b>field-like events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
            </remarks>
            <remarks>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.EventInterceptionAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnEventAddHandlerAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnEventInvokeHandlerAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnInstanceConstructedAdvice">
            <summary>
            Custom attribute that, when applied to a method of an aspect, specifies that this method should be executed 
            after the last instance constructor of the target class of the aspect has completed execution. That is, this method will be invoked when the target object
            will be fully constructed. This custom attribute can be applied only on methods that have return type <c>void</c> and no parameters.
            </summary>
            <remarks>
            The target object is fully constructed when all its constructors complete execution, including constructors of subclasses. For example, if you apply
            this advice to type <c>A</c>, and class <c>B</c> extends class <c>A</c>, then if you create a new instance of <c>B</c>, the method will be invoked only
            after B's constructor ends.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnInstanceLocationInitializedAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IOnInstanceLocationInitializedAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.IOnInstanceLocationInitializedAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)" />. However, it can be static.
              </para>
              <para>
                Standalone advices or group masters should also be annotated by a custom attribute derived from
                <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.LocationLevelAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />. However, it can be static.
              </para>
              <para>
                If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />, 
                <see cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />) and if these advices
                are meant to be applied to the same properties with consistent ordering, they should be
                grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
              </para>
              <para>
                Standalone advices or group masters should also be annotated by a custom attribute derived from
                <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.LocationLevelAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnInstanceLocationInitializedAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />. However, it can be static.
              </para>
              <para>
                If an aspect defines many advices (among <see cref="T:PostSharp.Aspects.Advices.OnLocationSetValueAdvice" />, 
                <see cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />) and if these advices
                are meant to be applied to the same properties with consistent ordering, they should be
                grouped together (see <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" /> property).
              </para>
              <para>
                Standalone advices or group masters should also be annotated by a custom attribute derived from
                <see cref="T:PostSharp.Aspects.Advices.Pointcut" />.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.LocationLevelAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnLocationGetValueAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnInstanceLocationInitializedAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodBoundaryAdvice">
            <summary>
            Base class for <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice"/>, <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice"/>,
            <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice"/> or <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice"/>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.OnMethodBoundaryAdvice.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the advice when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.OnMethodBoundaryAdvice.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the advice is applied to an unsupported target method.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      ) that are meant to be applied to the same methods with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodYieldAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodResumeAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      ) that are meant to be applied to the same methods with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodExitAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      ) that are meant to be applied to the same methods with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodInvokeAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" />. However, it can be static.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodInvokeAsyncAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.IAsyncMethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.IAsyncMethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)" />. However, it can be static.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodInvokeBaseAdvice">
            <summary>
            The base class for method interception advices.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.OnMethodInvokeBaseAdvice.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the advice when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Advices.OnMethodInvokeBaseAdvice.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the advice is applied to an async method with unsupported return value type.
            </summary>
            <remarks>
            <para>
            Starting with C#7 async methods can have return types other than <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>.
            Async method interception does not support this type of async methods. By default, the build error is raised whenever
            async method interception is applied to a method that returns awaitable type other than <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>.
            </para>
            <para>
            Set this property to change how unsupported async methods are handled during compile time.
            </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodResumeAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnResume(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnResume(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      ) that are meant to be applied to the same methods with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodYieldAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      ) that are meant to be applied to the same methods with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.OnMethodYieldAdvice">
            <summary>
              Custom attribute that, when applied on a method of an aspect class, specifies
              that this method is an advice having the same semantics as <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)" />.
            </summary>
            <remarks>
              <para>
                The method to which this custom attribute is applied must be public and must have the same signature as
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)" />. However, it can be static.
              </para>
              <br />
              <para>
      If an aspect defines many advices (among
      <see cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
      ,
      <see cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
      and
      <see cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
      ) that are meant to be applied to the same methods with consistent ordering, these advices should be
      grouped together (see
      <see cref="P:PostSharp.Aspects.Advices.GroupingAdvice.Master" />
      property).
    </para><note>
      Standalone advices or group masters should also be annotated by a custom attribute derived from
      <see cref="T:PostSharp.Aspects.Advices.Pointcut" />
      .
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodEntryAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExitAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodSuccessAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodExceptionAdvice" />
            <seealso cref="T:PostSharp.Aspects.Advices.OnMethodResumeAdvice" />
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.Pointcut">
            <summary>
              Custom attribute, typically accompanying an advice, specifying
              to which code elements the advice applies.
            </summary>
            <remarks>
            </remarks>
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Advices.Property`1">
            <summary>
            Exposes the semantics of a parameterless property for use
            with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" /> aspect extension.
            </summary>
            <typeparam name="TValue">Property value type.</typeparam>
            <remarks>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Advices.Property`2" />
            <seealso cref="T:PostSharp.Aspects.Advices.PropertyGetter`1" />
            <seealso cref="T:PostSharp.Aspects.Advices.PropertySetter`1" />
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute" />
            <seealso href="@members" target="_self">
      Conceptual: Introducing, Overriding and Importing Members
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Advices.Property`1.#ctor(PostSharp.Aspects.Advices.PropertyGetter{`0},PostSharp.Aspects.Advices.PropertySetter{`0})">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.Property`1.Get">
            <summary>
              Gets a delegate enabling to invoke the <b>get</b> accessor
              of the imported property.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.Property`1.Set">
            <summary>
              Gets a delegate enabling to invoke the <b>set</b> accessor
              of the imported property.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.Property`2">
            <summary>
            Mimics the semantics of a property accepting a single index parameter, for use
            with the <see cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/> aspect extension.
            </summary>
            <typeparam name="TIndex">Property index type.</typeparam>
            <typeparam name="TValue">Property value type.</typeparam>
            <seealso cref="T:PostSharp.Aspects.Advices.Property`1"/>
            <seealso cref="T:PostSharp.Aspects.Advices.PropertyGetter`2"/>
            <seealso cref="T:PostSharp.Aspects.Advices.PropertySetter`2"/>
        </member>
        <member name="M:PostSharp.Aspects.Advices.Property`2.#ctor(PostSharp.Aspects.Advices.PropertyGetter{`0,`1},PostSharp.Aspects.Advices.PropertySetter{`0,`1})">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.Property`2.Get">
            <summary>
              Gets a delegate enabling to invoke the <b>get</b> accessor
              of the imported property.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.Property`2.Set">
            <summary>
              Gets a delegate enabling to invoke the <b>set</b> accessor
              of the imported property.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.PropertyGetter`2">
            <summary>
              Defines the signature of methods implementing the <see cref = "P:PostSharp.Aspects.Advices.Property`2.Get" />
              semantic of a property with a single index parameter.
            </summary>
            <typeparam name = "TValue">Property value type.</typeparam>
            <typeparam name = "TIndex">Property index type.</typeparam>
            <param name = "index">Index.</param>
            <returns>The property value.</returns>
            <seealso cref = "T:PostSharp.Aspects.Advices.Property`2" />
        </member>
        <member name="T:PostSharp.Aspects.Advices.PropertySetter`2">
            <summary>
              Defines the signature of methods implementing the <see cref = "P:PostSharp.Aspects.Advices.Property`2.Set" />
              semantic of a property with a single index parameter.
            </summary>
            <typeparam name = "TValue">Property value type.</typeparam>
            <typeparam name = "TIndex">Property index type.</typeparam>
            <param name = "index">Index.</param>
            <param name = "value">The property value.</param>
            <seealso cref = "T:PostSharp.Aspects.Advices.Property`2" />
        </member>
        <member name="T:PostSharp.Aspects.Advices.PropertyGetter`1">
            <summary>
              Defines the signature of methods implementing the <see cref = "P:PostSharp.Aspects.Advices.Property`1.Get" />
              semantic of a parameterless property.
            </summary>
            <typeparam name = "TValue">Property value type.</typeparam>
            <returns>The property value.</returns>
            <seealso cref = "T:PostSharp.Aspects.Advices.Property`1" />
        </member>
        <member name="T:PostSharp.Aspects.Advices.PropertySetter`1">
            <summary>
              Defines the signature of methods implementing the <see cref = "P:PostSharp.Aspects.Advices.Property`1.Set" />
              semantic of a parameterless property.
            </summary>
            <typeparam name = "TValue">Property value type.</typeparam>
            <param name = "value">The property value.</param>
            <seealso cref = "T:PostSharp.Aspects.Advices.Property`1" />
        </member>
        <member name="T:PostSharp.Aspects.Advices.ReturnValueAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.SelfPointcut">
            <summary>
              <see cref="T:PostSharp.Aspects.Advices.Pointcut" /> that selects exactly the aspect target.
            </summary>
            <seealso href="@advices" target="_self">
      Conceptual: Adding Behaviors to Members
    </seealso>
            <remarks>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Advices.SignaturePointcut">
            <summary>
            A <see cref="T:PostSharp.Aspects.Advices.Pointcut"/> that matches target methods by name and signature.
            This works only with non-generic methods.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Advices.SignaturePointcut.#ctor(System.String,System.Type[])">
            <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Advices.SignaturePointcut"/>.
            </summary>
            <param name="name">The name of the target method.</param>
            <param name="parameterTypes">The exact type of parameters of this method.</param>
        </member>
        <member name="P:PostSharp.Aspects.Advices.SignaturePointcut.Name">
            <summary>
            Gets the name of the target method.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Advices.SignaturePointcut.ArgumentTypes">
            <summary>
            Gets the exact types of parameters of the target method.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Advices.StateAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Advices.StateAttribute.#ctor(PostSharp.Aspects.Advices.StateScope)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Advices.StateAttribute.#ctor(PostSharp.Aspects.Advices.StateScope,System.String)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.StateAttribute.Scope">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Advices.StateAttribute.SlotName">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.StateScope">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Advices.StateScope.MethodInvocation">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Advices.ThisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Arguments">
            <summary>
              Encapsulation of method arguments.
            </summary>
            <remarks>
              <note>
                As a result of optimizations, an <see cref = "T:PostSharp.Aspects.Arguments" /> object may be shared between different 
                advices. If an advice implementation needs to access an <see cref = "T:PostSharp.Aspects.Arguments" /> object after it has given over
                control, it should take a reference to a clone instead of the initial object itself.
              </note>
              <note>
                Implementations of this type should be considered an implementation detail and should not be accessed
                by user code.
              </note>
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.Arguments.Empty">
            <summary>
              Empty list of <see cref = "T:PostSharp.Aspects.Arguments" />.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Arguments.Count">
            <summary>
              Gets the number of arguments encapsulated by the current object.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.GetArgument(System.Int32)">
            <summary>
              Gets the value of the argument at a given index.
            </summary>
            <param name = "index">Argument index.</param>
            <returns>The value of the argument at position <paramref name = "index" />.</returns>
            <exception cref = "T:System.ArgumentOutOfRangeException"><paramref name = "index" /> is lower than zero or greater or equal than <see cref = "P:PostSharp.Aspects.Arguments.Count" />.</exception>
        </member>
        <member name="P:PostSharp.Aspects.Arguments.Item(System.Int32)">
            <summary>
              Gets or sets the value of an argument. Setting the value is only supported in specific situations. See <see cref="M:PostSharp.Aspects.Arguments.SetArgument(System.Int32,System.Object)"/> for details.  
            </summary>
            <param name = "index">Argument index.</param>
            <returns>The argument value.</returns>
            <exception cref = "T:System.ArgumentOutOfRangeException"><paramref name = "index" /> is lower than zero or greater or equal than <see cref = "P:PostSharp.Aspects.Arguments.Count" />.</exception>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.SetArgument(System.Int32,System.Object)">
            <summary>
              Sets the value of the <c>ref</c> or <c>out</c> argument at a given index. Replacing an argument value is supported only in some advices
              and is silently ignored in non-supported scenarios. See Remarks for details.
            </summary>
            <param name = "index">Argument index.</param>
            <param name = "value">New value of the ref or out argument at position <paramref name = "index" />.</param>
            <exception cref = "T:System.InvalidCastException"><paramref name = "value" /> is not assignable to parameter
              at position <paramref name = "index" />.</exception>
            <exception cref = "T:System.ArgumentOutOfRangeException"><paramref name = "index" /> is lower than zero or greater or equal than <see cref = "P:PostSharp.Aspects.Arguments.Count" />.</exception>
            <remarks>
            <para>
            Replacing a parameter value is supported in the following scenarios:
            </para>
            <list type="bullet">
               <item><description>In <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)"/> and <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" /> advices, to replace
                        the value of <c>ref</c> and <c>out</c> parameters.</description></item>
               <item><description>In any interception advice (such as <see cref="M:PostSharp.Aspects.MethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)"/> or <see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)"/>),
                to set the value passed to the next node in the chain of responsibility, or the value of <c>ref</c> and <c>out</c> parameters.
                </description></item>
            </list>
            <para>
            Setting the value in a different situation is unsupported and has unspecified behavior.
            </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.CopyFrom(System.Object[],System.Int32)">
            <summary>
              Copies all the argument values from the elements of <see cref = "T:System.Array" />.
            </summary>
            <param name = "array">The array that is the source of the argument values copied into the current <see cref = "T:PostSharp.Aspects.Arguments" />.</param>
            <param name = "index">An integer that represents the index in <paramref name = "array" /> at which copying begins.</param>
            <exception cref = "T:System.ArgumentNullException"><paramref name = "array" /> is <c>null</c>.</exception>
            <exception cref = "T:System.ArgumentOutOfRangeException"><paramref name = "index" /> is lower than zero.</exception>
            <seealso cref = "M:PostSharp.Aspects.Arguments.CopyTo(System.Object[],System.Int32)" />
        </member>
        <member name="M:PostSharp.Aspects.Arguments.CopyTo(System.Object[],System.Int32)">
            <summary>
              Copies all arguments values to the specified <see cref = "T:System.Array" /> starting at the specified destination <see cref = "T:System.Array" /> index.
            </summary>
            <param name = "array">The array that is the destination of argument values copied from the current <see cref = "T:PostSharp.Aspects.Arguments" />.</param>
            <param name = "index">An integer that represents the index in <paramref name = "array" /> at which copying begins</param>
            <seealso cref = "M:PostSharp.Aspects.Arguments.CopyFrom(System.Object[],System.Int32)" />
        </member>
        <member name="M:PostSharp.Aspects.Arguments.ToArray">
            <summary>
              Converts the current argument list into an <see cref = "T:System.Array" />.
            </summary>
            <returns>An <see cref = "T:System.Array" /> whose elements are equal to the values encapsulated by the current <see cref = "T:PostSharp.Aspects.Arguments" />.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Clone">
            <summary>
              Returns a shallow copy of the current object.
            </summary>
            <returns>A shallow copy of the current object.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``1(``0)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 1 argument.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg0"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``2(``0,``1)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 2 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``3(``0,``1,``2)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 3 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``4(``0,``1,``2,``3)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 4 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``5(``0,``1,``2,``3,``4)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 5 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 6 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="args5"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 7 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="args5"></param>
            <param name="args6"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Creates a strongly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing 8 arguments.
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="args5"></param>
            <param name="args6"></param>
            <param name="args7"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.Create(System.Object[])">
            <summary>
            Creates a weakly-typed <see cref="T:PostSharp.Aspects.Arguments"/> object representing any number of arguments.
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.Arguments.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Arguments.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Aspect">
            <summary>
            Base class for all aspects that are declared using multicast custom attributes (<see cref="T:PostSharp.Extensibility.MulticastAttribute" />).
            </summary>
            <remarks>
            <para>This class is not specific to any kind of declaration (method, field, type, ...). 
             Considering deriving your aspect from <see cref="T:PostSharp.Aspects.TypeLevelAspect" />, <see cref="T:PostSharp.Aspects.MethodLevelAspect" />, <see cref="T:PostSharp.Aspects.LocationLevelAspect" />,
            or <see cref="T:PostSharp.Aspects.EventLevelAspect" /> if it should be applied to a specific kind of declarations.
            </para>
            <br />
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Aspect.AspectPriority">
            <summary>
              Gets or sets the weaving priority of the aspect.
            </summary>
            <value>The aspect priority, or <c>0</c> if the aspect priority is
              not specified.</value>
            <remarks>
              <para>Advices with lower priority are executed before in case of
                'entry' semantics (entering or invoking a method, setting a field
                value), but this order is inverted for advices of 'exit' semantics
                (leaving a method, getting a field value).
              </para>
              <para>This property must not be confused with 
                <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributePriority" />, which solely
                influences the multicasting process.</para>
            </remarks>
            <seealso href="@aspect-dependencies" target="_self">
      Conceptual: Coping with Several Aspects on the Same Target
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Aspect.SerializerType">
            <summary>
              Gets or sets the <see cref="T:System.Type" /> of the serializer (a type derived
              from <see cref="T:PostSharp.Aspects.Serialization.AspectSerializer" />) used to serialize the aspect instance
              at build time and deserialize it at runtime.
            </summary>
            <seealso href="@instance-initialization" target="_self">
      Conceptual: Aspect Serialization
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Aspect.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the aspect is applied to an unsupported target element.  This property affects only simple aspects, not composite aspects. 
            </summary>
            <remarks>
            This property only affects the built-in advices of the simple aspect classes, not advices of composite aspects. See <see href="@custom-aspects">the conceptual documentation</see> for details.  For composite aspects, use the <c>UnsupportedTargetAction</c> property of the advice custom attribute, e.g. <see cref="P:PostSharp.Aspects.Advices.OnMethodBoundaryAdvice.UnsupportedTargetAction"/>.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Aspect.PostSharp#Extensibility#IValidableAnnotation#CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration">
            <summary>
              Method invoked at build time to create a concrete <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance specifically
              for the current <see cref="T:PostSharp.Aspects.Aspect" /> type.
            </summary>
            <returns>A new and empty instance of <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />, whose concrete type corresponds to
              the concrete type of the <see cref="T:PostSharp.Aspects.Aspect" />.</returns>
            <remarks>
              This method should not set up the returned <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />. After the current method has
              returned, the <see cref="M:PostSharp.Aspects.Aspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)" /> method will be invoked, and this method is responsible
              for setting up the <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />object.
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Aspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetElement">Code element (<see cref="T:System.Reflection.Assembly" />, <see cref="T:System.Type" />, 
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
              <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.Aspect" />
              has been applied.
            </param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the 
                <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Aspect.GetAspectConfiguration(System.Object)">
            <summary>
              Method invoked at build tome to get the imperative configuration of the current <see cref="T:PostSharp.Aspects.Aspect" />.
            </summary>
            <param name="targetElement">Code element (<see cref="T:System.Reflection.Assembly" />, <see cref="T:System.Type" />, 
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
              <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref="T:PostSharp.Aspects.Aspect" />
              has been applied.
            </param>
            <returns>An <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> representing the imperative configuration
              of the current <see cref="T:PostSharp.Aspects.Aspect" />.</returns>
            <remarks>
              <para>This method can be customized by overriding <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> and/or
                <see cref="M:PostSharp.Aspects.Aspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)" /></para>.
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Aspect.CompileTimeValidate(System.Object)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="target">Code element (<see cref="T:System.Reflection.Assembly" />, <see cref="T:System.Type" />, 
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodBase" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.EventInfo" />, 
              <see cref="T:System.Reflection.ParameterInfo" />, or <see cref="T:PostSharp.Reflection.LocationInfo" />) to which the aspect has been applied.</param>
            <returns><c>true</c> if the aspect was applied to an acceptable target, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.AspectDescriptionAttribute">
            <summary>
            Custom attribute that, when applied to an aspect class, specifies a human-readable description of the aspect
            that can be displayed in PostSharp Tools for Visual Studio.
            </summary>
            <remarks>
            <para>This attribute is intended to be used on simple aspects like <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect"/> or
            <see cref="T:PostSharp.Aspects.MethodInterceptionArgs"/>. For composite aspects, specify the description of each advice
            using the <see cref="P:PostSharp.Aspects.Advices.Advice.Description"/> property.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.AspectDescriptionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Aspects.AspectDescriptionAttribute"/> class.
            </summary>
            <param name="description">A human-readable description of the aspect class to which
            the <see cref="T:PostSharp.Aspects.AspectDescriptionAttribute"/> custom attribute is applied.</param>
        </member>
        <member name="P:PostSharp.Aspects.AspectDescriptionAttribute.Description">
            <summary>
            Gets a human-readable description of the aspect class to which
            the <see cref="T:PostSharp.Aspects.AspectDescriptionAttribute"/> custom attribute is applied.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.AspectInfo">
            <summary>
              Reserved for future usage.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.AspectInstance">
            <summary>
              Completely specifies an aspect instance, including its target code element. An <see cref="T:PostSharp.Aspects.AspectInstance" />
              contains either the aspect instance itself (<see cref="T:PostSharp.Aspects.Aspect" /> property), either information allowing to construct the aspect 
              (<see cref="P:PostSharp.Aspects.AspectSpecification.AspectConstruction" />) and configure the weaver (<see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />).
            </summary>
            <see cref="T:PostSharp.Aspects.IAspectProvider" />
            <seealso href="@aspect-provider" target="_self">
      Conceptual: Adding Aspects Dynamically
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Aspects.IAspect)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AspectInstance" /> from a runtime aspect instance (<see cref = "T:PostSharp.Aspects.IAspect" />).
            </summary>
            <param name = "targetElement">Code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref = "T:PostSharp.Aspects.AspectInstance" />
              is applied.</param>
            <param name = "aspect">The aspect runtime instance.</param>
        </member>
        <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Aspects.IAspect,PostSharp.Aspects.Configuration.AspectConfiguration)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AspectInstance" /> from a runtime aspect instance (<see cref = "T:PostSharp.Aspects.IAspect" />)
              and its <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />.
            </summary>
            <param name = "targetElement">Code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref = "T:PostSharp.Aspects.AspectInstance" />
              is applied.</param>
            <param name = "aspect">The aspect runtime instance.</param>
            <param name = "aspectConfiguration">The aspect configuration (the type of this parameter should be equal to the
              type configuration objects expected by the concrete <paramref name = "aspect" />).</param>
        </member>
        <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Reflection.ObjectConstruction)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AspectInstance" /> from an <see cref="T:PostSharp.Reflection.ObjectConstruction"/>.
            </summary>
            <param name = "targetElement">Code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref = "T:PostSharp.Aspects.AspectInstance" />
              is applied.</param>
            <param name = "aspectConstruction">An <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> instructing how the aspect instance
              should be constructed.</param>
        </member>
        <member name="M:PostSharp.Aspects.AspectInstance.#ctor(System.Object,PostSharp.Reflection.ObjectConstruction,PostSharp.Aspects.Configuration.AspectConfiguration)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AspectInstance" /> from an <see cref="T:PostSharp.Reflection.ObjectConstruction"/> and specifies an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration"/> object.
            </summary>
            <param name = "targetElement">Code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref = "T:PostSharp.Aspects.AspectInstance" />
              is applied.</param>
            <param name = "aspectConstruction">An <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> instructing how the aspect instance
              should be constructed.</param>
            <param name = "aspectConfiguration">An optional configuration object whose type corresponds to 
              the aspect type.</param>
        </member>
        <member name="P:PostSharp.Aspects.AspectInstance.TargetElement">
            <summary>
              Gets the code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current <see cref = "T:PostSharp.Aspects.AspectInstance" />
              is applied.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.AspectInstance.RepresentAsStandalone">
            <summary>
            Determines whether the <see cref="T:PostSharp.Aspects.AspectInstance"/> should be represented as a stand-alone instance
            in PostSharp Tools for Visual Studio. If <c>false</c>, the current <see cref="T:PostSharp.Aspects.AspectInstance"/>
            will be not be represented as a standalone node, and its advices will be merged with the ones provided 
            by the parent aspect (implementing <see cref="T:PostSharp.Aspects.IAspectProvider"/>). The default value is <c>false</c>.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.AspectSpecification">
            <summary>
              Completely specifies an aspect instance (but not its target). An <see cref = "T:PostSharp.Aspects.AspectSpecification" /> either the aspect instance itself 
              (<see cref = "P:PostSharp.Aspects.AspectSpecification.Aspect" /> property), either information allowing to construct the aspect (<see cref = "P:PostSharp.Aspects.AspectSpecification.AspectConstruction" />) and configure the weaver (<see cref = "P:PostSharp.Aspects.AspectSpecification.AspectConfiguration" />).
            </summary>
            <remarks>
              User code cannot create an instance of the <see cref = "T:PostSharp.Aspects.AspectSpecification" /> class. Always create an instance of
              <see cref = "T:PostSharp.Aspects.AspectInstance" /> instead.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.AspectSpecification.#ctor(PostSharp.Aspects.IAspect,PostSharp.Reflection.ObjectConstruction)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AspectSpecification" /> from an aspect instance.
            </summary>
            <param name = "aspect">Aspect instance.</param>
            <param name = "aspectConstruction">Construction of the aspect (or <c>null</c> if the construction
              is not available - in this case the aspect is required to have a serializer).</param>
        </member>
        <member name="M:PostSharp.Aspects.AspectSpecification.#ctor(PostSharp.Reflection.ObjectConstruction,PostSharp.Aspects.Configuration.AspectConfiguration)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.AspectSpecification" /> when one cannot provide an aspect instance,
              i.e. from an <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> and a <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />.
            </summary>
            <param name = "aspectConstruction">Aspect construction.</param>
            <param name = "aspectConfiguration">Aspect configuration.</param>
        </member>
        <member name="P:PostSharp.Aspects.AspectSpecification.AspectConfiguration">
            <summary>
              Gets the aspect configuration.
            </summary>
            <value>
              The aspect configuration, or <c>null</c> if none was provided.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.AspectSpecification.AspectConstruction">
            <summary>
              Gets the aspect construction.
            </summary>
            <value>
              The aspect construction, or <c>null</c> if the aspect instance was provided instead.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.AspectSpecification.Aspect">
            <summary>
              Gets the aspect instance.
            </summary>
            <value>
              The aspect instance, or <c>null</c> if the <see cref = "P:PostSharp.Aspects.AspectSpecification.AspectConfiguration" /> was provided instead.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.AspectSpecification.AspectAssemblyQualifiedTypeName">
            <summary>
              Gets the assembly-qualified type name of the aspect.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.AspectSpecification.AspectTypeName">
            <summary>
              Gets the type name of the aspect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.AspectUtilities">
            <summary>
              Utility methods for <c>PostSharp.Aspects</c>.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.AspectUtilities.InitializeCurrentAspects">
            <summary>
              Initializes the all the aspects of the calling instance. This method must be
              invoked from an instance method (not a static method) of a type that has been enhanced
              by an aspect.
            </summary>
            <remarks>
              <para>
                Calls to this method are transformed, at build time, to calls to
                <b>this.InitializeAspects</b>, a method that is typically generated by <c>PostSharp</c>. 
                This is why the current method has actually no implementation.
              </para>
              <para>
                The constructors of enhanced classes always initialize aspects. The only scenario
                where this method needs to be invoked manually is when instances are not built
                using the constructor, but for instance with the method <see cref="M:System.Runtime.Serialization.FormatterServices.GetUninitializedObject(System.Type)" />.
              </para>
            </remarks>
            <seealso href="@instance-initialization" target="_self">
      Conceptual: Coping with Custom Serializers
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.AssemblyLevelAspect">
            <summary>
            Base class for all aspects applied on assemblies.
            </summary>
            <seealso cref="T:PostSharp.Aspects.IAssemblyLevelAspect" />
            <remarks>
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.AssemblyLevelAspect.CompileTimeValidate(System.Reflection.Assembly)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="assembly">Assembly on which the current aspect is applied.</param>
            <returns><c>true</c> if the aspect was applied to an acceptable target, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.AssemblyLevelAspect.CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.AssemblyLevelAspect.CompileTimeInitialize(System.Reflection.Assembly,PostSharp.Aspects.AspectInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.AssemblyLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.Assembly)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetAssembly">Assembly to which the current aspect has been applied.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the 
                <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.AssemblyLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.AsyncCallId">
            <summary>
            Identifier of an asynchronous method invocation, i.e. of a unique async state machine instance.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.AsyncCallId.IsNull">
            <summary>
            Determines whether the current <see cref="T:PostSharp.Aspects.AsyncCallId"/> is null.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.AsyncCallId.Null">
            <summary>
            Gets a null instance of the <see cref="T:PostSharp.Aspects.AsyncCallId"/> struct.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.GetNext">
            <exclude/>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.Equals(PostSharp.Aspects.AsyncCallId)">
            <inheritdoc/>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.op_Equality(PostSharp.Aspects.AsyncCallId,PostSharp.Aspects.AsyncCallId)">
            <summary>
            Determines whether two instances of the <see cref="T:PostSharp.Aspects.AsyncCallId"/> type are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.op_Inequality(PostSharp.Aspects.AsyncCallId,PostSharp.Aspects.AsyncCallId)">
            <summary>
            Determines whether two instances of the <see cref="T:PostSharp.Aspects.AsyncCallId"/> type are different.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.AsyncCallId.ToString">
            <inheritdoc/>
        </member>
        <member name="T:PostSharp.Aspects.CompositionAspect">
            <summary>
            Aspect that, when applied on a type, introduces one or many new interfaces
            into that type. 
            </summary>
            <remarks>
            <note>
              Consider using a composite aspect and introducing an interface using <see cref="T:PostSharp.Aspects.Advices.IntroduceMemberAttribute" /> 
             instead of using a <see cref="T:PostSharp.Aspects.CompositionAspect" />.
            </note>
            <para>
            The <see cref="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" /> method 
            is invoked at build time. At runtime, the method <see cref="M:PostSharp.Aspects.CompositionAspect.CreateImplementationObject(PostSharp.Aspects.AdviceArgs)" />
            should return an object implementing all interfaces.
            </para>
            <para>
            Use the <see cref="T:PostSharp.Post" />.<see cref="M:PostSharp.Post.Cast``2(``0)" />
            method to cast the enhanced type to the newly implemented interface. This
            cast is verified during post-compilation.
            </para>
            <para>
                Properties <see cref="P:PostSharp.Aspects.CompositionAspect.OverrideAction" /> and <see cref="P:PostSharp.Aspects.CompositionAspect.AncestorOverrideAction" /> determine
            what should happen if the target type already implements the interface directly or indirectly.
            </para>
            <para>
             By default, the object implementing the interface is stored as a serializable field. If the property
            <see cref="P:PostSharp.Aspects.CompositionAspect.NonSerializedImplementation" /> is set to <c>true</c>, this field will be marked
            as <see cref="T:System.NonSerializedAttribute" />.
            </para>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Advices.IntroduceInterfaceAttribute" />
            <seealso href="@interface-introduction" target="_self">
      Conceptual: Introducing Interfaces
    </seealso>
            
        </member>
        <member name="M:PostSharp.Aspects.CompositionAspect.CreateImplementationObject(PostSharp.Aspects.AdviceArgs)">
            <summary>
              Method invoked at runtime, during the initialization of instances of the target type,
              to create the composed object.
            </summary>
            <returns>The composed object. This interface should implement the interfaces specified
              by the <see cref = "M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" /> method.</returns>
            <remarks>
              This method is invoked during at runtime after the base constructor has executed, and before
              the constructor of the current type is executed.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)">
            <summary>
              Gets the array of interfaces that should be introduced publicly into
              the target type of the current aspect.
            </summary>
            <param name = "targetType"><see cref = "T:System.Type" /> to which the current aspect is applied.</param>
            <returns>The array of interfaces that should be introduced publicly into <see cref = "T:System.Type" />
              <paramref name = "targetType" />, or <c>null</c> if no interface should
              be introduced publicly.</returns>
        </member>
        <member name="P:PostSharp.Aspects.CompositionAspect.OverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when one of the interfaces returned by the <see cref = "M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" /> method
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.CompositionAspect.AncestorOverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.CompositionAspect.AncestorOverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when an <i>ancestor</i> of one of the interfaces returned by <see cref = "M:PostSharp.Aspects.CompositionAspect.GetPublicInterfaces(System.Type)" />
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.CompositionAspect.OverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.CompositionAspect.NonSerializedImplementation">
            <summary>
              Determines whether the field containing the interface implementation (and storing the object returned by
              <see cref = "M:PostSharp.Aspects.CompositionAspect.CreateImplementationObject(PostSharp.Aspects.AdviceArgs)" />) should be excluded from serialization by <see cref = "T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />.
              The same effect is typically obtained by applying the <see cref = "T:System.NonSerializedAttribute" /> custom attribute to the field.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.CompositionAspect.GenerateImplementationAccessor">
            <summary>
              This property has no effect.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.CompositionAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.CompositionAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Configuration.AspectConfiguration">
            <summary>
              Configuration of an <see cref="T:PostSharp.Aspects.IAspect" />.
            </summary>
            <remarks>
              Every concrete aspect class has a corresponding configuration class derived from <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfiguration.AspectPriority">
            <summary>
              Gets or sets the aspect priority. Aspects with smaller priority are processed first. The default priority is zero.
            </summary>
            <remarks>
              Whenever possible, use dependencies (<see cref = "P:PostSharp.Aspects.Configuration.AspectConfiguration.Dependencies" /> collection) to specify the ordering of aspects.
              Unlike priorities, dependencies scale up in complexity, which can be important in larger projects.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfiguration.SerializerType">
            <summary>
              Gets or sets the type of the serializer that will be used
              to configure the current aspect.
            </summary>
            <remarks>
              The type assigned to this property must derive from the <see cref = "T:PostSharp.Aspects.Serialization.AspectSerializer" /> class
              and have a default constructor. Use <see cref="T:PostSharp.Aspects.Serialization.MsilAspectSerializer"/> to specify that the aspect will not
              be serialized, but will be constructed using MSIL instructions.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfiguration.Dependencies">
            <summary>
              Gets or sets the collection of dependencies.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfiguration.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the aspect is applied to an unsupported target element.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute">
            <summary>
              Configures an aspect of type <see cref="T:PostSharp.Aspects.IAspect" />.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.AspectPriority">
            <summary>
              Gets or sets the weaving priority of the aspect.
            </summary>
            <value>The aspect priority, or <c>null</c> if the aspect priority is not specified.</value>
            <remarks>
              <para>Advices with lower priority are executed before in case of 'entry' semantics (entering or invoking a
                method, setting a field value), but this order is inverted for advices of 'exit' semantics (leaving a
                method, getting a field value).
              </para>
              <para>This property must not be confused with <see cref = "P:PostSharp.Extensibility.MulticastAttribute.AttributePriority" />, which
                solely influences the multicasting process.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.SerializerType">
            <summary>
              Gets or sets the <see cref = "T:System.Type" /> of the serializer that will be used
              to configure the current aspect.
            </summary>
            <remarks>
              <para>The type assigned to this property must derive from the <see cref = "T:PostSharp.Aspects.Serialization.AspectSerializer" /> class
                and have a default constructor. Use <see cref="T:PostSharp.Aspects.Serialization.MsilAspectSerializer"/> to specify that the aspect will not
                be serialized, but will be constructed using MSIL instructions.
              </para>
              <para></para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.CreateAspectConfiguration">
            <summary>
              Creates a concrete <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance specifically for the current 
              <see cref = "T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute" /> type.
            </summary>
            <returns>A new and empty instance of <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />, whose concrete type corresponds to
              the concrete type of the <see cref = "T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute" />.</returns>
            <remarks>
              This method should not set up the returned <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />. After the current method has
              returned, the <see cref = "M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration)" /> method will be invoked, and this method is responsible
              for setting up the <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />object.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.GetAspectConfiguration">
            <summary>
              Gets the <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" /> corresponding to the current custom attribute.
            </summary>
            <returns>An <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" /> corresponding to the current custom attribute.</returns>
            <remarks>
              <para>This method can be customized by overriding <see cref = "M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.CreateAspectConfiguration" /> and/or
                <see cref = "M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration)" /></para>.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration)">
            <summary>
              Sets up an <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current  custom attribute instance.
            </summary>
            <param name = "aspectConfiguration">The <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref = "M:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.CreateAspectConfiguration" /> method.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.AspectConfigurationAttributeTypeAttribute">
            <summary>
            Custom attribute that, when applied to an aspect, specifies which custom attribute type
            (derived from <see cref="T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute"/>) can provide declarative configuration for the aspect.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.AspectConfigurationAttributeTypeAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute"/>.
            </summary>
            <param name="type">Custom attribute type
            (derived from <see cref="T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute"/>).</param>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.AspectConfigurationAttributeTypeAttribute.AttributeType">
            <summary>
            Gets the type of the custom attribute 
            (derived from <see cref="T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute"/>) that can provide declarative configuration for the aspect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.CompositionAspectConfiguration">
            <summary>
              Configuration of aspects of type <see cref="T:PostSharp.Aspects.ICompositionAspect" />.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.PublicInterfaces">
            <summary>
              Gets or sets the array of interfaces that should be introduced publicly into the target type of the aspect.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.OverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when one of the interfaces specified by <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.PublicInterfaces" /> 
              is already implemented by the type to which the aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.AncestorOverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.AncestorOverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when an <i>ancestor</i> of one of the interfaces specified by <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.PublicInterfaces" />
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.OverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.NonSerializedImplementation">
            <summary>
              Determines whether the field containing the interface implementation (and storing the object returned by
              <see cref = "M:PostSharp.Aspects.ICompositionAspect.CreateImplementationObject(PostSharp.Aspects.AdviceArgs)" />) should be excluded from serialization by <see cref = "T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />.
              The same effect is typically obtained by applying the <see cref = "T:System.NonSerializedAttribute" /> custom attribute to the field.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfiguration.GenerateImplementationAccessor">
            <summary>
              This property has no effect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute">
            <summary>
              Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.ICompositionAspect" />,
              defines the declarative configuration of that aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute" />
            <seealso cref="T:PostSharp.Aspects.CompositionAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.PublicInterfaces">
            <summary>
              Gets or sets the array of type names of interfaces that should be introduced publicly into
              the target type of the aspect.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.ProtectedInterfaces">
            <summary>
              Gets or sets the array of type names of interfaces to be introduced indirectly into the target type of the aspect.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.OverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when one of the interfaces specified by <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.PublicInterfaces" /> or <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.ProtectedInterfaces" />
              is already implemented by the type to which the aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.AncestorOverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.AncestorOverrideAction">
            <summary>
              Specifies the action (<see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Fail" /> or <see cref = "F:PostSharp.Aspects.Advices.InterfaceOverrideAction.Ignore" />)
              to be overtaken when an <i>ancestor</i> of one of the interfaces specified by <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.PublicInterfaces" />
              is already implemented by the type to which the current aspect is applied.
            </summary>
            <seealso cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.OverrideAction" />
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.NonSerializedImplementation">
            <summary>
              Determines whether the field containing the interface implementation (and storing the object returned by
              <see cref = "M:PostSharp.Aspects.ICompositionAspect.CreateImplementationObject(PostSharp.Aspects.AdviceArgs)" />) should be excluded from serialization by <see cref = "T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" />.
              The same effect is typically obtained by applying the <see cref = "T:System.NonSerializedAttribute" /> custom attribute to the field.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.GenerateImplementationAccessor">
            <summary>
              This property has no effect.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Configuration.CustomAttributeIntroductionAspectConfiguration">
            <summary>
              Configuration of aspects of type <see cref="T:PostSharp.Aspects.CustomAttributeIntroductionAspect" />.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.CustomAttributeIntroductionAspectConfiguration.ObjectConstruction">
            <summary>
              Gets or sets the construction of the custom attribute that must be applied to the target of this aspect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.EventInterceptionAspectConfiguration">
            <summary>
              Configuration of aspects of type <see cref="T:PostSharp.Aspects.IEventInterceptionAspect" />.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.EventInterceptionAspectConfigurationAttribute" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.EventInterceptionAspectConfigurationAttribute">
            <summary>
              Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IEventInterceptionAspect" />,
              defines the declarative configuration of that aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.EventInterceptionAspectConfiguration" />
            <seealso cref="T:PostSharp.Aspects.EventInterceptionAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.EventInterceptionAspectConfigurationAttribute.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfiguration">
            <summary>
              Configuration of aspects of type <see cref="T:PostSharp.Aspects.ILocationLevelAspect" />.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfigurationAttribute">
            <summary>
              Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.ILocationInterceptionAspect" />,
              defines the declarative configuration of that aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfiguration" />
            <seealso cref="T:PostSharp.Aspects.LocationLevelAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfigurationAttribute.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration">
            <summary>
              Configuration of aspects of type <see cref="T:PostSharp.Aspects.ManagedResourceIntroductionAspect" />.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration.#ctor(System.String,System.Byte[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration" />.
            </summary>
            <param name = "name">Name of the managed resource.</param>
            <param name = "data">Content of the managed resource.</param>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration.#ctor(System.String,System.Func{System.Byte[]})">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration" />
            by passing a delegate for late evaluation of the resource content.
            </summary>
            <param name = "name">Name of the managed resource.</param>
            <param name = "dataProvider">A method that returns the data to be introduced. If the method returns <c>null</c>,
            the aspect will be ignored and no managed resource will be introduced.</param>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration.Name">
            <summary>
              Gets the name of the managed resource.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration.Data">
            <summary>
              Gets the content of the managed resource.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration.DataProvider">
            <summary>
            Gets a delegate that provides content of the managed resource.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfiguration">
            <summary>
              Configuration of aspects of type <see cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute" />
            <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfiguration.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the aspect when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute">
            <summary>
              Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IMethodInterceptionAspect" />,
              defines the declarative configuration of that aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
            <seealso cref="T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfiguration" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Configuration.OnExceptionAspectConfiguration">
            <summary>
              Configuration of the <see cref="T:PostSharp.Aspects.IOnExceptionAspect" /> aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.OnExceptionAspect" />
            <seealso cref="T:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.OnExceptionAspectConfiguration.ExceptionType">
            <summary>
              Gets or sets the type of exceptions that are caught by this aspect.
            </summary>
            <remarks>
              If this property is <c>null</c>, any <see cref = "T:System.Exception" /> shall be caught.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.OnExceptionAspectConfiguration.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the aspect when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute">
            <summary>
              Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IOnExceptionAspect" />,
              defines the configuration of that aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.OnExceptionAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute.ExceptionType">
            <summary>
              Gets or sets the type of exceptions that are caught by this aspect.
            </summary>
            <remarks>
              If this property is <c>null</c>, any <see cref = "T:System.Exception" /> shall be caught.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfiguration">
            <summary>
              Configuration of the <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" /> aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfigurationAttribute" />
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfiguration.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the aspect when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfigurationAttribute">
            <summary>
              Custom attribute that, when applied on a class implementing <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" />,
              defines the configuration of that aspect.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfiguration" />
            <seealso cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfigurationAttribute.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.ConstructorDepth">
            <summary>
            System type used in the implementation of the <see cref="T:PostSharp.Aspects.Advices.OnInstanceConstructedAdvice"/>. Do not use in user code.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ConstructorDepth.Increment">
            <summary>
            Creates a new instance of the <see cref="T:PostSharp.Aspects.ConstructorDepth"/> type with a depth level that is one more than the current one.
            </summary>
            <returns>A new <see cref="T:PostSharp.Aspects.ConstructorDepth"/>, incremented of one from the current <see cref="T:PostSharp.Aspects.ConstructorDepth"/>.</returns>
        </member>
        <member name="P:PostSharp.Aspects.ConstructorDepth.IsZero">
            <summary>
            Determines whether the current depth is zero.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ConstructorDepth.Zero">
            <summary>
            Gets a <see cref="T:PostSharp.Aspects.ConstructorDepth"/> instance representing zero.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ConstructorDepth.ToString">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.CustomAttributeIntroductionAspect">
            <summary>
              Aspect that, when applied to a target, adds a custom attribute to this target.
            </summary>
            <remarks>
              <para>
                There are two ways to specify a custom attribute: either using an
                <see cref="T:PostSharp.Reflection.ObjectConstruction" /> (to construct a new custom attribute), 
                either a <see cref="T:System.Reflection.CustomAttributeData" /> (to copy a custom attribute reflected 
                using one of the overload of the method <see cref="M:System.Reflection.CustomAttributeData.GetCustomAttributes(System.Reflection.Assembly)" />/
              </para>
              <note>
                This aspect is not a custom attribute. You have to create another aspect
                implementing <see cref="T:PostSharp.Aspects.IAspectProvider" /> and have the method <see cref="M:PostSharp.Aspects.IAspectProvider.ProvideAspects(System.Object)" />
                return instances of this aspect.
              </note>
            </remarks>
            <seealso href="@aspect-provider" target="_self">
      Conceptual: Adding Aspects Dynamically
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.CustomAttributeIntroductionAspect.#ctor(PostSharp.Reflection.ObjectConstruction)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.CustomAttributeIntroductionAspect" /> by specifying an <see cref = "T:PostSharp.Reflection.ObjectConstruction" />.
            </summary>
            <param name = "attribute">Construction of the custom attribute to be added to the target.</param>
        </member>
        <member name="M:PostSharp.Aspects.CustomAttributeIntroductionAspect.#ctor(System.Reflection.CustomAttributeData)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.CustomAttributeIntroductionAspect" /> by specifying a
              <see cref = "T:System.Reflection.CustomAttributeData" />.
            </summary>
            <param name = "customAttributeData">Construction of the custom attribute to be added to the target.</param>
        </member>
        <member name="P:PostSharp.Aspects.CustomAttributeIntroductionAspect.CustomAttribute">
            <summary>
              Gets the construction of the custom attribute that must be applied to the target of this aspect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute">
            <summary>
              Specifies an aspect dependency matching an advice of the same aspect instance.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute" /> and specifies a position.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "position">Dependency position.</param>
            <param name = "adviceMethodName">Name of the advice method.</param>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute" /> without specifying the position,
              implicitly set to <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "adviceMethodName">Name of the advice method.</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AdviceDependencyAttribute.AdviceMethodName">
            <summary>
              Gets the name of the method implementing the advice.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyAction">
            <summary>
              Enumeration of the different kinds of relationships of specified by aspect dependencies.
            </summary>
            <remarks>
              <para>The combined values of <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAction" /> and <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyPosition" /> is interpreted
                as follows:</para>
              <table>
                <tr>   <th>Action</th>   <th>Position</th>   <th>Description</th>  </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After" /></td>
                  <td>The current aspect or advice should be positioned <i>after</i> the other aspect or advice
                    matched by the custom attribute.</td>
                </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before" /></td>
                  <td>The current aspect or advice should be positioned <i>before</i> the other aspect or advice
                    matched by the custom attribute.</td>
                </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" /></td>
                  <td>The current aspect or advice requires another aspect or advice
                    matched by the custom attribute, at any position.</td>
                </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After" /></td>
                  <td>The current aspect or advice requires another aspect or advice
                    matched by the custom attribute positioned <i>after</i> the current one.</td>
                </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before" /></td>
                  <td>The current aspect or advice requires another aspect or advice
                    matched by the custom attribute positioned <i>before</i> the current one.</td>
                </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" /></td>
                  <td>The current aspect or advice conflicts with any aspect or advice
                    matched by the custom attribute, at any position.</td>
                </tr>
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After" /></td>
                  <td>The current aspect or advice conflicts with any aspect or advice
                    matched by the custom attribute, if positioned <i>after</i> the current one.</td>
                </tr>  
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" /></td>
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before" /></td>
                  <td>The current aspect or advice conflicts with any aspect or advice
                    matched by the custom attribute, if positioned <i>before</i> the current one.</td>
                </tr>   
                <tr>   
                  <td><see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Commute" /></td>
                  <td></td>
                  <td>The current aspect or advice commute with any other aspect or advice
                    matched by the custom attribute.
                  </td></tr>
              </table>
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.None">
            <summary>
              The dependency is ignored.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order">
            <summary>
              The dependency specifies an order relationship.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require">
            <summary>
              The dependency specifies that the current aspect or advice requires
              another aspect or advice.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict">
            <summary>
              The dependency specifies that the current aspect or advice
              conflicts with another aspect or advice.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Commute">
            <summary>
              The dependency specifies that the current aspect or advice
              commutes with another aspect or advice.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute">
            <summary>
              Base class for all custom attributes defining aspect dependencies. An aspect dependency determines the
              behavior of aspects or advices when used in conjunction with other aspects and advices.
              Aspect dependencies determine ordering, requirements, conflicts, and commutativity of aspects and advices.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" /> without specifying the position,
              implicitly set to <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
            <param name = "action">Dependency action.</param>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" /> and specifies a position.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "position">Dependency position.</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Action">
            <summary>
              Gets the dependency action, i.e. the kind of relationship specified by the dependency
              (<see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Order" />, <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />,
              <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />, or <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Commute" />).
            </summary>
            <remarks>
              See documentation of <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAction" /> for a description of the meaning of combined <see cref = "P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Action" />
              and <see cref = "P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Position" /> properties.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Position">
            <summary>
              Gets the position of the current dependency, i.e. actually the position of the <i>other</i>
              aspect or advices with respect to the one related to this dependency.
            </summary>
            <remarks>
              See documentation of <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAction" /> for a description of the meaning of combined <see cref = "P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Action" />
              and <see cref = "P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Position" /> properties.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.Target">
            <summary>
              Determines the target (<see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Default" /> or <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type" />)
              to which the aspect dependency apply.
            </summary>
            <remarks>
              See the documentation of <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyTarget" /> for details.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.IsWarning">
            <summary>
              If <c>true</c>, specifies that the constraint (of type <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Require" />
              or <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyAction.Conflict" />) should emit a warning instead of an error if not
              respected.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectDependencyAttribute.TargetType">
            <summary>
              Aspect type to which this dependency applies. This property is required when the
              custom attribute is applied at assembly level. It is ignored when applied on
              class or method level.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyAttributeCollection">
            <summary>
              Collection of <see cref = "T:PostSharp.Aspects.Dependencies.AspectDependencyAttribute" />.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyPosition">
            <summary>
              Enumeration of the direction of the relationship specified by an aspect dependency.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any">
            <summary>
              Any order possible (or order not relevant).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Before">
            <summary>
              The current aspect or advice is positioned before the other aspect or handler.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.After">
            <summary>
              The current aspect or advice is positioned after the other aspect or handler.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectDependencyTarget">
            <summary>
              Enumeration of targets (<see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Default" /> or <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type" />)
              to which the aspect dependency apply.
            </summary>
            <remarks>
              <para>This property is meaningful only for aspects that apply to type members. For aspects that 
                apply to types, type-level and default-level dependencies are the same thing.</para>
              <para>Member-level aspects may have semantics that actually apply at type level (for instance
                member introductions and imports). By setting the dependency target to
                <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type" />, you can specify that the aspect dependency applies
                to type-level semantics. Otherwise, it will apply to member-level semantics.</para>
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Default">
            <summary>
              Natural target of the aspect.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.AspectDependencyTarget.Type">
            <summary>
              Declaring type of the natural target of the aspect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute">
            <summary>
              Specifies an aspect dependency matching aspects or advices having a given effect.
            </summary>
            <remarks>
              <para>
                All aspects (except the ones that have an empty implementation) have an effect on the program execution.
                The current custom attribute allows to express dependencies to aspects according to their effect.
              </para>
              <para>The list of standard effects is given in class <see cref="T:PostSharp.Aspects.Dependencies.StandardEffects" />. All advices have
                implicitly the effect <see cref="F:PostSharp.Aspects.Dependencies.StandardEffects.Custom" />. Most advices also have the effect
                <see cref="F:PostSharp.Aspects.Dependencies.StandardEffects.ChangeControlFlow" />, because they are able to modify the control flow (for instance, 
                skip the execution of the intercepted method or throwing an exception). An aspect or advice can declare
                it does <i>not</i> have a given effect by using the <see cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" /> custom attribute.
              </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Dependencies.StandardEffects" />
            <seealso cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> and specifies a position.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "position">Dependency position.</param>
            <param name = "effect">Effect (see <see cref = "T:PostSharp.Aspects.Dependencies.StandardEffects" />).</param>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> without specifying the position,
              implicitly set to <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "effect">Effect (see <see cref = "T:PostSharp.Aspects.Dependencies.StandardEffects" />).</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute.Effect">
            <summary>
              Gets the effect that the aspects or advices must have in order to match the current dependency.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute">
            <summary>
              Specifies an aspect dependency matching aspects or advices that are a part of a given role.
            </summary>
            <remarks>
              <para>
                A role describes what the aspect actually does. A list of standard roles is available on the class
                <see cref="T:PostSharp.Aspects.Dependencies.StandardRoles" />. Aspect vendors are encouraged to enroll their aspects in one of these
                roles whenever it makes sense, and to document the other roles they have used.
              </para>
              <para>An aspect or advice can be enrolled in a role by using the <see cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />
                custom attribute.
              </para>
            </remarks>/// <seealso cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />
            <seealso cref="T:PostSharp.Aspects.Dependencies.StandardRoles" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" /> and specifies a position.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "position">Dependency position.</param>
            <param name = "role">Role.</param>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> without specifying the position,
              implicitly set to <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "role">Role.</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute.Role">
            <summary>
              Gets the role that the aspects or advices must be a part of in order to match the current dependency.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute">
            <summary>
              Specifies an aspect dependency matching aspects of a specified type, and all its advices.
            </summary>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,PostSharp.Aspects.Dependencies.AspectDependencyPosition,System.Type)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute" /> and specifies a position.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "position">Dependency position.</param>
            <param name = "aspectType">Aspect type (derived from <see cref = "T:PostSharp.Aspects.IAspect" />).</param>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute.#ctor(PostSharp.Aspects.Dependencies.AspectDependencyAction,System.Type)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute" /> without specifying the position,
              implicitly set to <see cref = "F:PostSharp.Aspects.Dependencies.AspectDependencyPosition.Any" />.
            </summary>
            <param name = "action">Dependency action.</param>
            <param name = "aspectType">Aspect type (derived from <see cref = "T:PostSharp.Aspects.IAspect" />).</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.AspectTypeDependencyAttribute.AspectType">
            <summary>
              Gets the type from which the aspects should be derived in order to match the current dependency.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute">
            <summary>
              Specifies that the aspect or aspect advice to which this custom attribute is applied is a
              part of a given role. This aspect or advice can then be matched by <see cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" />/
            </summary>
            <seealso cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute.#ctor(System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />.
            </summary>
            <param name = "role">Role.</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute.Role">
            <summary>
              Gets the role into which the aspect or advice to which this custom
              attribute is applied will be enrolled.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.StandardEffects">
            <summary>
              List of standard effects.
            </summary>
            <remarks>
              <para>See <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> for a discussion of effects.</para>
              <para>This list is not meant to be extended by vendors providing concrete aspects (implementing some business
                functionality). Roles should be used to categorized the business effect of concrete aspects. However, if you
                implement a new kind of abstract aspect  (for instance member suppression), you may need to define new effects.
              </para>
              <para>
                In that case, we at <c>PostSharp</c> encourage you contact us to define a new role string. If you define a
                new role string, we recommend you clearly define it so that users of your aspect can express dependencies
                with their own aspects, or third-party aspects.</para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" />
            <seealso cref="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" />
            <seealso cref="T:PostSharp.Aspects.Dependencies.StandardRoles" />
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.MemberImport">
            <summary>
              Import of a type member.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.CustomAttributeIntroduction">
            <summary>
              Introduction of a custom attribute.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.InterfaceIntroduction">
            <summary>
              Introduction of an interface.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.MemberIntroduction">
            <summary>
              Introduction of a type member.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.Custom">
            <summary>
              Custom effect (implemented in an aspect advice). All advices have this effect by default,
              unless they are annotated by <see cref = "T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" />.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardEffects.ChangeControlFlow">
            <summary>
              Change the flow control (for instance by having the possibility to skip execution of an
              intercepted method).
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.StandardEffects.GetMemberIntroductionEffect(System.String)">
            <summary>
              Gets a string representing the effect of introducing a member into a type.
            </summary>
            <param name = "memberName">Name of the introduced member.</param>
            <returns>A string that, by convention, represents the introduction of a member named
              <paramref name = "memberName" /> into a type.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.StandardEffects.GetMemberImportEffect(System.String)">
            <summary>
              Gets a string representing the effect of importing a member into from the target
              type into the aspect.
            </summary>
            <param name = "memberName">Name of the imported member.</param>
            <returns>A string that, by convention, represents the import of a member named
              <paramref name = "memberName" /> from the target type into the aspect.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.StandardEffects.GetInterfaceIntroductionEffect(System.String)">
            <summary>
              Gets a string representing the effect of introducing an interface into a type.
            </summary>
            <param name = "typeName">Name of the introduced interface.</param>
            <returns>A string that, by convention, represents the introduction of an interface named
              <paramref name = "typeName" /> into a type.</returns>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.StandardRoles">
            <summary>
              List of standard roles.
            </summary>
            <remarks>
              <para>See <see cref="T:PostSharp.Aspects.Dependencies.AspectRoleDependencyAttribute" /> for a discussion of aspect roles.</para>
              <para>Roles are used to categorize aspects according to their function. This class
                defines standard names for the most commonly used aspect roles. If you are an aspect vendor,
                you are encouraged to enroll your aspects (using <see cref="T:PostSharp.Aspects.Dependencies.ProvideAspectRoleAttribute" />) into
                one of these roles. 
              </para>
              <para>
                If this list is not sufficient, we at <c>PostSharp</c> encourage you
                contact us to define a new role string. In any case, if you define a new role string, we recommend you
                clearly define it so that users of your aspect can express dependencies with their own aspects,
                or third-party aspects.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Validation">
            <summary>
              Validation of field, property, or parameter value.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Tracing">
            <summary>
              Tracing and logging.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.PerformanceInstrumentation">
            <summary>
              Performance instrumentation (for instance performance counters).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Security">
            <summary>
              Security enforcing (typically authorization).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Caching">
            <summary>
              Caching.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.TransactionHandling">
            <summary>
              Transaction handling.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.ExceptionHandling">
            <summary>
              Exception handling.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.DataBinding">
            <summary>
              Data binding (for instance implementation of <see cref = "T:System.ComponentModel.INotifyPropertyChanged" />).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Persistence">
            <summary>
              Object persistence (for instance Object-Relational Mapper).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.EventBroker">
            <summary>
              Event broker (a system role used internally by <c>PostSharp</c> to realize
              the <see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />  handler).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Dependencies.StandardRoles.Threading">
            <summary>
              Threading (locking).
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute">
            <summary>
              Declares that the aspect class or advice to which this custom attribute is applied
              is exempt of a given effect.
            </summary>
            <remarks>
              See <see cref="T:PostSharp.Aspects.Dependencies.AspectEffectDependencyAttribute" /> for details about effects.
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" /> declaring that
              the aspect class or advice to which this custom attribute is applied has
              no effect at all.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute.#ctor(System.String[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute" /> declaring that
              the aspect class or advice to which this custom attribute is applied is
              exempt of the specified effects.
            </summary>
            <param name = "effects">List of effects of which the aspect class or advice
              to which this custom attribute is applied is guaranteed to be exempt.</param>
        </member>
        <member name="P:PostSharp.Aspects.Dependencies.WaiveAspectEffectAttribute.Effects">
            <summary>
            Gets the list of effects of which the aspect class or advice
            to which this custom attribute is applied is guaranteed to be exempt.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.EventInterceptionArgs">
            <summary>
              Arguments of handlers of aspects of the type <see cref="T:PostSharp.Aspects.EventInterceptionAspect" />.
            </summary>
            <seealso cref="T:PostSharp.Aspects.EventInterceptionAspect" />
            <remarks>
              <note>
      As a result of weaving optimizations, instances of classes derived from
      <see cref="T:PostSharp.Aspects.AdviceArgs" />
      may be shared among different aspects. Therefore,
      aspect code should not attempt to access this object once the control has been given over to the next node in the chain of invocation. Consider working
      with
      <see href="@interception-aspects" target="_self">aspect bindings</see>
      if you need such deferred execution.
    </note><note>
      Aspect weaving optimizations may also cause an advice parameter of this type to be seen <c>null</c> when inspecting it in a debugger.
      If you need to inspect the instance in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.EventInterceptionAspect" />
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.#ctor(System.Object,PostSharp.Aspects.Arguments,System.Delegate)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.EventInterceptionArgs" />.
            </summary>
            <param name = "instance">The instance related to the aspect handler invocation, or
              <c>null</c> if the handler is associated to a static element.</param>
            <param name = "arguments">Arguments of <paramref name = "handler" />, when it is being invoked.</param>
            <param name = "handler">The delegate being added to the event, removed from the event, or invoked.</param>
        </member>
        <member name="P:PostSharp.Aspects.EventInterceptionArgs.Binding">
            <summary>
              Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
            <remarks>
              <para>
      Bindings are thread-safe and context-free singleton instances exposing the next node in the chain of invocation.
    </para><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.EventInterceptionArgs.Handler">
            <summary>
              Gets the delegate being added, removed, or invoked.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.EventInterceptionArgs.ReturnValue">
            <summary>
              Gets the return value of the delegate.
            </summary>
            <remarks>
              <para>This property is meaningful only during a delegate invocation (not during an addition or removal).</para>
              <para>This property is typically set by the <see cref = "M:PostSharp.Aspects.EventInterceptionArgs.ProceedInvokeHandler" /> method. It is also legal for
                an implementation of <see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" /> to change the value of this property.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.EventInterceptionArgs.Event">
            <summary>
              Gets the event to which the current aspect has been applied.
            </summary>
            <remarks>
              <note>
                Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
                this property whenever possible. One of the possible solution is to use compile-time initialization of
                aspect instances and to make use of reflection only at build time.
              </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.EventInterceptionArgs.Arguments">
            <summary>
              Gets the delegate arguments.
            </summary>
            <remarks>
              <para>This property is meaningful only during a delegate invocation (not during an addition or removal).</para>
              <para>This property is typically accessed by the <see cref = "M:PostSharp.Aspects.EventInterceptionArgs.ProceedInvokeHandler" /> method. Implementations of
                <see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" /> can also get or change the value of this property.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.ProceedAddHandler">
            <summary>
              Proceeds with adding the <see cref = "T:System.Delegate" /> to the event to which the current aspect. 
              This method invokes the next handler in chain. 
              It is typically invoked from the implementation of <see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.AddHandler(System.Delegate)">
            <summary>
              Adds a handler to the event by invoking the <c>Add</c> semantic of the next node in the chain of invocation.
            </summary>
            <param name = "handler">The handler to add to the event.</param>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.ProceedRemoveHandler">
            <summary>
              Proceeds with removing the <see cref = "T:System.Delegate" /> from the event to which the current aspect. 
              This method invokes the next handler in chain. 
              It is typically invoked from the implementation of <see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.RemoveHandler(System.Delegate)">
            <summary>
              Removes a handler from the event by invoking the <c>Remove</c> semantic of the next node in the chain of invocation.
            </summary>
            <param name = "handler">Handler to be removed.</param>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.ProceedInvokeHandler">
            <summary>
              Proceeds with invoking the <see cref = "T:System.Delegate" /> with the arguments specified in the <see cref = "P:PostSharp.Aspects.EventInterceptionArgs.Arguments" /> property.
              The delegate may change the <see cref = "P:PostSharp.Aspects.EventInterceptionArgs.Arguments" /> and set the <see cref = "P:PostSharp.Aspects.EventInterceptionArgs.ReturnValue" />.
              This method invokes the next handler in chain. 
              It is typically invoked from the implementation of <see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionArgs.InvokeHandler(System.Delegate,PostSharp.Aspects.Arguments)">
            <summary>
              Invokes a handler by calling the <c>Invoke</c> semantic of the next node in the chain of invocation.
            </summary>
            <param name = "handler">Handler to be invoked.</param>
            <param name = "arguments">Arguments passed to the handler.</param>
            <returns>Return value of the handler.</returns>
        </member>
        <member name="T:PostSharp.Aspects.EventInterceptionAspect">
            <summary>
            Aspect that, when applied on an event, intercepts invocations of its semantics <c>Add</c> (<see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />), 
            <c>Remove</c> (<see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />) and <c>Invoke</c> (<see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />).
            </summary>
            <remarks>
            <para>
            Applying an aspect of type <see cref="T:PostSharp.Aspects.EventInterceptionAspect" /> to an event results in the <c>add</c> and <c>remove</c>
            methods of the event to be replaced by a call to <see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" /> and <see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />, respectively.
            The original accessor body is moved into new methods, which the aspect code can call by invoking <see cref="M:PostSharp.Aspects.EventInterceptionArgs.ProceedAddHandler" />
            or <see cref="M:PostSharp.Aspects.EventInterceptionArgs.ProceedRemoveHandler" />.
            </para>
            <para>
            The method <see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />, if defined, is called instead when the event is raised, <i>once for every handler</i> that has been added
            to the list. When you define <see cref="M:PostSharp.Aspects.EventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" /> method, PostSharp will use a broker object to control access to the event; this broker
            object will be the unique subscriber of the event, and maintains its own list of subscribers.
            </para>
            <para>
                <note>
                    The aspect works only when caller code access the event through its <c>add</c>/<c>remove</c> semantics. It does not work when the caller
                    code bypasses the event semantics and accesses directly its implementation (the underlying field of the event, typically). The C# compiler
                    is known to bypass the semantics when the event is accessed directly from the class declaring it (it accesses directly the private field
                    whenever it can).
                </note>
            </para>
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
             <seealso href="@interception-aspects" target="_self">
      Conceptual: Interception Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.EventInterceptionAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.EventLevelAspect">
            <summary>
            Base class for all aspects applied on events.
            </summary>
            <remarks>
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.IEventLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.EventLevelAspect.RuntimeInitialize(System.Reflection.EventInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.EventLevelAspect.CompileTimeInitialize(System.Reflection.EventInfo,PostSharp.Aspects.AspectInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.EventLevelAspect.CompileTimeValidate(System.Reflection.EventInfo)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="targetEvent">Event to which the aspect has been applied</param>
            <returns><c>true</c> if the aspect was applied to an acceptable event, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.EventLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.EventInfo)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetEvent">Event to which the current aspect has been applied.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the 
                <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.EventLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.EventLevelAspect.CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.FieldLevelAspect">
            <summary>
            Base class for all aspects applied on fields.
            </summary>
            <seealso cref="T:PostSharp.Aspects.IFieldLevelAspect" />
            <remarks>
            <note>
                Consider deriving your aspects from <see cref="T:PostSharp.Aspects.LocationLevelAspect" />; locations can abstract both fields and properties,
            making it possible to apply the same aspect to both.
            </note>
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.LocationLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.FieldLevelAspect.CompileTimeValidate(System.Reflection.FieldInfo)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="field">Field to which the aspect has been applied</param>
            <returns><c>true</c> if the aspect was applied to an acceptable field, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.FieldLevelAspect.CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.FieldLevelAspect.CompileTimeInitialize(System.Reflection.FieldInfo,PostSharp.Aspects.AspectInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.FieldLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.FieldInfo)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetField">Field to which the current aspect has been applied.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the 
                <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.FieldLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.FieldLevelAspect.RuntimeInitialize(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.FlowBehavior">
            <summary>
              Enumerates the possible behaviors of the calling method after the calling method has returned.
            </summary>
            <remarks>
            <para>
              This enumeration is used by the <see cref = "T:PostSharp.Aspects.MethodExecutionArgs" /> class.
            </para>
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.FlowBehavior.Default">
            <summary>
              Default flow behavior for the current method. The default flow is <see cref = "F:PostSharp.Aspects.FlowBehavior.Continue" /> for all advices except for
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/> where it is <see cref = "F:PostSharp.Aspects.FlowBehavior.RethrowException" />.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.FlowBehavior.Continue">
            <summary>
              Continue normal method execution. For <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/> advice,
              the <see cref="F:PostSharp.Aspects.FlowBehavior.Continue"/> behavior works the same way as <see cref="F:PostSharp.Aspects.FlowBehavior.Return"/> behavior.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.FlowBehavior.RethrowException">
            <summary>
              The current exception will be rethrown. Available only for <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.FlowBehavior.Return">
            <summary>
              Return immediately from the current method. Available only for <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)"/> and
              <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/>. Note that you may want to set the <see cref = "P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue" />
              property, otherwise you may get a <see cref = "T:System.NullReferenceException" />. If there is another <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect"/>
              aspect before the current <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect"/> aspect on the current method,
              the <see cref="F:PostSharp.Aspects.FlowBehavior.Return"/> behavior calls the <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)"/>
              and <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)"/> methods of the other aspect.
            </summary>
            <remarks>
              If the advice is applied semantically to an iterator method in <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)"/>, it means that
            the call to <see cref="M:System.Collections.IEnumerator.MoveNext"/> should return false and the enumerator should thus behave as empty.
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.FlowBehavior.ThrowException">
            <summary>
            Throws the exception contained in the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception"/> property. Available only for <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.FlowBehavior.Yield">
            <summary>
            Awaits for an awaiter. Available only for
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)"/> and <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnResume(PostSharp.Aspects.MethodExecutionArgs)"/> advices
            applied to async methods.
            </summary>
            <remarks>
            In the future, this may also cause a value to be yielded in iterator methods. Currently, it is the same as <see cref="F:PostSharp.Aspects.FlowBehavior.Continue"/> for iterator methods.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.IAspect">
            <summary>
              Base interface for run-time semantics of all aspects.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.IAspectBuildSemantics" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" />
            <seealso cref = "T:PostSharp.Aspects.Aspect" />
        </member>
        <member name="T:PostSharp.Aspects.IAspectBuildSemantics">
            <summary>
              Compile-time semantics of <see cref = "T:PostSharp.Aspects.IAspect" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.IAspectBuildSemantics.GetAspectConfiguration(System.Object)">
            <summary>
              Method invoked at build time to get the imperative configuration of the current <see cref = "T:PostSharp.Aspects.Aspect" />.
            </summary>
            <param name = "targetElement">Code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current aspect has been applied.
            </param>
            <returns>An <see cref = "T:PostSharp.Aspects.Configuration.AspectConfiguration" /> representing the imperative configuration
              of the current <see cref = "T:PostSharp.Aspects.Aspect" />.</returns>
        </member>
        <member name="T:PostSharp.Aspects.IAspectInstance">
            <summary>
            Represents an instance of an aspect applied to a declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.IAspectInstance.AspectConfiguration">
            <summary>
              Gets the aspect configuration.
            </summary>
            <value>
              The aspect configuration, or <c>null</c> if none was provided.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.IAspectInstance.AspectConstruction">
            <summary>
              Gets the aspect construction.
            </summary>
            <value>
              The aspect construction, or <c>null</c> if the aspect instance was provided instead.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.IAspectInstance.Aspect">
            <summary>
              Gets the aspect instance.
            </summary>
            <value>
              The aspect instance, or <c>null</c> if the <see cref = "P:PostSharp.Aspects.IAspectInstance.AspectConfiguration" /> was provided instead.
            </value>
        </member>
        <member name="P:PostSharp.Aspects.IAspectInstance.AspectType">
            <summary>
            Gets the type of the aspect.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.IAspectProvider">
            <summary>
              Interface that, when implemented by an aspect class, allows aspect instances
              to provide other aspects to the weaver.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.IAspectProvider.ProvideAspects(System.Object)">
            <summary>
              Provides new aspects.
            </summary>
            <param name = "targetElement">Code element (<see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, 
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.MethodBase" />, <see cref = "T:System.Reflection.PropertyInfo" />, <see cref = "T:System.Reflection.EventInfo" />, 
              <see cref = "T:System.Reflection.ParameterInfo" />, or <see cref = "T:PostSharp.Reflection.LocationInfo" />) to which the current aspect has been applied.
            </param>
            <returns>A set of aspect instances.</returns>
            <remarks>
              <para>Implementations of this method are only allowed to return aspect instances applied on elements
                of code located <i>under</i> the target element of code (<paramref name = "targetElement" />).
                For instance, a type-level <see cref = "T:PostSharp.Aspects.IAspectProvider" /> can provide aspects on methods of the current type,
                but not of other types.</para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.IAspectRepositoryService">
            <summary>
            Service that allows to determine which aspects have been applied to a given declaration, whether declaratively through custom attributes or <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>,
            or programmatically using <see cref="T:PostSharp.Aspects.IAspectProvider"/>.
            </summary>
            <remarks>
            <para>To get an instance of this service, use the <see cref="M:PostSharp.Extensibility.IProject.GetService``1(System.Boolean)"/> method from <c>PostSharpEnvironment.CurrentProject.GetService</c>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IAspectRepositoryService.GetAspectInstances(System.Object)">
            <summary>
            Gets the list of aspect instances on a given declaration.
            </summary>
            <param name="declaration">The declaration (in the current assembly) for which the list of aspect instances is required.</param>
            <returns>The list of aspect instances applied on <paramref name="declaration"/>.</returns>
        </member>
        <member name="M:PostSharp.Aspects.IAspectRepositoryService.HasAspect(System.Object,System.Type)">
            <summary>
            Determines whether an aspect of a given type has been applied to a given declaration.
            </summary>
            <param name="declaration">The declaration on which the presence of the aspect must be checked.</param>
            <param name="aspectType">The type of aspect.</param>
            <returns><c>true</c> if an aspect of type <paramref name="aspectType"/> has been applied to <paramref name="declaration"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="E:PostSharp.Aspects.IAspectRepositoryService.AspectDiscoveryCompleted">
            <summary>
            Event invoked after all the aspects in the current project have been discovered and initialized.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.IAssemblyLevelAspect">
            <summary>
              Runtime semantics of aspects applied at assembly level.
            </summary>
            <remarks>
              An assembly-level aspect has no equivalent to <b>RuntimeInitialize</b> since assemblies are never initialized.
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics" />
            <seealso cref = "T:PostSharp.Aspects.AssemblyLevelAspect" />
        </member>
        <member name="T:PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics">
            <summary>
              Build-time semantics of aspects applied at assembly level.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.AssemblyLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.IAssemblyLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.Assembly,PostSharp.Aspects.AspectInfo)">
            <summary>
              Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
              before any other build-time method.
            </summary>
            <param name="assembly">Assembly to which the current aspect is applied</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
            <param name="aspectInfo">Reserved for future usage.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.IAsyncMethodBinding">
            <summary>
              Interface through which a method-level aspect or advice can
              asynchronously invoke the next node in the chain of invocation.
            </summary>
            <seealso href="@method-interception" target="_self">
             Conceptual: Intercepting Methods
            </seealso>
        </member>
        <member name="M:PostSharp.Aspects.IAsyncMethodBinding.InvokeAsync(System.Object@,PostSharp.Aspects.Arguments)">
            <summary>
              Invokes asynchronously the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance on which the method should be invoked (<c>null</c> if the method is static).</param>
            <param name="arguments">Method arguments.</param>
            <returns>The value that can be awaited to get the result of the underlying method's invocation.
            </returns>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.IAsyncMethodInterceptionAspect">
            <summary>
              Runtime semantics of an aspect that, when applied on a method, intercepts invocations of this method.
              Includes semantics for both async and non-async method interception.
            </summary>
            <remarks>
              See <see cref = "T:PostSharp.Aspects.MethodInterceptionAspect" /> for details.
            </remarks>
            <see cref = "T:PostSharp.Aspects.MethodInterceptionAspect" />
            <see cref = "T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfiguration" />
            <see cref = "T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute" />
        </member>
        <member name="M:PostSharp.Aspects.IAsyncMethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)">
            <summary>
              Method invoked <i>instead</i> of the method to which the aspect has been applied.
            </summary>
            <param name = "args">Advice arguments.</param>
            <remarks>
              <para>The implementation of <see cref = "M:PostSharp.Aspects.IAsyncMethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)" /> may invoke <see cref = "M:PostSharp.Aspects.MethodInterceptionArgs.ProceedAsync" />, may schedule it for invocation from another thread, or
                may completely skip its invocation. Alternatively, it may use <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.Binding" />. Before returning to the caller,
                the <see cref = "M:PostSharp.Aspects.IAsyncMethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)" /> method must set the return value (property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" />),
                otherwise the target method may fail with a <see cref = "T:System.NullReferenceException" />. It is normally set by calling <see cref = "M:PostSharp.Aspects.MethodInterceptionArgs.ProceedAsync" />.</para>
              <para>
                If semantic advising applies to a method and the method is an async method or returns a <see cref="T:System.Threading.Tasks.Task"/>, then <see cref="M:PostSharp.Aspects.IAsyncMethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)" /> is called for that method instead of <see cref="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)"/>.
              </para>
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.MethodInterceptionArgs" />
        </member>
        <member name="T:PostSharp.Aspects.ICloneAwareAspect">
            <summary>
            Defines the semantics of aspects that require to be notified after
            a target object is cloned using <see cref="M:System.Object.MemberwiseClone"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ICloneAwareAspect.OnCloned(PostSharp.Aspects.ICloneAwareAspect)">
            <summary>
            Method called after the an object enhanced by the current aspect has been
            cloned using <see cref="M:System.Object.MemberwiseClone"/>. The <c>this</c>
            parameter refers to the new aspect instance in the cloned object.
            </summary>
            <param name="source">Aspect instance corresponding to the current
            aspect instance in the cloned target object.</param>
            <remarks>
                <para>Prior to calling the current method, the aspect framework
            initializes the <paramref name="source"/> object using <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.CreateInstance(PostSharp.Aspects.AdviceArgs)"/> 
            and <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.RuntimeInitializeInstance"/>. That is, the aspect instance
            in the cloned object is <i>not</i> cloned from the source aspect instance, but from the prototype
            aspect instance.
            </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.ICompositionAspect">
            <summary>
              Defines the semantics of an aspect that, when applied on a type, introduce one or many new interfaces
              into that type, and let these interfaces be implemented by an object created
              at runtime.
            </summary>
            <remarks>
              See <see cref = "T:PostSharp.Aspects.CompositionAspect" /> for details.
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.CompositionAspect" />
        </member>
        <member name="M:PostSharp.Aspects.ICompositionAspect.CreateImplementationObject(PostSharp.Aspects.AdviceArgs)">
            <summary>
              Method invoked at runtime, during the initialization of instances of the target type,
              to create the composed object.
            </summary>
            <returns>The composed object. This interface should implement the interfaces specified
              by the <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.PublicInterfaces" /> and 
              <see cref = "P:PostSharp.Aspects.Configuration.CompositionAspectConfigurationAttribute.ProtectedInterfaces" /> collections.</returns>
            <remarks>
              This method is invoked during at runtime after the base constructor has executed, and before
              the constructor of the current type is executed.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.ICustomAttributeIntroductionAspect">
            <summary>
              Semantics of an aspect that, when applied to a target, adds a custom attribute to this target.
            </summary>
            <remarks>
              See <see cref = "T:PostSharp.Aspects.CustomAttributeIntroductionAspect" /> for details.
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.CustomAttributeIntroductionAspect" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.CustomAttributeIntroductionAspectConfiguration" />
        </member>
        <member name="T:PostSharp.Aspects.IEventBinding">
            <summary>
              Interface through which an event-level aspect or advice can
              invoke the next node in the chain of invocation.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/>
            <seealso href="@event-interception" target="_self">
             Conceptual: Intercepting Events
            </seealso>
        </member>
        <member name="M:PostSharp.Aspects.IEventBinding.AddHandler(System.Object@,System.Delegate)">
            <summary>
              Invoke the <c>Add</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance on which the event is defined (<c>null</c> if the event is static).</param>
            <param name="handler">Handler to be added to the event.</param>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IEventBinding.RemoveHandler(System.Object@,System.Delegate)">
            <summary>
              Invoke the <c>Remove</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance on which the event is defined (<c>null</c> if the event is static).</param>
            <param name="handler">Handler to be removed from the event.</param>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IEventBinding.InvokeHandler(System.Object@,System.Delegate,PostSharp.Aspects.Arguments)">
            <summary>
              Invoke the <c>Invoke</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance on which the event is defined (<c>null</c> if the event is static).</param>
            <param name="handler">Handler to be removed from the event.</param>
            <param name="arguments">Arguments with which the <paramref name="handler" /> should be invoked.</param>
            <returns>The value returned by the handler.</returns>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
              <br />
              <note>
      The
      <b>Invoke Event Handler</b>
      semantic is different from normal event firing.
      Indeed, when you fire an event, all handlers that were added to this event are fired. However, the current method
      invokes only a single handler: the one passed to the
      <c>handler</c>
      parameter.
    </note>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.IEventInterceptionAspect">
            <summary>
              Runtime semantics of an aspect that, when applied on an event, intercepts invocations of its semantics <c>Add</c> (<see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)" />), 
              <c>Remove</c> (<see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)" />) and <c>Invoke</c> (<see cref = "M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />) semantics.
            </summary>
            <remarks>
              <para>
                For details, see <see cref = "T:PostSharp.Aspects.EventInterceptionAspect" />
              </para>
            </remarks>   /// <see cref = "T:PostSharp.Aspects.EventInterceptionAspect" />
            <see cref = "T:PostSharp.Aspects.Configuration.EventInterceptionAspectConfiguration" />
            <see cref = "T:PostSharp.Aspects.Configuration.EventInterceptionAspectConfigurationAttribute" />
        </member>
        <member name="M:PostSharp.Aspects.IEventInterceptionAspect.OnAddHandler(PostSharp.Aspects.EventInterceptionArgs)">
            <summary>
              Method invoked <i>instead</i> of the <c>Add</c> semantic of the event to which the current aspect is applied,
              i.e. when a new delegate is added to this event.
            </summary>
            <param name="args">Handler arguments.</param>
            <remarks>
              <para>
               This advice does not intercept the initializer of a field-like event. If you want to intercept the adding of all handlers,
            do not use event initializers and instead add the initial handler in the constructor.
              </para>
              <br />
              <note>
      Because of the way how the C# compiler implements
      <b>field-like events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IEventInterceptionAspect.OnRemoveHandler(PostSharp.Aspects.EventInterceptionArgs)">
            <summary>
              Method invoked <i>instead</i> of the <c>Remove</c> semantic of the event to which the current aspect is applied,
              i.e. when a delegate is removed from this event.
            </summary>
            <param name="args">Handler arguments.</param>
            <remarks>
              <note>
      Because of the way how the C# compiler implements
      <b>field-like events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)">
            <summary>
              Method invoked when the event to which the current aspect is applied is fired, <i>for each</i> delegate
              of this event, and <i>instead of</i> invoking this delegate.
            </summary>
            <param name="args">Handler arguments.</param>
            <remarks>
              <note>
      Because of the way how the C# compiler implements
      <b>field-like events</b>
      (i.e. events where you
      don't implement the
      <c>Add</c>
      and
      <c>Remove</c>
      semantics manually), the
      <b>Invoke Event Handler</b>
      semantic (
      <see cref="M:PostSharp.Aspects.IEventInterceptionAspect.OnInvokeHandler(PostSharp.Aspects.EventInterceptionArgs)" />
      or equivalent) shall
      <b>not</b>
      be invoked for delegates that have been added from inside the class that declares this event.
    </note>
              <br />
              <note>
      The
      <b>Invoke Event Handler</b>
      semantic is different from normal event firing.
      Indeed, when you fire an event, all handlers that were added to this event are fired. However, the current method
      invokes only a single handler: the one passed to the
      <c>handler</c>
      parameter.
    </note>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.IEventLevelAspect">
            <summary>
              Runtime semantics of aspects that can be applied on events.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.EventLevelAspect" />
            <seealso cref = "T:PostSharp.Aspects.IEventLevelAspectBuildSemantics" />
        </member>
        <member name="M:PostSharp.Aspects.IEventLevelAspect.RuntimeInitialize(System.Reflection.EventInfo)">
            <summary>
              Initializes the current aspect.
            </summary>
            <param name="eventInfo">Event to which the current aspect is applied.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.IEventLevelAspectBuildSemantics">
            <summary>
              Build-time semantics of aspects that can be applied on events.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.EventLevelAspect" />
            <seealso cref = "T:PostSharp.Aspects.IEventLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.IEventLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.EventInfo,PostSharp.Aspects.AspectInfo)">
            <summary>
              Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
              before any other build-time method.
            </summary>
            <param name="targetEvent">Event to which the current aspect is applied</param>
            <param name="aspectInfo">Reserved for future usage.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.IFieldLevelAspect">
            <summary>
              Run-time semantics of aspects applied to fields.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.IFieldLevelAspectBuildSemantics" />
            <seealso cref = "T:PostSharp.Aspects.FieldLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.IFieldLevelAspect.RuntimeInitialize(System.Reflection.FieldInfo)">
            <summary>
              Method invoked at runtime before any other method of the aspect is invoked.
            </summary>
            <param name="field">Field on which this instance is applied.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.IFieldLevelAspectBuildSemantics">
            <summary>
              Compile-time semantics of <see cref = "T:PostSharp.Aspects.IFieldLevelAspect" />.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.IFieldLevelAspect" />
            <seealso cref = "T:PostSharp.Aspects.FieldLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.IFieldLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.FieldInfo,PostSharp.Aspects.AspectInfo)">
            <summary>
              Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
              before any other build-time method.
            </summary>
            <param name="field">Field to which the current aspect is applied</param>
            <param name="aspectInfo">Reserved for future usage.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.IInstanceScopedAspect">
            <summary>
              Runtime semantics of aspects that have the same lifetime as <i>instance</i> of types
              to which their are applied (or instance of the declaring type of members to which they are applied).
            </summary>
            <remarks>
              <para>When an aspect is instance-scoped, a new instance of this aspect is created whenever an instance of the
                type to which it has been applied is created (concretely, before the call to the base constructor and the own constructor of this type).</para>
              <para>New aspect instances are obtained using the <b>prototype</b> design pattern. As any other aspect, an instance-scope aspect
                has a static instance initialized at build time, then serialized, deserialized at runtime, and initialized by <b>RuntimeInitialize</b>.
                This static instance then serves as a <i>prototype</i>.  When a new instance of the target type is created, the prototype is cloned
                by the method <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.CreateInstance(PostSharp.Aspects.AdviceArgs)" /> (typically implemented by a call to <see cref="M:System.Object.MemberwiseClone" />). Then some system
                initializations (for instance member import) are performed on the aspect instance, and finally the <see cref="M:PostSharp.Aspects.IInstanceScopedAspect.RuntimeInitializeInstance" />
                method is invoked.
              </para>
              <para>When an aspect implementing the <see cref="T:PostSharp.Aspects.IInstanceScopedAspect" /> interface is applied on a static method, field, property, or event,
                the aspect will be statically scoped and the interface will be ignored.</para>
            </remarks>
            <seealso href="@aspect-lifetime" target="_self">
      Conceptual: Understanding Aspect Lifetime and Scope
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.IInstanceScopedAspect.CreateInstance(PostSharp.Aspects.AdviceArgs)">
            <summary>
              Creates a new instance of the aspect based on the current instance, serving as a prototype.
            </summary>
            <param name = "adviceArgs">Aspect arguments.</param>
            <returns>A new instance of the aspect, typically a clone of the current prototype instance.</returns>
            <remarks>
              This method is typically implemented by invoking <see cref = "M:System.Object.MemberwiseClone" />.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IInstanceScopedAspect.RuntimeInitializeInstance">
            <summary>
              Initializes the aspect instance. This method is invoked when all system elements of the aspect (like member imports)
              have completed.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.InitializeAspectInstanceAdvice"/>
        </member>
        <member name="T:PostSharp.Aspects.ILicensedAspect">
            <exclude/>
        </member>
        <member name="M:PostSharp.Aspects.ILicensedAspect.GetLicenseRequirements">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.ILocationBinding">
            <summary>
              Interface through which a field- or property-level aspect or advice can
              invoke the next node in the chain of invocation.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/>
            <seealso cref="T:PostSharp.Aspects.ILocationBinding`1"/>
            <seealso href="@location-interception" target="_self">
             Conceptual: Intercepting Properties and Fields
            </seealso>
        </member>
        <member name="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)">
            <summary>
              Invokes the <c>Get</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance from which the field or property should be retrieved (<c>null</c> if the field or property is static).</param>
            <param name="index">Index arguments, if the location is an indexer property.</param>
            <returns>The value stored at the location.</returns>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationBinding.SetValue(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <summary>
              Invokes the <c>Set</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance from which the field or property should be retrieved (<c>null</c> if the field or property is static).</param>
            <param name="index">Index arguments, if the location is an indexer property.</param>
            <param name="value">New value to be stored at the location.</param>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.ILocationBinding.LocationInfo">
            <summary>
            Gets metadata information about the field or property represented by the current binding.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ILocationBinding.LocationType">
            <summary>
            Gets the type of the field or property.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ILocationBinding.DeclarationIdentifier">
            <summary>
            Gets the <see cref="P:PostSharp.Aspects.ILocationBinding.DeclarationIdentifier"/> of the declaration that the binding represents.
            </summary>
            <remarks>
            <para>For usage information, see the remarks of the <see cref="P:PostSharp.Aspects.ILocationBinding.DeclarationIdentifier"/> type documentation.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationBinding.Execute``1(PostSharp.Aspects.ILocationBindingAction{``0},``0@)">
            <summary>
            Provides a mechanism to execute a strongly-typed action that depends on the type of the current location.
            </summary>
            <typeparam name="TPayload">Type of the payload passed to the <paramref name="payload"/> parameter.</typeparam>
            <param name="action">Action.</param>
            <param name="payload">Payload.</param>
        </member>
        <member name="T:PostSharp.Aspects.ILocationBinding`1">
            <summary>
            A strongly-typed variant for <see cref="T:PostSharp.Aspects.ILocationBinding"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:PostSharp.Aspects.ILocationBinding`1.GetValue(System.Object@,PostSharp.Aspects.Arguments)">
            <summary>
              Invokes the <c>Get</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance from which the field or property should be retrieved (<c>null</c> if the field or property is static).</param>
            <param name="index">Index arguments, if the location is an indexer property.</param>
            <returns>The value stored at the location.</returns>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationBinding`1.SetValue(System.Object@,PostSharp.Aspects.Arguments,`0)">
            <summary>
              Invokes the <c>Set</c> semantic on the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance from which the field or property should be retrieved (<c>null</c> if the field or property is static).</param>
            <param name="index">Index arguments, if the location is an indexer property.</param>
            <param name="value">New value to be stored at the location.</param>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.ILocationBindingAction`1">
            <summary>
            Exposes an <see cref="M:PostSharp.Aspects.ILocationBindingAction`1.Execute``1(PostSharp.Aspects.ILocationBinding{``0},`0@)"/> method invoked by the <see cref="M:PostSharp.Aspects.ILocationBinding.Execute``1(PostSharp.Aspects.ILocationBindingAction{``0},``0@)"/> method,
            which allows to execute strongly-typed operations and avoid boxing required by the weakly typed <see cref="T:PostSharp.Aspects.ILocationBinding"/> interface.
            </summary>
            <typeparam name="TPayload">Type of the payload of the <see cref="M:PostSharp.Aspects.ILocationBindingAction`1.Execute``1(PostSharp.Aspects.ILocationBinding{``0},`0@)"/> method.</typeparam>
        </member>
        <member name="M:PostSharp.Aspects.ILocationBindingAction`1.Execute``1(PostSharp.Aspects.ILocationBinding{``0},`0@)">
            <summary>
            Method invoked by the <see cref="M:PostSharp.Aspects.ILocationBinding.Execute``1(PostSharp.Aspects.ILocationBindingAction{``0},``0@)"/> method.
            </summary>
            <typeparam name="TValue">Type of the value of the <see cref="T:PostSharp.Aspects.ILocationBinding"/> object.</typeparam>
            <param name="binding">The typed <see cref="T:PostSharp.Aspects.ILocationBinding"/>.</param>
            <param name="payload">Payload.</param>
        </member>
        <member name="T:PostSharp.Aspects.ILocationInterceptionArgs">
            <summary>
            An interface for <see cref="T:PostSharp.Aspects.LocationInterceptionArgs"/>.
            </summary>
            <remarks>
            <para>This interface is not generally used directly, but it serves as a base for the strongly-typed <see cref="T:PostSharp.Aspects.ILocationInterceptionArgs`1"/>,
            which is used by <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)"/>.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.Binding">
            <summary>
              Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
            <remarks>
              <para>
      Bindings are thread-safe and context-free singleton instances exposing the next node in the chain of invocation.
    </para><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.Index">
            <summary>
              Gets the current index arguments (in case of a property with parameters).
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs.ProceedGetValue">
            <summary>
              Invokes the <b>Get Location Value</b> semantic on the next node in the chain of invocation and stores the location value in the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property.
            </summary>
            <remarks>
              <para>
                Note that this method overwrites the content of the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property. Therefore, you should not call this invoke
                from a <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice unless you store the value before. If you need to retrieve
                the current value of the location from a <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, it is recommended you
                use the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> method.
              </para>
              <br />
              <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.ILocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs.ProceedSetValue">
            <summary>
              Invokes the <b>Set Location Value</b> semantic on the next node in the chain of invocation and stores the value of the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property into
              the location.
            </summary>
            <remarks>
              <para>Note that this method requires the value to be stored in the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property. If you need to retrieve
                the current value of the location from a <see cref="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, it is recommended you
                use the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> method.
              </para>
              <br />
              <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.ILocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs.GetCurrentValue">
            <summary>
              Retrieves the current value of the location without overwriting the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property.
            </summary>
            <returns>The current value of the location, as returned by the next node in the chain of invocation (see <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />).</returns>
            <remarks>
              <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.ILocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs.SetNewValue(System.Object)">
            <summary>
              Sets the value of the location without overwriting the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property.
            </summary>
            <param name="value">The value to be passed to the next node in the chain of invocation (see <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />).</param>
            <remarks>
              <br />
              <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.ILocationInterceptionArgs.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)">
            <summary>
            Executes a delegate for the current <see cref="T:PostSharp.Aspects.LocationInterceptionArgs"/>. This method allows to
            execute strongly-typed operations and avoid boxing required by the weakly typed <see cref="T:PostSharp.Aspects.ILocationInterceptionArgs"/> interface.
            </summary>
            <typeparam name="TPayload">Type of the payload.</typeparam>
            <param name="action">Class (typically a singleton) that contains the generic method <see cref="M:PostSharp.Aspects.ILocationInterceptionArgsAction`1.Execute``1(PostSharp.Aspects.ILocationInterceptionArgs{``0},`0@)"/>
            that will be executed with the right method generic argument.</param>
            <param name="payload">An argument being passed to the <see cref="M:PostSharp.Aspects.ILocationInterceptionArgsAction`1.Execute``1(PostSharp.Aspects.ILocationInterceptionArgs{``0},`0@)"/> method of the <paramref name="action"/>
            parameter.</param>
            <remarks>
            <note>
                <para>This method is ignored by the advice optimizer. As a result, the optimizer will not know that the <paramref name="action"/> implementation uses
            any feature of the <see cref="T:PostSharp.Aspects.LocationInterceptionArgs"/> object, and the code supporting these features won't be generated. If these features are required
            by <paramref name="action"/>, they must be referenced inside the <see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)"/> or <see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)"/>
            method.
            </para>
            </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.Value">
            <summary>
            See <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" />
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.Location">
            <summary>
            See <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Location" />
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.LocationName">
            <summary>
            See <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.LocationName" />
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.LocationFullName">
            <summary>
            See <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.LocationFullName" />
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs.Instance">
            <summary>
              Gets or sets the object instance on which the method is being executed.
            </summary>
            <remarks>
              This set may be set by user code only when the instance is a value type.
              As usually, user code is responsible for setting an object of the
              right type.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.ILocationInterceptionArgs`1">
            <summary>
            A strongly-typed specialization of the <see cref="T:PostSharp.Aspects.ILocationInterceptionArgs"/> interface.
            </summary>
            <typeparam name="T">Type of the location value.</typeparam>
            <remarks>Use the <see cref="M:PostSharp.Aspects.ILocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)"/> method to consume this interface.</remarks>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs`1.Binding">
            <summary>
              Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
            <remarks>
              <para>
      Bindings are thread-safe and context-free singleton instances exposing the next node in the chain of invocation.
    </para><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.ILocationInterceptionArgs`1.Value">
            <summary>
              Gets or sets the location value.
            </summary>
            <remarks>
              <para>
                Inside an <see cref = "M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, this property is available after
                the next advice in chain has been invoked using <see cref = "M:PostSharp.Aspects.ILocationInterceptionArgs.ProceedGetValue" />. However, 
                inside an <see cref = "M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, the value is available immediately,
                and is used as input by <see cref = "M:PostSharp.Aspects.ILocationInterceptionArgs.ProceedSetValue" />. 
              </para>
              <para>
                See <see cref = "M:PostSharp.Aspects.ILocationInterceptionArgs`1.GetCurrentValue" /> and <see cref = "M:PostSharp.Aspects.ILocationInterceptionArgs`1.SetNewValue(`0)" />
                to get or set the value of the location without affecting the value of this property.
              </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs`1.GetCurrentValue">
            <summary>
              Retrieves the current value of the location without overwriting the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property.
            </summary>
            <returns>The current value of the location, as returned by the next node in the chain of invocation (see <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />).</returns>
            <remarks>
              <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.ILocationInterceptionArgs`1.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgs`1.SetNewValue(`0)">
            <summary>
              Sets the value of the location without overwriting the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value" /> property.
            </summary>
            <param name="value">The value to be passed to the next node in the chain of invocation (see <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" />).</param>
            <remarks>
              <br />
              <note>
      This method is designed to be invoked during the execution of the advice. If you need to retrieve or store the value of the location at a different time, it is
      recommended to use the
      <see cref="P:PostSharp.Aspects.ILocationInterceptionArgs`1.Binding" />
      . Indeed, a binding is stateless, while
      <see cref="T:PostSharp.Aspects.LocationInterceptionArgs" />
      instances may be shared
      among different aspects.
    </note>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.ILocationInterceptionArgsAction`1">
            <summary>
            Exposes an <see cref="M:PostSharp.Aspects.ILocationInterceptionArgsAction`1.Execute``1(PostSharp.Aspects.ILocationInterceptionArgs{``0},`0@)"/> method invoked by the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)"/> method,
            which allows to execute strongly-typed operations and avoid boxing required by the weakly typed <see cref="T:PostSharp.Aspects.ILocationInterceptionArgs"/> interface.
            </summary>
            <typeparam name="TPayload">Type of the payload of the <see cref="M:PostSharp.Aspects.ILocationInterceptionArgsAction`1.Execute``1(PostSharp.Aspects.ILocationInterceptionArgs{``0},`0@)"/> method.</typeparam>
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionArgsAction`1.Execute``1(PostSharp.Aspects.ILocationInterceptionArgs{``0},`0@)">
            <summary>
            Method invoked by the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)"/> method.
            </summary>
            <typeparam name="TValue">Type of the value of the <see cref="T:PostSharp.Aspects.LocationInterceptionArgs"/> object.</typeparam>
            <param name="args">The typed <see cref="T:PostSharp.Aspects.LocationInterceptionArgs"/>.</param>
            <param name="payload">Payload passed to the <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)"/> method.</param>
        </member>
        <member name="T:PostSharp.Aspects.ILocationInterceptionAspect">
            <summary>
              Runtime semantics of an aspect that, when applied on a location (field or property), intercepts invocations of
              the <c>Get</c> (<see cref = "M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) and <c>Set</c> (<see cref = "M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) semantics.
            </summary>
            <remarks>
              See <see cref = "T:PostSharp.Aspects.LocationInterceptionAspect" /> for details.
            </remarks>
            <see cref = "T:PostSharp.Aspects.LocationInterceptionAspect" />
            <see cref = "T:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfiguration" />
            <see cref = "T:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfigurationAttribute" />
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)">
            <summary>
              Method invoked <i>instead</i> of the <c>Get</c> semantic of the field or property to which the current aspect is applied,
              i.e. when the value of this field or property is retrieved.
            </summary>
            <param name = "args">Advice arguments.</param>
            <seealso cref = "T:PostSharp.Aspects.LocationInterceptionArgs" />
        </member>
        <member name="M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)">
            <summary>
            Method invoked <i>instead</i> of the <c>Set</c> semantic of the field or property to which the current aspect is applied,
              i.e. when the value of this field or property is changed.
            </summary>
            <remarks>
            <para>
            This method is invoked <i>instead</i> of the setter of the property to which the current aspect is applied. If it is applied to a field, that field
            is transformed into a property. This method intercepts all writes to static properties, but it does not intercept inline initializers of instance
            properties; use <see cref="M:PostSharp.Aspects.IOnInstanceLocationInitializedAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)"/> for that.
            </para>
            <para>
            If you apply this advice to a getter-only auto-implemented property, PostSharp will create a setter that will be called in these cases:
            </para>
            <list type="bullet">
              <item>for static properties, instead of the property inline initialization or property assignment from the static constructor;</item>
              <item>for instance properties, only instead of the property assignment from the constructor but not for the inline initialization
                (use the <see cref="M:PostSharp.Aspects.IOnInstanceLocationInitializedAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)"/> advice to intercept inline initialization
            of an instance property).</item>
            </list>
            </remarks>
            <param name = "args">Advice arguments.</param>
            <seealso cref = "T:PostSharp.Aspects.LocationInterceptionArgs" />
        </member>
        <member name="T:PostSharp.Aspects.ILocationLevelAspect">
            <summary>
              Runtime semantics of aspects defined on a field, property, or parameter.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ILocationLevelAspect.RuntimeInitialize(PostSharp.Reflection.LocationInfo)">
            <summary>
              Initializes the current aspect.
            </summary>
            <param name="locationInfo">Location to which the current aspect is applied.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.ILocationLevelAspectBuildSemantics">
            <summary>
              Compile-time semantics of <see cref = "T:PostSharp.Aspects.ILocationLevelAspect" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ILocationLevelAspectBuildSemantics.CompileTimeInitialize(PostSharp.Reflection.LocationInfo,PostSharp.Aspects.AspectInfo)">
            <summary>
              Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
              before any other build-time method.
            </summary>
            <param name="targetLocation">Location to which the current aspect is applied</param>
            <param name="aspectInfo">Reserved for future usage.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.ILocationValidationAspect">
            <summary>
            Ancestor of <see cref="T:PostSharp.Aspects.ILocationValidationAspect`1"/>.
            </summary>
            <remarks>
            <para>This interface exists only because PostSharp SDK requires a common non-generic interface for <see cref="T:PostSharp.Aspects.ILocationValidationAspect`1"/>.
            It should not be used in user code.</para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.ILocationValidationAspect`1">
            <summary>
              Runtime semantics of an aspect that, when applied on a location (field, property, or parameter), 
              validates the value assigned to this location using method <see cref="M:PostSharp.Aspects.ILocationValidationAspect`1.ValidateValue(`0,System.String,PostSharp.Reflection.LocationKind,PostSharp.Aspects.LocationValidationContext)"/>, and throws
              the exception returned by this method if any.
            </summary>
            <typeparam name="T">Type of values validated by the current aspect.</typeparam>
            <remarks>
              <para>An aspect will typically implement several generic instances of the current interface,
               with different values of <typeparamref name="T"/>. The aspect can be applied only to locations
               for which there is an exact type match. PostSharp does not implement any type conversion, even
               when this conversion is implicitly supported by the compiler, for instance <c>int</c> to <c>long</c>.
               Therefore, if your aspect must be able to validate all integers, you may need to implement
               the interface instances for <typeparamref name="T"/> ranging in <c>long</c>, <c>int</c>, <c>short</c>,
                <c>sbyte</c> and possibly their unsigned variant. However, values of a derived type can be
                validated if <typeparamref name="T"/> is the base type.
            </para>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.Advices.LocationValidationAdvice"/>
        </member>
        <member name="M:PostSharp.Aspects.ILocationValidationAspect`1.ValidateValue(`0,System.String,PostSharp.Reflection.LocationKind,PostSharp.Aspects.LocationValidationContext)">
            <summary>
            Validates the value being assigned to the location to which the current aspect has been applied.
            </summary>
            <param name="value">Value being applied to the location.</param>
            <param name="locationName">Name of the location.</param>
            <param name="locationKind">Location kind (<see cref="F:PostSharp.Reflection.LocationKind.Field"/>, <see cref="F:PostSharp.Reflection.LocationKind.Property"/>, or
            <see cref="F:PostSharp.Reflection.LocationKind.Parameter"/>).
            </param>
            <param name="context">Indicates the context in which the value is being validated, such as precondition or postcondition for ref method parameters.</param>
            <returns>The <see cref="T:System.Exception"/> to be thrown, or <c>null</c> if no exception needs to be thrown.</returns>
        </member>
        <member name="T:PostSharp.Aspects.IManagedResourceIntroductionAspect">
            <summary>
              Semantics of an aspect that, when applied to an assembly, adds a managed resource to this assembly.
            </summary>
            <remarks>
              See <see cref = "T:PostSharp.Aspects.ManagedResourceIntroductionAspect" /> for details.
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.ManagedResourceIntroductionAspect" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.ManagedResourceIntroductionAspectConfiguration" />
        </member>
        <member name="T:PostSharp.Aspects.IMethodBinding">
            <summary>
              Interface through which a method-level aspect or advice can
              invoke the next node in the chain of invocation.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Advices.ImportMemberAttribute"/>
            <seealso href="@method-interception" target="_self">
             Conceptual: Intercepting Methods
            </seealso>
        </member>
        <member name="M:PostSharp.Aspects.IMethodBinding.Invoke(System.Object@,PostSharp.Aspects.Arguments)">
            <summary>
              Invokes the next node in the chain of invocation.
            </summary>
            <param name="instance">Target instance on which the method should be invoked (<c>null</c> if the method is static).</param>
            <param name="arguments">Method arguments.</param>
            <returns>Return value of the method.</returns>
            <remarks>
              <para>
      The
      <paramref name="instance" />
      parameter is passed by reference so that instance methods of value types (
      <c>struct</c>
      in C#) are allowed to change the value of the instance.
    </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.IMethodInterceptionAspect">
            <summary>
              Runtime semantics of an aspect that, when applied on a method, intercepts invocations of this method.
            </summary>
            <remarks>
              See <see cref = "T:PostSharp.Aspects.MethodInterceptionAspect" /> for details.
            </remarks>
            <see cref = "T:PostSharp.Aspects.MethodInterceptionAspect" />
            <see cref = "T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfiguration" />
            <see cref = "T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute" />
        </member>
        <member name="M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)">
            <summary>
              Method invoked <i>instead</i> of the method to which the aspect has been applied.
            </summary>
            <param name = "args">Advice arguments.</param>
            <remarks>
              <para>The implementation of <see cref = "M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" /> may invoke <see cref = "M:PostSharp.Aspects.MethodInterceptionArgs.Proceed" />, may schedule it for invocation from another thread, or
                may completely skip its invocation. Alternatively, it may use <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.Binding" />. Before returning to the caller, the <see cref = "M:PostSharp.Aspects.IMethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" /> method must set the return value (property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" />)
                and all output arguments (property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.Arguments" />), otherwise the target method may fail with a <see cref = "T:System.NullReferenceException" />. These
                are normally set by calling <see cref = "M:PostSharp.Aspects.MethodInterceptionArgs.Proceed" />.</para>
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.MethodInterceptionArgs" />
        </member>
        <member name="T:PostSharp.Aspects.IMethodLevelAspect">
            <summary>
              Runtime semantics of aspects applied to methods.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.IMethodLevelAspectBuildSemantics" />
            <seealso cref = "T:PostSharp.Aspects.MethodLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.IMethodLevelAspect.RuntimeInitialize(System.Reflection.MethodBase)">
            <summary>
              Initializes the current aspect.
            </summary>
            <param name="method">Method to which the current aspect is applied.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.IMethodLevelAspectBuildSemantics">
            <summary>
              Compile-time semantics of <see cref = "T:PostSharp.Aspects.IMethodLevelAspect" />.
            </summary>
            <see cref = "T:PostSharp.Aspects.MethodLevelAspect" />
            <see cref = "T:PostSharp.Aspects.IMethodLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.IMethodLevelAspectBuildSemantics.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)">
            <summary>
              Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
              before any other build-time method.
            </summary>
            <param name="method">Method to which the current aspect is applied</param>
            <param name="aspectInfo">Reserved for future usage.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.InstanceLevelAspect">
            <summary>
            Base class for aspects applied on types, but having the same lifetime as
            instances of the type to which they are applied.
            </summary>
            <remarks>
            <para>This class is provided for convenience. You get the same functionality by deriving your
            aspect class directly from <see cref="T:PostSharp.Aspects.TypeLevelAspect" /> and implementing the interface
            <see cref="T:PostSharp.Aspects.IInstanceScopedAspect" />
            </para>
            <br />
            <para>See <see cref="T:PostSharp.Aspects.IInstanceScopedAspect" /> for a discussion of instance-scoped aspects.</para>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.IInstanceScopedAspect" />
            <seealso href="@aspect-lifetime" target="_self">
      Conceptual: Understanding Aspect Lifetime and Scope
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.InstanceLevelAspect.CreateInstance(PostSharp.Aspects.AdviceArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.InstanceLevelAspect.RuntimeInitializeInstance">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.InstanceLevelAspect.OnCloned(PostSharp.Aspects.ICloneAwareAspect)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.InstanceLevelAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Aspects.InstanceLevelAspect.Instance">
            <summary>
              Gets the object to which the current aspect has been applied.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Internals.AdviceOptimizationAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`1">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 1 argument.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`1.Arg0">
            <summary>
              First Argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`1.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`1" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`1.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`1.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`1.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`1.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.ArgumentsArray">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a
              list of arguments of arbitrary length and type.
            </summary>
            <remarks>
              Unless generic implementations of
              <see cref = "T:PostSharp.Aspects.Arguments" />, <see cref = "T:PostSharp.Aspects.Internals.ArgumentsArray" /> boxes all arguments
              into an <see cref = "T:System.Array" />, resulting in lower performance and higher memory usage.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Internals.ArgumentsArray.#ctor(System.Object[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.ArgumentsArray" />.
            </summary>
            <param name = "arguments"><see cref = "T:System.Array" /> containing the argument values.</param>
        </member>
        <member name="P:PostSharp.Aspects.Internals.ArgumentsArray.Arguments">
            <summary>
              Gets or sets the underlying array of arguments.
            </summary>
            <remarks>
              When you set this property, the new <see cref = "T:System.Array" /> must have the same length as the previous one.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Internals.ArgumentsArray.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.ArgumentsArray.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.ArgumentsArray.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.ArgumentsArray.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`2">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 2 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`2.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`2.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`2.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`2" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`2.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`2.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`2.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`2.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`3">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 3 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
            <typeparam name = "TArg2">Type of the third argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`3.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`3.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`3.Arg2">
            <summary>
              Third argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`3.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`3" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`3.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`3.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`3.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`3.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`4">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 4 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
            <typeparam name = "TArg2">Type of the third argument.</typeparam>
            <typeparam name = "TArg3">Type of the fourth argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`4.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`4.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`4.Arg2">
            <summary>
              Third argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`4.Arg3">
            <summary>
              Fourth argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`4.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`4" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`4.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`4.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`4.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`4.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`5">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 5 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
            <typeparam name = "TArg2">Type of the third argument.</typeparam>
            <typeparam name = "TArg3">Type of the fourth argument.</typeparam>
            <typeparam name = "TArg4">Type of the fifth argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`5.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`5.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`5.Arg2">
            <summary>
              Third argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`5.Arg3">
            <summary>
              Fourth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`5.Arg4">
            <summary>
              Fifth argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`5.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`5" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`5.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`5.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`5.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`5.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`6">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 6 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
            <typeparam name = "TArg2">Type of the third argument.</typeparam>
            <typeparam name = "TArg3">Type of the fourth argument.</typeparam>
            <typeparam name = "TArg4">Type of the fifth argument.</typeparam>
            <typeparam name = "TArg5">Type of the sixth argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`6.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`6.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`6.Arg2">
            <summary>
              Third argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`6.Arg3">
            <summary>
              Fourth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`6.Arg4">
            <summary>
              Fifth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`6.Arg5">
            <summary>
              Sixth argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`6.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`6" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`6.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`6.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`6.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`6.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`7">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 7 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
            <typeparam name = "TArg2">Type of the third argument.</typeparam>
            <typeparam name = "TArg3">Type of the fourth argument.</typeparam>
            <typeparam name = "TArg4">Type of the fifth argument.</typeparam>
            <typeparam name = "TArg5">Type of the sixth argument.</typeparam>
            <typeparam name = "TArg6">Type of the seventh argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg2">
            <summary>
              Third argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg3">
            <summary>
              Fourth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg4">
            <summary>
              Fifth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg5">
            <summary>
              Sixth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`7.Arg6">
            <summary>
              Seventh argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`7.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`7" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`7.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`7.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`7.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`7.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.Arguments`8">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Arguments" /> representing a list of 8 arguments.
            </summary>
            <typeparam name = "TArg0">Type of the first argument.</typeparam>
            <typeparam name = "TArg1">Type of the second argument.</typeparam>
            <typeparam name = "TArg2">Type of the third argument.</typeparam>
            <typeparam name = "TArg3">Type of the fourth argument.</typeparam>
            <typeparam name = "TArg4">Type of the fifth argument.</typeparam>
            <typeparam name = "TArg5">Type of the sixth argument.</typeparam>
            <typeparam name = "TArg6">Type of the seventh argument.</typeparam>
            <typeparam name = "TArg7">Type of the eighth argument.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg0">
            <summary>
              First argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg1">
            <summary>
              Second argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg2">
            <summary>
              Third argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg3">
            <summary>
              Fourth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg4">
            <summary>
              Fifth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg5">
            <summary>
              Sixth argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg6">
            <summary>
              Seventh argument.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.Arguments`8.Arg7">
            <summary>
              Eighth argument.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`8.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.Internals.Arguments`8" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`8.GetArgument(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`8.SetArgument(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`8.CopyTo(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.Arguments`8.CopyFrom(System.Object[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.AsyncMethodBinding">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding.Invoke(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding.PostSharp#Aspects#IAsyncMethodBinding#InvokeAsync(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding.InvokeAsync(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding.PostSharp#Aspects#ITaskAdapter#GetResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.#ctor(System.Object,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.TypedBinding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.Binding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.AsyncBinding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.ReturnValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.ProceedAsync">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.InvokeAsync(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.Proceed">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.Invoke(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.PostSharp#Aspects#IAsyncMethodInterceptionArgsInternal#GetResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.PostSharp#Aspects#IAsyncMethodInterceptionArgsInternal#AwaitResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.PostSharp#Aspects#ITaskAdapter#GetResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl.IsAsync">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.#ctor(System.Object,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.TypedBinding">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.TypedReturnValue">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.Binding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.AsyncBinding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.ReturnValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.ProceedAsync">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.InvokeAsync(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.Proceed">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.Invoke(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.IsAsync">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.PostSharp#Aspects#IAsyncMethodInterceptionArgsInternal#GetResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.PostSharp#Aspects#IAsyncMethodInterceptionArgsInternal#AwaitResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodInterceptionArgsImpl`1.PostSharp#Aspects#ITaskAdapter#GetResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.CreateInstanceOptimizations)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.CreateInstanceOptimizationAttribute.Optimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.CreateInstanceOptimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.DebuggerAspectGeneratedCodeAttribute">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.DebuggerAspectMethodAttribute">
            <exclude/>
        </member>
        <member name="M:PostSharp.Aspects.Internals.DebuggerAspectMethodAttribute.#ctor(PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior)">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.DebuggerBindingMethodAttribute">
            <exclude/>
        </member>
        <member name="M:PostSharp.Aspects.Internals.DebuggerBindingMethodAttribute.#ctor(System.Int32)">
            <exclude/>
        </member>
        <member name="P:PostSharp.Aspects.Internals.DebuggerBindingMethodAttribute.BindingInvokeMethodToken">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.DebuggerSourceMethodAttribute">
            <exclude/>
        </member>
        <member name="M:PostSharp.Aspects.Internals.DebuggerSourceMethodAttribute.#ctor(System.Int32)">
            <exclude/>
        </member>
        <member name="P:PostSharp.Aspects.Internals.DebuggerSourceMethodAttribute.SourceMethodToken">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior">
            <exclude/>
        </member>
        <member name="F:PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior.None">
            <exclude/>
        </member>
        <member name="F:PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior.RunToTarget">
            <exclude/>
        </member>
        <member name="F:PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior.StepOut">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.DebuggerTargetMethodAttribute">
            <exclude/>
        </member>
        <member name="M:PostSharp.Aspects.Internals.DebuggerTargetMethodAttribute.#ctor(System.Int32)">
            <exclude/>
        </member>
        <member name="P:PostSharp.Aspects.Internals.DebuggerTargetMethodAttribute.TargetMethodToken">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1">
            <summary>
            Enumerator over an empty collection that returns the type's default value from its <see cref="P:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1.Current"/> properties. Its methods do nothing.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1.Dispose">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1.MoveNext">
            <summary>
            Always returns false.
            </summary>
            <returns>False.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1.Reset">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1.Current">
            <summary>
            Gets the default value of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Internals.EmptyNonThrowingEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the default value of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Internals.EventBinding">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBinding.AddHandler(System.Object@,System.Delegate,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBinding.RemoveHandler(System.Object@,System.Delegate,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBinding.InvokeHandler(System.Object@,System.Delegate,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBinding.PostSharp#Aspects#IEventBinding#AddHandler(System.Object@,System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBinding.PostSharp#Aspects#IEventBinding#RemoveHandler(System.Object@,System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBinding.PostSharp#Aspects#IEventBinding#InvokeHandler(System.Object@,System.Delegate,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.EventBroker">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.EventBroker.Instance">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.SubscribeImpl">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.UnsubscribeImpl">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.OnHandlerInvoked(System.Delegate,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.AddHandler(System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.RemoveHandler(System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventBroker.OnEventFired(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.SafeEventBroker">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.SafeEventBroker.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.SafeEventBroker.Instance">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.SafeEventBroker.CreateInterceptor(System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.SafeEventBroker.AddHandler(System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.SafeEventBroker.RemoveHandler(System.Delegate)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.EventInterceptor">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.EventInterceptor.Handler">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.EventInterceptor.Instance">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptor.#ctor(System.Object,System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptor.Subscribe">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptor.Unsubscribe">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizations)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizationAttribute.Optimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.EventInterceptionAdviceOptimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.EventInterceptionArgsImpl">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.#ctor(System.Object,PostSharp.Aspects.Arguments,System.Delegate)">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.TypedBinding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.Binding">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.ProceedAddHandler">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.ProceedRemoveHandler">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.ProceedInvokeHandler">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.AddHandler(System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.RemoveHandler(System.Delegate)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.EventInterceptionArgsImpl.InvokeHandler(System.Delegate,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.HasOnInstanceConstructedAttribute">
            <exclude/>
        </member>
        <member name="T:PostSharp.Aspects.Internals.LocationBinding`1">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.GetValue(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.SetValue(System.Object@,PostSharp.Aspects.Arguments,`0,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.PostSharp#Aspects#ILocationBinding#GetValue(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.PostSharp#Aspects#ILocationBinding{T}#SetValue(System.Object@,PostSharp.Aspects.Arguments,`0)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.PostSharp#Aspects#ILocationBinding{T}#GetValue(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.PostSharp#Aspects#ILocationBinding#SetValue(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationBinding`1.LocationInfo">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationBinding`1.LocationType">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationBinding`1.DeclarationIdentifier">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationBinding`1.Execute``1(PostSharp.Aspects.ILocationBindingAction{``0},``0@)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizationAttribute.Optimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations.IgnoreGetLocation">
            <summary>
            If set, it means that <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Location"/> is not accessed, so we don't need to emit code that would set it.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations.IgnoreGetLocationName">
            <summary>
            If set, it means that <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.LocationName"/> is not accessed, so we don't need to emit code that would set it.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.LocationInterceptionAdviceOptimizations.IgnoreGetLocationFullName">
            <summary>
            If set, it means that <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.LocationFullName"/> is not accessed, so we don't need to emit code that would set it.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.#ctor(System.Object,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.TypedBinding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.Binding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.Value">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.TypedValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.ProceedGetValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.ProceedSetValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.GetCurrentValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.SetNewValue(System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationInterceptionArgsImpl`1.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.LocationLevelAdviceArgs">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value">
            <summary>
              Gets or sets the location value.
            </summary>
            <remarks>
              <para>
                Inside an <see cref = "M:PostSharp.Aspects.ILocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, this property is available after
                the next advice in chain has been invoked using <see cref = "M:PostSharp.Aspects.LocationInterceptionArgs.ProceedGetValue" />. However, 
                inside an <see cref = "M:PostSharp.Aspects.ILocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> advice, the value is available immediately,
                and is used as input by <see cref = "M:PostSharp.Aspects.LocationInterceptionArgs.ProceedSetValue" />. 
              </para>
              <para>
                See <see cref = "M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> and <see cref = "M:PostSharp.Aspects.LocationInterceptionArgs.SetNewValue(System.Object)" />
                to get or set the value of the location without affecting the value of this property.
              </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Location">
            <summary>
              Gets the location (field, property or parameter) related to the aspect or advice being executed.
            </summary>
            <remarks>
              <note>
                Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
                this property whenever possible. One of the possible solution is to use compile-time initialization of
                aspect instances and to make use of reflection only at build time.
              </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.LocationName">
            <summary>
              Gets the name of the location (field, property or parameter) related to the aspect or advice being executed.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.LocationFullName">
            <summary>
              Gets the full name (including the full name of the declaring type) of the location (field, property or parameter) related to the aspect or advice being executed.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodBinding">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodBinding.PostSharp#Aspects#IMethodBinding#Invoke(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodBinding.Invoke(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodBinding`1">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodBinding`1.PostSharp#Aspects#IMethodBinding#Invoke(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodBinding`1.Invoke(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.AsyncMethodBinding`1">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding`1.Invoke(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding`1.PostSharp#Aspects#IAsyncMethodBinding#InvokeAsync(System.Object@,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding`1.InvokeAsync(System.Object@,PostSharp.Aspects.Arguments,System.Object)">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.AsyncMethodBinding`1.PostSharp#Aspects#ITaskAdapter#GetResult(System.Threading.Tasks.Task)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizations)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizationAttribute.Optimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodExecutionAdviceOptimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizations)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizationAttribute.Optimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodInterceptionAdviceOptimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.#ctor(System.Object,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.TypedBinding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.Binding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.ReturnValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.Proceed">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.Invoke(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.IsAsync">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.AsyncBinding">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.ProceedAsync">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl.InvokeAsync(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.#ctor(System.Object,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.TypedBinding">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.TypedReturnValue">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.Binding">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.ReturnValue">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.Proceed">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.Invoke(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.IsAsync">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.AsyncBinding">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.ProceedAsync">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.MethodInterceptionArgsImpl`1.InvokeAsync(PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresAdviceAnalysisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresCreateInstanceAnalysisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresDebuggerEnhancementAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.RequiresDebuggerEnhancementAttribute.#ctor(PostSharp.Aspects.Internals.DebuggerStepOverAspectBehavior)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.RequiresDebuggerEnhancementAttribute.Kind">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresEventInterceptionAdviceAnalysisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresLocationInterceptionAdviceAnalysisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresMethodExecutionAdviceAnalysisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RequiresMethodInterceptionAdviceAnalysisAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute.#ctor(PostSharp.Aspects.Internals.RuntimeInitializeOptimizations)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.RuntimeInitializeOptimizationAttribute.Optimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.RuntimeInitializeOptimizations">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1">
            <exclude />
            <summary>
            Base class for PostSharp-created state machines created for methods that return IEnumerable, if there's a semantically advised method boundary advice
            in front of a non-semantically advised advice. 
            </summary>
            <remarks>
            In this class, "the target method" means a newly created method to which we moved the body of the "kickoff" method (the method
            to which the user applied the aspects).
            <para>
            This class always uses the non-generic enumerable and the non-generic enumerator because it works for non-generic enumerables and pretty much
            all generic enumerables have the same methods implementing both the generic and the non-generic interfaces.
            </para>
            </remarks>
            <typeparam name="TElement">Type of elements of the enumerator or enumerable. If it's a non-generic enumerator or enumerable, then this is <see cref="T:System.Object"/>.</typeparam>
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.YieldValueFieldName">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.IsDisposingFieldName">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.StateFieldName">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.yieldValue">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.isDisposing">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.state">
            <exclude />
        </member>
        <member name="M:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.Dispose">
            <summary>
            Disposes the decorated enumerator and calls OnSuccess and OnExit, if OnEntry was called but OnExit wasn't yet called.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.CallTargetEnumerableMethod">
            <summary>
            Calls the target method, possibly with some arguments changed. This method is only overridden if the target method has <see cref="T:System.Collections.IEnumerable"/>
            or <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the return type.
            </summary>
            <returns>The return value of the target method; or null if the target method returns an enumerator.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.CallTargetEnumeratorMethod">
            <summary>
            Calls the target method, possibly with some arguments changed. This method is only overridden if the target method has <see cref="T:System.Collections.IEnumerator"/>
            or <see cref="T:System.Collections.Generic.IEnumerator`1" /> as the return type.
            </summary>
            <returns>The return value of the target method; or null if the target method returns an enumerable.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.MoveNext">
            <summary>
            Advances this (as an enumerator) to the next element by calling MoveNext() on the decorated enumerator, then accesses its <see cref="P:System.Collections.IEnumerator.Current"/>
            and stores it, so that it can be read and modified by <see cref="M:PostSharp.Aspects.IOnStateMachineBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)"/> advices.
            </summary>
            <returns>Whatever the decorated enumerator returns.</returns>
        </member>
        <member name="M:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.CreateCopy">
            <summary>
            Creates an enumerator from this enumerable as a copy of this instance. See Remarks.
            </summary>
            <returns>A copy of this instance.</returns>
            <remarks>
            This method is only called if this instance represents an enumerable. It's called only from <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> and
            <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/> and its return value represents the enumerator.
            <para>
            This way, each enumerator has its own set of arguments and its own method execution tag, so and if you change the arguments or the tag, it will
            only affect that enumerator an not all of them. 
            </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.Reset">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.Current">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.Internals.StateMachine.BaseGeneratedIteratorStateMachine`1.System#Collections#IEnumerator#Current">
            <exclude />
        </member>
        <member name="T:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineIsDisposingStatus">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineIsDisposingStatus.NotDisposing">
            <summary>
            Value of an iterator state machine's isDisposing field if <see cref="M:System.IDisposable.Dispose"/> wasn't yet run or already completed, we're not
            inside a Dispose call.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineIsDisposingStatus.DisposeInProgress">
            <summary>
            Value of an iterator state machine's isDisposing field if <see cref="M:System.IDisposable.Dispose"/> was called and is currently doing the disposing.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineIsDisposingStatus.AfterDisposeMoveNextInProgress">
            <summary>
            Value of an iterator state machine's isDisposing field if <see cref="M:System.IDisposable.Dispose"/> was called, resources have been disposed of,
            and now PostSharp is running a final MoveNext iteration to force remaining OnSuccess/OnExit advices to run.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineState">
            <exclude />
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineState.EnumeratorNotYetCreated">
            <summary>
            Value of an iterator state machine's state field if the state machine represents an <see cref="T:System.Collections.IEnumerable"/> for which <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> wasn't yet called.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineState.EnumerationEnded">
            <summary>
            Value of an iterator state machine's state field if the enumerator reached its end.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.Internals.StateMachine.IteratorStateMachineState.BeforeUserCode">
            <summary>
            Value of an iterator state machine's state field just before execution of the first user code. 
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.IOnExceptionAspect">
            <summary>
              Runtime semantics of an aspect that, when applied on a method,
              defines an exception handler around the whole method body
              and lets the implementation of this interface handle the exception.
            </summary>
            <remarks>
              <para>See <see cref = "T:PostSharp.Aspects.OnExceptionAspect" /> for details.</para>
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.OnExceptionAspect" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.OnExceptionAspectConfiguration" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute" />
        </member>
        <member name="M:PostSharp.Aspects.IOnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
              Method executed <b>after</b> the body of methods to which this aspect is applied,
              in case that the method failed with an exception (i.e., in a <c>catch</c> block).
            </summary>
            <param name = "args">Advice arguments.</param>
        </member>
        <member name="T:PostSharp.Aspects.IOnInstanceLocationInitializedAspect">
            <summary>
            Contains the signature of <see cref="M:PostSharp.Aspects.IOnInstanceLocationInitializedAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)"/>, a location-level advice.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.IOnInstanceLocationInitializedAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)">
            <summary>
            Method invoked <i>after</i> an initial value is set for a field or property to which the current aspect is applied.
            The method is invoked only for instance fields and instance auto-implemented properties, and it is invoked after their inline initialization.
            For static fields and properties, and for accesses from the constructor, OnSetValue is invoked instead.
            </summary>
            <remarks>
            <para>
            This method is invoked at the beginning of an instance constructor.
            If more than one field or property is affected by this advice, this method will be called for them in declaration
            order of the properties (so, if in your C# file you declare first "a", then "b", then the method will be called for "a" first).
            If more than one advice group applies to a property, they will be called in order of aspect priority as normal.
            </para>
            <para>
            This method is invoked for all instance fields and auto-implemented properties, even if they do not have an initializer. If they don't,
            the method is called with the default value in the <see cref="P:PostSharp.Aspects.Internals.LocationLevelAdviceArgs.Value"/> property (<c>null</c>, zero, or <c>false</c>).
            </para>
            <para>
            For structs, this method is only invoked if an actual non-default constructor of the struct is invoked.
            </para>
            </remarks>
            <param name="args">Information about the location.</param>
        </member>
        <member name="T:PostSharp.Aspects.IOnMethodBoundaryAspect">
            <summary>
              Runtime semantics of <see cref = "T:PostSharp.Aspects.OnMethodBoundaryAspect" />.
            </summary>
            <remarks>
              <para>See <see cref = "T:PostSharp.Aspects.OnMethodBoundaryAspect" /> for details.</para>
            </remarks>
            <seealso cref = "T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfiguration" />
            <seealso cref = "T:PostSharp.Aspects.Configuration.OnMethodBoundaryAspectConfigurationAttribute" />
        </member>
        <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
              Method executed <b>before</b> the body of methods to which this aspect is applied.
            </summary>
            <param name = "args">Event arguments specifying which method
              is being executed, which are its arguments, and how should the execution continue
              after the execution of <see cref = "M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />.</param>
            <remarks>
              If the aspect is applied to a constructor, the current method is invoked
              after the <c>this</c> pointer has been initialized, that is, after
              the base constructor has been called.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
              Method executed <b>after</b> the body of methods to which this aspect is applied,
              even when the method exists with an exception (this method is invoked from
              the <c>finally</c> block).
            </summary>
            <param name = "args">Event arguments specifying which method
              is being executed and which are its arguments.</param>
        </member>
        <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
              Method executed <b>after</b> the body of methods to which this aspect is applied,
              but only when the method successfully returns (i.e. when no exception flies out
              the method.).
            </summary>
            <param name = "args">Event arguments specifying which method
              is being executed and which are its arguments.</param>
        </member>
        <member name="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
              Method executed <b>after</b> the body of methods to which this aspect is applied,
              in case that the method resulted with an exception.
            </summary>
            <param name = "args">Event arguments specifying which method
              is being executed and which are its arguments.</param>
        </member>
        <member name="T:PostSharp.Aspects.IOnStateMachineBoundaryAspect">
            <summary>
            Extends the <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect"/> interface with two advises
            to be applied on state machines.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.IOnStateMachineBoundaryAspect.OnResume(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
            Method executed when a state machine resumes execution after a <c>yield return</c> or
            <c>await</c> statement.
            </summary>
            <remarks>
            <para>For iterator methods, this advice is executed before the <see cref="M:System.Collections.IEnumerator.MoveNext"/> method.
            However, the very first call of <see cref="M:System.Collections.IEnumerator.MoveNext"/> maps to <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)"/>.
            </para>
            <para>In async methods, the advice is executed just after the state machine restarts execution after having waited 
            as a result of the <c>await</c> statement. </para>
            </remarks>
            <param name = "args">Event arguments specifying which method
              is being executed and which are its arguments.</param>
        </member>
        <member name="M:PostSharp.Aspects.IOnStateMachineBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)">
            <summary>
            Method executed when a state machine yields, as the result of a <c>yield return</c> or
            <c>await</c> statement.
            </summary>
            <remarks>
            <para>In iterator methods, this advise is exactly executed at the <c>yield return</c> statement.</para>
            <para>
            In async methods, the advice is executed just after the state machine starts waiting as a result of the <c>await</c> statement.
             In case the operand of the <c>await</c> statement is an operation that completed synchronously, the state machine
            does not yield, and the <see cref="M:PostSharp.Aspects.IOnStateMachineBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)"/> advise won't be invoked.
             </para>
            </remarks>
            <param name = "args">Event arguments specifying which method
              is being executed and which are its arguments. In iterator methods, the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.YieldValue"/>
            property gives access to the operand of the <c>yield return</c> statement.</param>
        </member>
        <member name="T:PostSharp.Aspects.ITypeLevelAspect">
            <summary>
              Run-time semantics of aspects applied to types.
            </summary>
            <seealso cref = "T:PostSharp.Aspects.ITypeLevelAspectBuildSemantics" />
        </member>
        <member name="M:PostSharp.Aspects.ITypeLevelAspect.RuntimeInitialize(System.Type)">
            <summary>
              Initializes the current aspect.
            </summary>
            <param name="type">Type to which the current aspect is applied.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.ITypeLevelAspectBuildSemantics">
            <summary>
              Compile-time semantics of <see cref = "T:PostSharp.Aspects.ITypeLevelAspect" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ITypeLevelAspectBuildSemantics.CompileTimeInitialize(System.Type,PostSharp.Aspects.AspectInfo)">
            <summary>
              Method invoked at build time to initialize the instance fields of the current aspect. This method is invoked
              before any other build-time method.
            </summary>
            <param name="type">Type to which the current aspect is applied</param>
            <param name="aspectInfo">Reserved for future usage.</param>
            <seealso href="@aspect-initialization" target="_self">
      Conceptual: Initializing Aspects
    </seealso>
        </member>
        <member name="T:PostSharp.Aspects.LinesOfCodeAvoidedAttribute">
            <summary>
            Custom attribute that, when applied to an aspect class, specifies how many manual lines of code
            are avoided every time the aspect is being used.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.LinesOfCodeAvoidedAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.LinesOfCodeAvoidedAttribute"/>.
            </summary>
            <param name="lines">Number of lines of code saved every time the aspect is applied to a target class.</param>
        </member>
        <member name="P:PostSharp.Aspects.LinesOfCodeAvoidedAttribute.Count">
            <summary>
            Gets the number of lines of code saved every time the aspect is applied to a target class.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.LocationBindingExtensions">
            <summary>
            Extension methods for the <see cref="T:PostSharp.Aspects.ILocationBinding"/> interface.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.GetValue(PostSharp.Aspects.ILocationBinding,System.Object,PostSharp.Aspects.Arguments)">
            <summary>
            Gets the value of an indexer (property with arguments).
            </summary>
            <param name="locationBinding">The binding for the indexer.</param>
            <param name="instance">The instance for which the indexer is evaluated, or <c>null</c> if the indexer is static.</param>
            <param name="index">The arguments of the indexer.</param>
            <returns>The indexer value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.GetValue``1(PostSharp.Aspects.ILocationBinding{``0},System.Object,PostSharp.Aspects.Arguments)">
            <summary>
            Gets the value of an indexer (property with arguments).
            </summary>
            <param name="locationBinding">The binding for the indexer.</param>
            <param name="instance">The instance for which the indexer is evaluated, or <c>null</c> if the indexer is static.</param>
            <param name="index">The arguments of the indexer.</param>
            <returns>The indexer value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.GetValue(PostSharp.Aspects.ILocationBinding,System.Object)">
            <summary>
            Gets the value of a field or property.
            </summary>
            <param name="locationBinding">The binding for the field or property.</param>
            <param name="instance">The instance for which the field or property is evaluated, or <c>null</c> if the location is static.</param>
            <returns>The field or property value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.GetValue``1(PostSharp.Aspects.ILocationBinding{``0},System.Object)">
            <summary>
            Gets the value of a field or property.
            </summary>
            <param name="locationBinding">The binding for the field or property.</param>
            <param name="instance">The instance for which the field or property is evaluated, or <c>null</c> if the location is static.</param>
            <returns>The field or property value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.SetValue(PostSharp.Aspects.ILocationBinding,System.Object,PostSharp.Aspects.Arguments,System.Object)">
            <summary>
            Sets the value of an indexer (property with arguments).
            </summary>
            <param name="locationBinding">The binding for the indexer.</param>
            <param name="instance">The instance for which the indexer is set, or <c>null</c> if the indexer is static.</param>
            <param name="index">The arguments of the indexer.</param>
            <param name="value">The new value.</param>
            <returns>The indexer value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.SetValue``1(PostSharp.Aspects.ILocationBinding{``0},System.Object,PostSharp.Aspects.Arguments,``0)">
            <summary>
            Sets the value of an indexer (property with arguments).
            </summary>
            <param name="locationBinding">The binding for the indexer.</param>
            <param name="instance">The instance for which the indexer is set, or <c>null</c> if the indexer is static.</param>
            <param name="index">The arguments of the indexer.</param>
            <param name="value">The new value.</param>
            <returns>The indexer value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.SetValue``1(PostSharp.Aspects.ILocationBinding{``0},System.Object,``0)">
            <summary>
            Sets the value of a field or property.
            </summary>
            <param name="locationBinding">The binding for the field or property.</param>
            <param name="instance">The instance for which the field or property is set, or <c>null</c> if the location is static.</param>
            <param name="value">The new value assigned to the field or property.</param>
            <returns>The field or property value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="M:PostSharp.Aspects.LocationBindingExtensions.SetValue(PostSharp.Aspects.ILocationBinding,System.Object,System.Object)">
            <summary>
            Sets the value of a field or property.
            </summary>
            <param name="locationBinding">The binding for the field or property.</param>
            <param name="instance">The instance for which the field or property is set, or <c>null</c> if the location is static.</param>
            <param name="value">The new value assigned to the field or property.</param>
            <returns>The field or property value.</returns>
            <seealso cref="M:PostSharp.Aspects.ILocationBinding.GetValue(System.Object@,PostSharp.Aspects.Arguments)"/>
        </member>
        <member name="T:PostSharp.Aspects.LocationInitializationArgs">
            <summary>
            Represents information about a location that has just been initialized. Used in <see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.LocationInitializationArgs.#ctor(System.Object,System.Object)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.LocationInitializationArgs.Value">
            <summary>
            Gets the initial value of the location.
            </summary>
            <remarks>
            Returns the current value of the field or, if it's a property, of the property's backing field. This is usually the default value or the value
            set by the initializer.
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.LocationInterceptionArgs">
            <summary>
              Arguments of advices of aspect type <see cref="T:PostSharp.Aspects.LocationInterceptionAspect" />.
            </summary>
            <remarks>
              <note>
      As a result of weaving optimizations, instances of classes derived from
      <see cref="T:PostSharp.Aspects.AdviceArgs" />
      may be shared among different aspects. Therefore,
      aspect code should not attempt to access this object once the control has been given over to the next node in the chain of invocation. Consider working
      with
      <see href="@interception-aspects" target="_self">aspect bindings</see>
      if you need such deferred execution.
    </note><note>
      Aspect weaving optimizations may also cause an advice parameter of this type to be seen <c>null</c> when inspecting it in a debugger.
      If you need to inspect the instance in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.LocationInterceptionAspect" />
        </member>
        <member name="P:PostSharp.Aspects.LocationInterceptionArgs.Binding">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Aspects.LocationInterceptionArgs.Index">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedGetValue">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedSetValue">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionArgs.SetNewValue(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionArgs.Execute``1(PostSharp.Aspects.ILocationInterceptionArgsAction{``0},``0@)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.LocationInterceptionAspect">
            <summary>
            Aspect that, when applied on a location (field or property), intercepts invocations of
            the <c>Get</c> (<see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) and <c>Set</c> (<see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" />) semantics.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.LocationInterceptionAspectConfigurationAttribute" />
            <remarks>
            <para>
            This aspect can be applied indifferently to fields and properties, called <i>locations</i> 
            because they both have the semantics of a slot where a value can be stored and retrieved.
            </para>
            <h5>Applying the Aspect on Properties</h5>
            <para>Applying an aspect of type <see cref="T:PostSharp.Aspects.LocationInterceptionAspect" /> to a property results in the accessors of this property to be replaced by a call to the method <see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> 
            or <see cref="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)" /> of the current class. The original body of the accessor is moved into a new method, 
            which can be called by the aspect by invoking one of the methods 
            <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedGetValue" />, <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedSetValue" />,
            <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> or <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.SetNewValue(System.Object)" />,
            or by using the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" /> object.</para>
            <h5>Applying the Aspect on Fields</h5>
            <para>Applying this aspect on a field transforms the field into a property of the same name,
            scope and visibility as the original field. The original field is removed. Aspect code can get or set the
            value of the field by calling the methods <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedGetValue" />, 
            <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.ProceedSetValue" />,  <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.GetCurrentValue" /> 
            or <see cref="M:PostSharp.Aspects.LocationInterceptionArgs.SetNewValue(System.Object)" />, or by using the <see cref="P:PostSharp.Aspects.LocationInterceptionArgs.Binding" /> object.</para>
            <para><note>
            Remember to use
            <see cref="T:System.Reflection.PropertyInfo" /> instead of <see cref="T:System.Reflection.FieldInfo" /> at runtime to reflect the original field.
            For this reason, you cannot store a <see cref="T:System.Reflection.FieldInfo" /> in the aspect. 
            Store a <see cref="T:PostSharp.Reflection.LocationInfo" />
            instead; even if a <see cref="T:PostSharp.Reflection.LocationInfo" /> represents a field at build time, it will represent
            the corresponding <see cref="T:System.Reflection.PropertyInfo" /> at runtime.</note></para>
            <para><note>
            When you apply an aspect derived from <see cref="T:PostSharp.Aspects.LocationInterceptionAspect" /> to a value-type field, 
            you should not pass the value of this field by reference (as an argument to <c>out</c> and <c>ref</c> parameters in C#).
            Indeed, PostSharp is unable to detect read and write accesses through references. 
            </note></para>
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso href="@interception-aspects" target="_self">
      Conceptual: Interception Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionAspect.OnGetValue(PostSharp.Aspects.LocationInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionAspect.OnSetValue(PostSharp.Aspects.LocationInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionAspect.OnInstanceLocationInitialized(PostSharp.Aspects.LocationInitializationArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationInterceptionAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.LocationLevelAspect">
            <summary>
            Base class for aspects defined in fields, properties, or parameters.
            </summary>
            <remarks>
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.ILocationLevelAspect" />
        </member>
        <member name="M:PostSharp.Aspects.LocationLevelAspect.RuntimeInitialize(PostSharp.Reflection.LocationInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationLevelAspect.CompileTimeInitialize(PostSharp.Reflection.LocationInfo,PostSharp.Aspects.AspectInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationLevelAspect.CompileTimeValidate(PostSharp.Reflection.LocationInfo)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="locationInfo">Location to which the aspect has been applied</param>
            <returns><c>true</c> if the aspect was applied to an acceptable field, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.LocationLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,PostSharp.Reflection.LocationInfo)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetLocation">Location to which the current aspect has been applied.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.LocationLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.LocationLevelAspect.CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.LocationValidationContext">
            <summary>
            Enumerates the possible contexts in which the location validation advices can be invoked.
            </summary>
            <remarks>
              This enumeration can be passed as an argument to the method marked with the <see cref="T:PostSharp.Aspects.Advices.LocationValidationAdvice"/> attribute.
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.LocationValidationContext.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.LocationValidationContext.Precondition">
            <summary>
            The value is being validated on method entry.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.LocationValidationContext.SuccessPostcondition">
            <summary>
            The value is being validated just before the method successfully returns.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.ManagedResourceIntroductionAspect">
            <summary>
              Aspect that, when applied to an assembly, adds a custom attribute to this assembly.
            </summary>
            <seealso href="@aspect-provider" target="_self">
      Conceptual: Adding Aspects Dynamically
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.ManagedResourceIntroductionAspect.#ctor(System.String,System.Byte[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.ManagedResourceIntroductionAspect" /> by passing the data as a byte array.
            </summary>
            <param name = "name">Name of the managed resource.</param>
            <param name = "data">Content of the managed resource.</param>
        </member>
        <member name="M:PostSharp.Aspects.ManagedResourceIntroductionAspect.#ctor(System.String,System.Func{System.Byte[]})">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Aspects.ManagedResourceIntroductionAspect" /> by passing a delegate for late evaluation of
            the resource content.
            </summary>
            <param name = "name">Name of the managed resource.</param>
            <param name = "dataProvider">A method that returns the data to be introduced. If the method returns <c>null</c>,
            the aspect will be ignored and no managed resource will be introduced.
            .</param>
        </member>
        <member name="P:PostSharp.Aspects.ManagedResourceIntroductionAspect.Name">
            <summary>
              Gets the name of the managed resource.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ManagedResourceIntroductionAspect.Data">
            <summary>
              Gets the content of the managed resource.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.ManagedResourceIntroductionAspect.DataProvider">
            <summary>
            Gets a delegate that provides content of the managed resource.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.MethodBindingInvokeAwaitable">
            <summary>
            Represents the awaitable result of the asynchronous method invocation.
            Await this value to get the <c>System.Object</c> instance containing the return value of the async method.
            The result of the await is <c>null</c> for async methods that do not return any value.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodBindingInvokeAwaitable.GetAwaiter">
            <summary>
            Gets an awaiter used to await the asynchronous method invocation.
            </summary>
            <returns><see cref="T:PostSharp.Aspects.MethodBindingInvokeAwaiter"/> used to await the asynchronous method invocation.</returns>
        </member>
        <member name="M:PostSharp.Aspects.MethodBindingInvokeAwaitable.GetTask">
            <summary>
            Gets the underlying task that was returned by the asynchronous method invocation.
            </summary>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> instance returned by the asynchronous method.</returns>
        </member>
        <member name="T:PostSharp.Aspects.MethodBindingInvokeAwaiter">
            <summary>
            Represents the awaiter for the result of the asynchronous method invocation.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.MethodBindingInvokeAwaiter.IsCompleted">
            <summary>
            Gets a value that indicates whether a yield is not required.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodBindingInvokeAwaiter.GetResult">
            <summary>
            Ends the await operation.
            </summary>
            <returns>The result of the asynchronous invocation.</returns>
        </member>
        <member name="M:PostSharp.Aspects.MethodBindingInvokeAwaiter.OnCompleted(System.Action)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodBindingInvokeAwaiter.UnsafeOnCompleted(System.Action)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.MethodExecutionArgs">
            <summary>
              Arguments of advices of aspects of type <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" /> and <see cref="T:PostSharp.Aspects.OnExceptionAspect" />
            </summary> 
            <remarks>
              <note>
      As a result of weaving optimizations, instances of classes derived from
      <see cref="T:PostSharp.Aspects.AdviceArgs" />
      may be shared among different aspects. Therefore,
      aspect code should not attempt to access this object once the control has been given over to the next node in the chain of invocation. Consider working
      with
      <see href="@interception-aspects" target="_self">aspect bindings</see>
      if you need such deferred execution.
    </note><note>
      Aspect weaving optimizations may also cause an advice parameter of this type to be seen <c>null</c> when inspecting it in a debugger.
      If you need to inspect the instance in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.MethodExecutionArgs.#ctor(System.Object,PostSharp.Aspects.Arguments)">
            <exclude />
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.Method">
            <summary>
              Gets the method being executed.
            </summary>
            <note>
               As a result of weaving optimizations, this property may be seen <c>null</c> when inspecting its value using a debugger.
               Therefore, you may want to disable aspect optimizer
            </note>
            <remarks>
              <para>If the executed method is generic or if its declaring type is generic,
                the current property contains the generic instance being executed.</para>
              <note>
                Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
                this property whenever possible. One of the possible solution is to use compile-time initialization of
                aspect instances and to make use of reflection only at build time. See <see cref="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)" />
                for details.
              </note>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
            <seealso cref="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)" />
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.Arguments">
            <summary>
              Gets the arguments with which the method has been invoked.
            </summary>
            <remarks>
              <note>The property setter should never be used in user code.</note>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue">
            <summary>
              Gets or sets the method return value.
            </summary>
            <remarks>
              <para>
                You can modify the return value only when the join point is located
                after a method execution (<see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />,
                <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" /> or <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />,
                or in case you force the method to exit using the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" /> property.
              </para>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
            <note>
               This property must not be accessed when the aspect is applied to a state machine or if the method returns a reference ("ref return").
            </note>
            <note>
              When a method returns a null <see cref="T:System.Threading.Tasks.Task" />, this property is equal to <see cref="T:PostSharp.Aspects.NullTaskSentinel" />.<see cref="P:PostSharp.Aspects.NullTaskSentinel.Instance" />
              and its value cannot be modified.
            </note>
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.YieldValue">
            <summary>
            Gets or sets the value yielded by the iterator method.
            </summary>
            <remarks>
              <para>
                This property is only available inside the <see cref="M:PostSharp.Aspects.IOnStateMachineBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)" /> advice
                when the current method is an iterator method.
              </para>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.IOnStateMachineBoundaryAspect" />
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.Exception">
            <summary>
              Gets or sets the exception thrown by the target method.
            </summary>
            <value>An <see cref = "P:PostSharp.Aspects.MethodExecutionArgs.Exception" />, or <c>null</c> if the method is exiting normally.</value>
            <remarks>
              <para>This property is only available inside the <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/> and <see cref="M:PostSharp.Aspects.IOnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)"/> advices.</para>
              <para>You can replace the exception by setting this property and also setting <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior"/> to <see cref="F:PostSharp.Aspects.FlowBehavior.ThrowException"/>. You can also throw a new exception from the advice if you need to replace the current exception.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior">
            <summary>
              Determines the control flow of the target method once the advice is exited.
            </summary>
            <remarks>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
               When this advice is applied to a state machine, you only have limited flow behavior options available. See documentation
            for <see cref="T:PostSharp.Aspects.FlowBehavior" /> for details.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag">
            <summary>
              User-defined state information whose lifetime is linked to the
              current method execution. Aspects derived from <see cref="T:PostSharp.Aspects.IOnMethodBoundaryAspect" />
              should use this property to save state information between
              different events (<see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />,
              <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" /> and <see cref="M:PostSharp.Aspects.IOnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />).
            </summary>
            <remarks>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="T:PostSharp.Aspects.MethodImplementationAspect">
            <summary>
            Aspect that, when applied on an abstract or <c>extern</c> method, creates an implementation for this method.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute" />
            <remarks>
            <para>This aspect is exactly identical to <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />, with the difference
            that it applies to abstract methods.</para>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.MethodImplementationAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodImplementationAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.MethodInterceptionArgs">
            <summary>
              Arguments of advices of aspect type <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />.
            </summary>
            <remarks>
              <note>
      As a result of weaving optimizations, instances of classes derived from
      <see cref="T:PostSharp.Aspects.AdviceArgs" />
      may be shared among different aspects. Therefore,
      aspect code should not attempt to access this object once the control has been given over to the next node in the chain of invocation. Consider working
      with
      <see href="@interception-aspects" target="_self">aspect bindings</see>
      if you need such deferred execution.
    </note><note>
      Aspect weaving optimizations may also cause an advice parameter of this type to be seen <c>null</c> when inspecting it in a debugger.
      If you need to inspect the instance in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
            </remarks>
            <seealso cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionArgs.Binding">
            <summary>
              Gets an interface that allows to invoke the next node in the chain of invocation of the intercepted method.
            </summary>
            <remarks>
              <para>
      Bindings are thread-safe and context-free singleton instances exposing the next node in the chain of invocation.
    </para><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue">
            <summary>
              Gets or sets the return value of the method.
            </summary>
            <remarks>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionArgs.Method">
            <summary>
              Gets the method being executed.
            </summary>
            <remarks>
              <para>If the executed method is generic or if its declaring type is generic,
                the current property contains the generic instance being executed.</para>
              <note>
                Using this property causes the aspect weaver to generate code that has non-trivial runtime overhead. Avoid using
                this property whenever possible. One of the possible solution is to use compile-time initialization of
                aspect instances and to make use of reflection only at build time. See <see cref="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)" />
                for details.
              </note>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
            <seealso cref="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)" />
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionArgs.Arguments">
            <summary>
              Gets the list of arguments with which the method has been invoked.
            </summary>
            <remarks>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionArgs.Proceed">
            <summary>
              Proceeds with invocation of the method that has been intercepted by calling the next node in the chain of invocation, 
              passing the current <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.Arguments" /> to that method and 
              storing its return value into the property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" />.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionArgs.Invoke(PostSharp.Aspects.Arguments)">
            <summary>
              Invokes the method that has been intercepted by calling the next node in the chain of invocation with given arguments,
              without affecting the property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" />.
            </summary>
            <param name = "arguments">Arguments passed to the intercepted method.</param>
            <returns>Value returned by the intercepted method.</returns>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionArgs.IsAsync">
            <summary>
            Determines whether the intercepted method is <c>async</c>, and therefore whether the <see cref="P:PostSharp.Aspects.MethodInterceptionArgs.AsyncBinding"/> property
            and <see cref="M:PostSharp.Aspects.MethodInterceptionArgs.ProceedAsync"/> method are available.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionArgs.AsyncBinding">
            <summary>
              Gets an interface that allows to invoke asynchronously the next node in the chain of invocation of the intercepted method.
            </summary>
            <remarks>
              <para>
      Bindings are thread-safe and context-free singleton instances exposing the next node in the chain of invocation.
    </para><seealso href="@interception-aspects" target="_self">
      Conceptual: Aspect Bindings
    </seealso>
              <note>
      As a result of weaving optimizations, value of this property may be seen as <c>null</c> in a debugger.
      If you need to inspect the value in runtime, consider disabling aspect optimizations in the debug build configuration.
    </note>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionArgs.ProceedAsync">
            <summary>
              Proceeds asynchronously with invocation of the method that has been intercepted by calling the next node in the chain of invocation, 
              passing the current <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.Arguments" /> to that method and 
              storing its return value into the property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" /> upon the completion of the intercepted async method.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionArgs.InvokeAsync(PostSharp.Aspects.Arguments)">
            <summary>
              Invokes asynchronously the method that has been intercepted by calling the next node in the chain of invocation with given arguments,
              without affecting the property <see cref = "P:PostSharp.Aspects.MethodInterceptionArgs.ReturnValue" />.
            </summary>
            <param name = "arguments">Arguments passed to the intercepted method.</param>
            <returns>The value that can be awaited to get the result of the intercepted method's invocation.</returns>
        </member>
        <member name="T:PostSharp.Aspects.MethodInterceptionAspect">
            <summary>
            Aspect that, when applied on a method, intercepts invocations of this method.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Configuration.MethodInterceptionAspectConfigurationAttribute" />
            <remarks>
            <para>Applying a <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" /> to a method results in the body of this method to be replaced by a call to the aspect <see cref="M:PostSharp.Aspects.MethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)" /> method of the current class. 
            The original method body is moved into a new method, which can be called by the aspect by invoking the <see cref="M:PostSharp.Aspects.MethodInterceptionArgs.Proceed" /> method,
            or by using the object <see cref="P:PostSharp.Aspects.MethodInterceptionArgs.Binding" />.</para>
            <note>
            PostSharp creates a local copy of all by-reference parameters (<c>in</c>, <c>out</c>, <c>ref</c>) and this local copy is passed to the intercepted method, not the original argument.
            This may have unwanted effects on multi-threaded code (because the argument value is not changed at the same moment as before) or when applying the aspect on a P-Invoke method
            (because a by-reference parameter could represent the starting address of a larger buffer).
            </note>
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
            <seealso href="@interception-aspects" target="_self">
      Conceptual: Interception Aspects
    </seealso>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionAspect.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the aspect when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionAspect.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the aspect is applied to an async method with unsupported return value type.
            </summary>
            <remarks>
            <para>
            Starting with C#7 async methods can have return types other than <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>.
            Async method interception does not support this type of async methods. By default, the build error is raised whenever
            async method interception is applied to a method that returns awaitable type other than <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>.
            </para>
            <para>
            Set this property to change how unsupported async methods are handled during compile time.
            </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionAspect.OnInvoke(PostSharp.Aspects.MethodInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionAspect.OnInvokeAsync(PostSharp.Aspects.MethodInterceptionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.MethodInterceptionProceedAwaitable">
            <summary>
            Represents the asynchronous proceed operation that calls the next node in the chain of invocation.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionProceedAwaitable.GetAwaiter">
            <summary>
            Gets an awaiter used to await the asynchronous method invocation.
            </summary>
            <returns><see cref="T:PostSharp.Aspects.MethodInterceptionProceedAwaiter"/> used to await the asynchronous method invocation.</returns>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionProceedAwaitable.GetTask">
            <summary>
            Gets the underlying task that represents the asynchronous proceed operation.
            </summary>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> instance that represents the asynchronous proceed operation.</returns>
        </member>
        <member name="T:PostSharp.Aspects.MethodInterceptionProceedAwaiter">
            <summary>
            Represents the awaiter for the completion of the asynchronous proceed operation.
            </summary>
        </member>
        <member name="P:PostSharp.Aspects.MethodInterceptionProceedAwaiter.IsCompleted">
            <summary>
            Gets a value that indicates whether a yield is not required.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionProceedAwaiter.GetResult">
            <summary>
            Ends the await operation.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionProceedAwaiter.OnCompleted(System.Action)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodInterceptionProceedAwaiter.UnsafeOnCompleted(System.Action)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.MethodLevelAspect">
            <summary>
            Base class for all aspects applied on methods.
            </summary>
            <seealso cref="T:PostSharp.Aspects.IMethodLevelAspect" />
            <remarks>
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeValidate(System.Reflection.MethodBase)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="method">Method to which the aspect has been applied</param>
            <returns><c>true</c> if the aspect was applied to an acceptable field, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodLevelAspect.CompileTimeInitialize(System.Reflection.MethodBase,PostSharp.Aspects.AspectInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.MethodBase)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetMethod">Method to which the current aspect has been applied.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the 
                <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.MethodLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.MethodLevelAspect.RuntimeInitialize(System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.ModuleInitializerAttribute">
            <summary>
            Custom attribute that, when added to a static method, causes the method to be executed immediately
            after the assembly is loaded by the CLR. The target method must be public, parameterless, void, and non-generic.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.ModuleInitializerAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Aspects.ModuleInitializerAttribute"/>.
            </summary>
            <param name="order">Order in which the <see cref="T:PostSharp.Aspects.ModuleInitializerAttribute"/> will be executed if the
            current project contains several initializers. Initializers with smaller values of the <paramref name="order"/>
            parameter get invoked first.</param>
        </member>
        <member name="P:PostSharp.Aspects.ModuleInitializerAttribute.Order">
            <summary>
            Gets the order in which the <see cref="T:PostSharp.Aspects.ModuleInitializerAttribute"/> will be executed if the
            current project contains several initializers. Initializers with smaller values of the <see cref="P:PostSharp.Aspects.ModuleInitializerAttribute.Order"/>
            property get invoked first.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.NullTaskSentinel">
            <summary>
            The singleton instance of this class is assigned to the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue"/> property when
            an <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect"/> aspect is applied semantically to a method and the target method returns a null task.
            </summary>
            <remarks>
            When an <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect"/> aspect is applied semantically to a method, then the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue"/> property
            represents the result of executing the task returned by the method. If the method returns a null task, then the result is undefined. The <see cref="P:PostSharp.Aspects.NullTaskSentinel.Instance"/>
            is used to represent this case.
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.NullTaskSentinel.Instance">
            <summary>
            The singleton instance that is assigned to the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue"/> property when
            an <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect"/> aspect is applied semantically to a method and the target method returns a null task.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.OnExceptionAspect">
            <summary>
            Aspect that, when applied to a method, defines an exception
            handler around the whole method and calls a custom method in this exception
            handler.
            </summary>
            <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" />
            <seealso cref="T:PostSharp.Aspects.Configuration.OnExceptionAspectConfigurationAttribute" />
            <remarks>
            <para>
            The <see cref="T:PostSharp.Aspects.OnExceptionAspect" /> aspect adds an exception handler to the method to which it is applied.
            It allows you to easily encapsulate exception handling policies as a custom attribute.</para>
            <para>The most important method is <see cref="M:PostSharp.Aspects.OnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />. It is the exception handler in itself.</para>
            <para> The current exception is available from the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" /> property of the <see cref="T:PostSharp.Aspects.MethodExecutionArgs" />
            object. This property is read-only. If you need to  replace the current exception by another one, you should throw a new exception 
            from the handler. If you need to ignore the exception, set the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" /> property to
            <see cref="F:PostSharp.Aspects.FlowBehavior.Continue" />.</para>
            <para>
      An object of type
      <see cref="T:PostSharp.Aspects.MethodExecutionArgs" />
      is passed to every advice of this aspect. This object allows you to:
    </para><list type="bullet">
      <item>
        <b>Get or set arguments.</b>
        Input and output arguments are available on the property
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Arguments" />. You can change output (<c>out</c>)
        and by-reference (<c>ref</c>)
        arguments, but not input arguments. If you need to modify arguments passed by value, consider using a
        <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
        (see property <see cref="P:PostSharp.Aspects.MethodInterceptionArgs.Arguments" />).
      </item>
      <item>
        <b>
          Get the current exception.
        </b>
        The current exception is available in the property <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" /> (only from the <see cref="M:PostSharp.Aspects.OnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" /> advice). 
        You can also replace the exception (see <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" /> for details).
      </item>
      <item>
        <b>
          Get or set the return value.
        </b> The return value is available in the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue" /> property. You can also modify it.
      </item>
      <item>
        <b>
          Change the method control flow.
        </b>
        You can change the value of the
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" />
        property to specify
        whether the target method should continue to execute after the execution of the current advice. 
        This may be useful to implement a caching aspect or an exception handler.
      </item>
      <item>
        <b>
          Share state between advices.
        </b>
        You can use the
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" />
        property to store state between the execution of
        different advices related to the same execution of a method. For instance, you can store a cache key in
        <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />
        and find it back in
        <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />. Using
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" />
        is the only way to share state that is both thread-safe and reentrant.
      </item>
    </list>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.OnExceptionAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Aspects.OnExceptionAspect.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the aspect when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.OnExceptionAspect.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the aspect is applied to an unsupported target method.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.OnExceptionAspect.GetExceptionType(System.Reflection.MethodBase)">
            <summary>
              Gets the type of exception handled by this aspect.
            </summary>
            <param name = "targetMethod">Method to which the current aspect is applied.</param>
            <returns>The type (derived from <see cref = "T:System.Exception" />) of exceptions handled
              by this aspect.</returns>
        </member>
        <member name="M:PostSharp.Aspects.OnExceptionAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnExceptionAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.OnMethodBoundaryAspect">
            <summary>
            Aspect that, when applied to a method defined in the current assembly, inserts a piece
            of code before and after the body of these methods.
            </summary>
            <remarks>
            <para>The <see cref="T:PostSharp.Aspects.OnMethodBoundaryAspect" /> aspect results in the target method to 
            be wrapped into a <c>try</c> ... <c>catch</c> ... <c>finally</c> block. You can
            implement four advices: <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />, executed at the beginning of the block;
            <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />, executed only when the method is successful (i.e. does not
            result in an exception); <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" />, invoked when the method results in 
            an exception; and <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)" />, always executed after method execution
            (whether the method resulted in an exception or not).</para>
            <para>Schematically, the aspect transforms the original method as follows:</para>
            <code lang="c#">
            int MyMethod(object arg0, int arg1)
            {
               OnEntry();
               try
               {
                // Original method body. 
                OnSuccess();
                return returnValue;
              }
              catch ( Exception e )
              {
                OnException();
              }
              finally
              {
                OnExit();
              }
            }
            </code>
            <para>Note that this code is only schematic; actually generated instructions are 
            more complex because they have to cope with parameter boxing and control flow 
            modification, among others.
            </para>
            <para>
      An object of type
      <see cref="T:PostSharp.Aspects.MethodExecutionArgs" />
      is passed to every advice of this aspect. This object allows you to:
    </para><list type="bullet">
      <item>
        <b>Get or set arguments.</b>
        Input and output arguments are available on the property
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Arguments" />. You can change output (<c>out</c>)
        and by-reference (<c>ref</c>)
        arguments, but not input arguments. If you need to modify arguments passed by value, consider using a
        <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />
        (see property <see cref="P:PostSharp.Aspects.MethodInterceptionArgs.Arguments" />).
      </item>
      <item>
        <b>
          Get the current exception.
        </b>
        The current exception is available in the property <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" /> (only from the <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)" /> advice). 
        You can also replace the exception (see <see cref="P:PostSharp.Aspects.MethodExecutionArgs.Exception" /> for details).
      </item>
      <item>
        <b>
          Get or set the return value.
        </b> The return value is available in the <see cref="P:PostSharp.Aspects.MethodExecutionArgs.ReturnValue" /> property. You can also modify it.
      </item>
      <item>
        <b>
          Change the method control flow.
        </b>
        You can change the value of the
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.FlowBehavior" />
        property to specify
        whether the target method should continue to execute after the execution of the current advice. 
        This may be useful to implement a caching aspect or an exception handler.
      </item>
      <item>
        <b>
          Share state between advices.
        </b>
        You can use the
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" />
        property to store state between the execution of
        different advices related to the same execution of a method. For instance, you can store a cache key in
        <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)" />
        and find it back in
        <see cref="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)" />. Using
        <see cref="P:PostSharp.Aspects.MethodExecutionArgs.MethodExecutionTag" />
        is the only way to share state that is both thread-safe and reentrant.
      </item>
    </list>
            <para>
            You can apply a method boundary aspect to a method that is outside your assembly. If you do, all calls to that method
            are intercepted and replaced with calls to a new method, in your assembly, that calls the original method. When this happens,
            by-reference parameters (<c>ref</c>) undergo special treatment similar to what happens in <see cref="T:PostSharp.Aspects.MethodInterceptionAspect" />.
            </para>
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnEntry(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnExit(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnSuccess(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnException(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Aspects.OnMethodBoundaryAspect.SemanticallyAdvisedMethodKinds">
            <summary>
            Determines which target methods will be advised semantically. This affects the behavior of the aspect when it's applied to
            iterator or async methods, which are compiled into state machines.
            </summary>
            <remarks>
            <para>
            Semantic advising results in an aspect that is consistent with the level of abstraction of the programming language. This is the default behavior.
            You can disable semantic advising using this property to be consistent with the level of abstraction
            of MSIL and for backward-compatibility with the versions of PostSharp prior to 3.1.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Aspects.OnMethodBoundaryAspect.UnsupportedTargetAction">
            <summary>
            Specifies the action to take when the aspect is applied to an unsupported target method.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.CreateAspectConfiguration">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnResume(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.OnMethodBoundaryAspect.OnYield(PostSharp.Aspects.MethodExecutionArgs)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.SemanticallyAdvisedMethodKinds">
            <summary>
            Enumerates possible target methods for semantic advising.
            </summary>
            <remarks>
            When semantic advising is enabled the advices work at the abstraction level of the original programming language.
            For example, advices are applied to the underlying async state machine instead of the public async method the starts the state machine.
            </remarks>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.None">
            <summary>
            Do not use semantic advising.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.Async">
            <summary>
            Apply semantic advising to async methods.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.ReturnsAwaitable">
            <summary>
            Apply semantic advising to methods that return any awaitable type (e.g. <c>System.Threading.Tasks.Task</c>).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.Iterator">
            <summary>
            Apply semantic advising to iterator methods (methods that use <c>yield</c> statements).
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.ReturnsEnumerable">
            <summary>
            Apply semantic advising to methods that return <see cref="T:System.Collections.IEnumerable"/>, <see cref="T:System.Collections.IEnumerator"/>, <see cref="T:System.Collections.Generic.IEnumerable`1"/>, or
            <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.AsyncIterator">
            <summary>
            Apply semantic advising to async methods which return IAsyncEnumerable. Semantic advising for this C# 8.0 feature is not supported by PostSharp yet.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.Default">
            <summary>
            The default behavior includes <see cref="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.Async"/>, <see cref="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.ReturnsAwaitable"/>, <see cref="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.Iterator"/>, and <see cref="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.AsyncIterator" />, but not <see cref="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.ReturnsEnumerable"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.SemanticallyAdvisedMethodKinds.All">
            <summary>
            Apply semantic advising to all possible target methods.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Serialization.AspectSerializer">
            <summary>
              Base class for all aspect serializers, whose role is to serialize aspect instances at compile-time and
              deserialize them at runtime.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.AspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream,PostSharp.Reflection.IMetadataEmitter)">
            <summary>
              Serializes an array of aspects into a stream.
            </summary>
            <param name = "aspects">Array of aspects to be serialized.</param>
            <param name = "stream">Stream into which aspects have to be serialized.</param>
            <param name="metadataEmitter">A metadata emitter for the current module.</param>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.AspectSerializer.Deserialize(System.IO.Stream,PostSharp.Reflection.IMetadataDispenser)">
            <summary>
              Deserializes a stream into an array if aspects.
            </summary>
            <param name = "stream">Stream containing serialized aspects.</param>
            <param name="metadataDispenser">Metadata dispenser to be used to resolve serialized metadata references in <paramref name="stream"/>.</param>
            <returns>An array of aspects.</returns>
            <remarks>
              The implementation is not allowed to change the order or array elements.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.AspectSerializer.Deserialize(System.Reflection.Assembly,System.String,PostSharp.Reflection.IMetadataDispenser)">
            <summary>
              Deserializes aspects contained in a managed resource of an assembly.
            </summary>
            <param name = "assembly">Assembly containing the serialized aspects.</param>
            <param name = "resourceName">Name of the managed resources into which aspects have been serialized.</param>
            <param name="metadataDispenser">Metadata dispenser to be used to resolve serialized metadata references in this resource.</param>
            <returns>An array of aspects.</returns>
        </member>
        <member name="T:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder">
            <summary>
              Implementation of <see cref = "T:System.Runtime.Serialization.SerializationBinder" /> used at runtime when aspect instances
              are deserialized. By overriding the default binder, you can resolve assembly names differently.
              This can be useful if assemblies have been renamed or merged between PostSharp run and execution
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder.#ctor">
            <summary>
            Initializes a new <seealso cref="T:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializationBinder.BindToType(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Serialization.BinaryAspectSerializer">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Serialization.AspectSerializer" /> based on the
              <see cref = "T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> provided by the full version
              of the .NET Framework.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializer.Deserialize(System.IO.Stream,PostSharp.Reflection.IMetadataDispenser)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream,PostSharp.Reflection.IMetadataEmitter)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Serialization.BinaryAspectSerializer.ChainSurrogateSelector(System.Runtime.Serialization.ISurrogateSelector)">
            <summary>
            Adds an item to the chain of surrogate selectors
            used during the process of serializing aspects.
            </summary>
            <param name="selector">A new surrogate selector.</param>
        </member>
        <member name="T:PostSharp.Aspects.Serialization.BinaryAspectSerializer.DelegateSerializationSurrogate">
            <summary>
            This surrogate checks that we do not try to serialize any delegate fields of the aspect class.
            If the delegate field has non-null value, then a build error should be raised.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.Serialization.IMetadataAwareSurrogateSelector">
            <summary>
            A <see cref="T:System.Runtime.Serialization.SurrogateSelector"/> that receives an <see cref="T:PostSharp.Reflection.IMetadataEmitter"/>
            before serialization.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.IMetadataAwareSurrogateSelector.SetMetadataEmitter(PostSharp.Reflection.IMetadataEmitter)">
            <summary>
            Sets the <see cref="T:PostSharp.Reflection.IMetadataEmitter"/>.
            </summary>
            <param name="metadataEmitter">An <see cref="T:PostSharp.Reflection.IMetadataEmitter"/>.</param>
        </member>
        <member name="T:PostSharp.Aspects.Serialization.MsilAspectSerializer">
            <summary>
              When used as a value of <see cref = "T:PostSharp.Aspects.Configuration.AspectConfigurationAttribute" />.<see cref = "P:PostSharp.Aspects.Configuration.AspectConfigurationAttribute.SerializerType" />
              property, specifies that the aspect should not be serialized but should instead be constructed at runtime using MSIL instructions.
            </summary>
            <remarks>
              This class is <b>not</b> a serializer. When you use MSIL aspect construction, the aspect is instantiated at runtime
              just as a normal custom attribute, and any initialization made at build time is lost.
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.MsilAspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream,PostSharp.Reflection.IMetadataEmitter)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Serialization.MsilAspectSerializer.Deserialize(System.IO.Stream,PostSharp.Reflection.IMetadataDispenser)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.Serialization.PortableAspectSerializer">
            <summary>
              Implementation of <see cref = "T:PostSharp.Aspects.Serialization.AspectSerializer" /> based on the <see cref = "T:PostSharp.Serialization.PortableFormatter" />, for use on any supported .NET platform.
            </summary>
            <seealso cref="T:PostSharp.Aspects.Serialization.AspectSerializer"/>
        </member>
        <member name="M:PostSharp.Aspects.Serialization.PortableAspectSerializer.Serialize(PostSharp.Aspects.IAspect[],System.IO.Stream,PostSharp.Reflection.IMetadataEmitter)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.Serialization.PortableAspectSerializer.Deserialize(System.IO.Stream,PostSharp.Reflection.IMetadataDispenser)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.TypeIdentity">
            <summary>
              Wraps a <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" /> or a type name.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.TypeIdentity.FromType(System.Type)">
            <summary>
              Wraps a <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" /> into a <see cref = "T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
            <param name = "type">A <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" />.</param>
            <returns>A <see cref = "T:PostSharp.Aspects.TypeIdentity" /> wrapping <paramref cref = "F:PostSharp.Aspects.TypeIdentity.type" />.</returns>
        </member>
        <member name="M:PostSharp.Aspects.TypeIdentity.FromTypes(System.Type[])">
            <summary>
              Wraps an array of <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" /> into an array of <see cref = "T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
            <param name = "types">An array of <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" />.</param>
            <returns>An array of <see cref = "T:PostSharp.Aspects.TypeIdentity" /> wrapping <paramref name = "types" />.</returns>
        </member>
        <member name="P:PostSharp.Aspects.TypeIdentity.Type">
            <summary>
              Gets the wrapped <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" />, or <c>null</c> it the <see cref = "P:PostSharp.Aspects.TypeIdentity.TypeName" /> property is set.
            </summary>
        </member>
        <member name="M:PostSharp.Aspects.TypeIdentity.ToType">
            <summary>
              Converts a <see cref = "T:PostSharp.Aspects.TypeIdentity" /> into a <see cref = "T:System.Type" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Aspects.TypeIdentity.FromTypeName(System.String)">
            <summary>
              Wraps a type name into a <see cref = "T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
            <param name = "typeName">The type name.</param>
            <returns>A <see cref = "T:PostSharp.Aspects.TypeIdentity" /> wrapping the type name.</returns>
        </member>
        <member name="M:PostSharp.Aspects.TypeIdentity.FromTypeNames(System.String[])">
            <summary>
              Wraps an array of type names into an array of <see cref = "T:PostSharp.Aspects.TypeIdentity" />.
            </summary>
            <param name = "typeNames">An array of type names.</param>
            <returns>An array of <see cref = "T:PostSharp.Aspects.TypeIdentity" /> wrapping <paramref name = "typeNames" />.</returns>
        </member>
        <member name="P:PostSharp.Aspects.TypeIdentity.TypeName">
            <summary>
              Gets the wrapped type name, or <c>null</c> it the <see cref = "P:PostSharp.Aspects.TypeIdentity.Type" /> property is set.
            </summary>
        </member>
        <member name="T:PostSharp.Aspects.TypeLevelAspect">
            <summary>
            Base class for all aspects applied on types.
            </summary>
            <seealso cref="T:PostSharp.Aspects.ITypeLevelAspect" />
            <remarks>
            <note>
      This class does not provide any advice. You may derive your aspect class from a
      <see href="@simple-aspects" target="_self">
        class providing
        predefined advice
      </see>
      , or build a
      <see href="@complex-aspects" target="_self">composite aspect</see>
      .
    </note><seealso href="@simple-aspects#AspectClasses" target="_self">
      Conceptual: Aspect Classes
    </seealso><seealso href="@complex-aspects" target="_self">
      Conceptual: Developing Complex Aspects
    </seealso>
            <br />
            <para>
      <note>
        All classes implementing
        <see cref="T:PostSharp.Aspects.IAspect" />
        should typically be marked as serializable
        using the 
        <see cref="T:System.SerializableAttribute" /> or <see cref="T:PostSharp.Serialization.PSerializableAttribute" /> custom attribute
        . Fields that
        are only used at runtime (and unknown at compile-time) should be carefully
        marked with the <see cref="T:System.NonSerializedAttribute" /> or <see cref="T:PostSharp.Serialization.PNonSerializedAttribute" /> custom attribute.
        When PostSharp is used on a platform that does not support aspect serialization
        (such as .NET Compact Framework, Silverlight, or Windows Phone), or when
        another aspect serializer is used, it is not necessary to mark the aspect
        class as serializable.
        For more information, see
        <see href="@aspect-serialization">Aspect Serialization</see>
        .
      </note>
    </para><seealso href="@aspect-serialization">
      Conceptual: Aspect Serialization
    </seealso>
            </remarks>
        </member>
        <member name="M:PostSharp.Aspects.TypeLevelAspect.CompileTimeValidate(System.Type)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to the right target.
            </summary>
            <param name="type">Type to which the aspect has been applied</param>
            <returns><c>true</c> if the aspect was applied to an acceptable field, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message (see 
              <see cref="T:PostSharp.Extensibility.MessageSource" />) or an exception in case of error. Returning <c>false</c> without emitting an
              error message or exception causes the aspect to be silently ignored.
            </remarks>
            <seealso href="@aspect-validation" target="_self">
      Conceptual: Validating Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.TypeLevelAspect.CompileTimeValidate(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.TypeLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Type)">
            <summary>
              Method invoked at build time to set up an <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> object according to the current 
              <see cref="T:PostSharp.Aspects.Aspect" /> instance and a specified target element of the current aspect.
            </summary>
            <param name="aspectConfiguration">The <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" /> instance previously returned  by the
              <see cref="M:PostSharp.Aspects.Aspect.CreateAspectConfiguration" /> method.</param>
            <param name="targetType">Type to which the current aspect has been applied.</param>
            <remarks>
              <para>Classes overriding this method must always invoke the base implementation before performing their own
                changes to the 
                <see cref="T:PostSharp.Aspects.Configuration.AspectConfiguration" />.</para>
            </remarks>
            <seealso href="@aspect-configuration" target="_self">
      Conceptual: Configuring Aspects
    </seealso>
        </member>
        <member name="M:PostSharp.Aspects.TypeLevelAspect.SetAspectConfiguration(PostSharp.Aspects.Configuration.AspectConfiguration,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.TypeLevelAspect.CompileTimeInitialize(System.Type,PostSharp.Aspects.AspectInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Aspects.TypeLevelAspect.RuntimeInitialize(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Aspects.UnsupportedTargetAction">
            <summary>
            Enumerates actions that can be taken when an aspect is applied to a target element that is not currently supported.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.UnsupportedTargetAction.Default">
            <summary>
            Same as <see cref="F:PostSharp.Aspects.UnsupportedTargetAction.Fail"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.UnsupportedTargetAction.Fail">
            <summary>
            Emit a build-time error when the target declaration is not supported by the aspect. This is the default behavior.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.UnsupportedTargetAction.Ignore">
            <summary>
            Do not apply the advice when the target declaration is not supported but do not emit a build error.
            </summary>
        </member>
        <member name="F:PostSharp.Aspects.UnsupportedTargetAction.Fallback">
            <summary>
            Fall back to a supported advising strategy if any is available, e.g. from semantic advising (taking into account async semantics) to non-semantic advising.
            If no fallback is available, emit a build-time error.
            </summary>
        </member>
        <member name="T:PostSharp.BoolWithDefault">
            <summary>
              Boolean with a "default" value. For use in design-time configurable boolean properties.
            </summary>
        </member>
        <member name="F:PostSharp.BoolWithDefault.Default">
            <summary>
              Indicates that the value has not been set.
            </summary>
        </member>
        <member name="F:PostSharp.BoolWithDefault.True">
            <summary>
              Indicates that the value has been set to <c>true</c>.
            </summary>
        </member>
        <member name="F:PostSharp.BoolWithDefault.False">
            <summary>
              Indicates that the value has been set to <c>false</c>.
            </summary>
        </member>
        <member name="T:PostSharp.Collections.ILinkedListNode`1">
            <summary>
            Represents a node in a double-linked list.
            </summary>
            <typeparam name="T">Type of values stored in the list.</typeparam>
        </member>
        <member name="P:PostSharp.Collections.ILinkedListNode`1.Value">
            <summary>
            Gets the value stored in the current node.
            </summary>
        </member>
        <member name="P:PostSharp.Collections.ILinkedListNode`1.Previous">
            <summary>
            Gets the previous node in the list, or <c>null</c> if the current node is the first one in the list.
            </summary>
        </member>
        <member name="P:PostSharp.Collections.ILinkedListNode`1.Next">
            <summary>
            Gets the next node in the list, or <c>null</c> if the current node is the last one in the list.
            </summary>
        </member>
        <member name="T:PostSharp.Collections.IReadOnlyLinkedList`1">
            <summary>
            Represents a double linked list.
            </summary>
            <typeparam name="T">Type of values stored in the link list.</typeparam>
            <seealso cref="T:PostSharp.Collections.LinkedListExtensions"/>
        </member>
        <member name="P:PostSharp.Collections.IReadOnlyLinkedList`1.First">
            <summary>
            Gets the first node in the list, or <c>null</c> if the list is empty.
            </summary>
        </member>
        <member name="P:PostSharp.Collections.IReadOnlyLinkedList`1.Last">
            <summary>
            Gets the last node in the list, or <c>null</c> if the list is empty.
            </summary>
        </member>
        <member name="P:PostSharp.Collections.IReadOnlyLinkedList`1.IsEmpty">
            <summary>
            Determines whether the list is empty.
            </summary>
        </member>
        <member name="T:PostSharp.Collections.ISinglyLinkedListNode`1">
            <summary>
            Represents a node in a singly linked list.
            </summary>
            <typeparam name="T">Type of values stored in the list.</typeparam>
        </member>
        <member name="P:PostSharp.Collections.ISinglyLinkedListNode`1.Value">
            <summary>
            Gets the value stored in the current node.
            </summary>
        </member>
        <member name="P:PostSharp.Collections.ISinglyLinkedListNode`1.Next">
            <summary>
            Gets the next node in the list, or <c>null</c> if the current node is the last one in the list.
            </summary>
        </member>
        <member name="T:PostSharp.Collections.LinkedListExtensions">
            <summary>
            Extensions to the <see cref="T:PostSharp.Collections.IReadOnlyLinkedList`1"/> interface.
            </summary>
        </member>
        <member name="M:PostSharp.Collections.LinkedListExtensions.ToEnumerable``1(PostSharp.Collections.IReadOnlyLinkedList{``0})">
            <summary>
            Transforms an <see cref="T:PostSharp.Collections.IReadOnlyLinkedList`1"/> into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="linkedList">A <see cref="T:PostSharp.Collections.IReadOnlyLinkedList`1"/>, or <c>null</c>.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that can enumerate all elements in <paramref name="linkedList"/>.
            If <paramref name="linkedList"/> is <c>null</c>, an empty enumerable is returned.
             </returns>
        </member>
        <member name="M:PostSharp.Collections.LinkedListExtensions.ToEnumerable``1(PostSharp.Collections.ReadOnlyLinkedList{``0})">
            <summary>
            Transforms a <see cref="T:PostSharp.Collections.ReadOnlyLinkedList`1"/> into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="linkedList">An <see cref="T:PostSharp.Collections.ReadOnlyLinkedList`1"/>.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that can enumerate all elements in <paramref name="linkedList"/>.
            If <paramref name="linkedList"/> is <c>null</c>, an empty enumerable is returned.
             </returns>
        </member>
        <member name="T:PostSharp.Collections.ReadOnlyLinkedList`1">
            <summary>
            A value-type implementation of the <see cref="T:PostSharp.Collections.IReadOnlyLinkedList`1"/> interface.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:PostSharp.Collections.ReadOnlyLinkedList`1.First">
            <inherit/>
        </member>
        <member name="P:PostSharp.Collections.ReadOnlyLinkedList`1.Last">
            <inherit/>
        </member>
        <member name="P:PostSharp.Collections.ReadOnlyLinkedList`1.IsEmpty">
            <inherit/>
        </member>
        <member name="T:PostSharp.Collections.ReadOnlySinglyLinkedList`1">
            <summary>
            Represents a singly-linked list. 
            </summary>
            <typeparam name="T">Type of values stored in the list.</typeparam>
        </member>
        <member name="P:PostSharp.Collections.ReadOnlySinglyLinkedList`1.FirstNode">
            <summary>
            Gets the first node of the list.
            </summary>
        </member>
        <member name="P:PostSharp.Collections.ReadOnlySinglyLinkedList`1.IsEmpty">
            <summary>
            Determines whether the list is empty.
            </summary>
        </member>
        <member name="M:PostSharp.Collections.ReadOnlySinglyLinkedList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Collections.ReadOnlySinglyLinkedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Collections.ReadOnlySinglyLinkedList`1.GetEnumerator">
            <summary>
            Gets a value-type enumerator.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="T:PostSharp.Collections.ReadOnlySinglyLinkedList`1.Enumerator">
            <summary>
            An enumerator allowing to enumerate a <see cref="T:PostSharp.Collections.ReadOnlySinglyLinkedList`1"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Collections.ReadOnlySinglyLinkedList`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Collections.ReadOnlySinglyLinkedList`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Collections.ReadOnlySinglyLinkedList`1.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Collections.ReadOnlySinglyLinkedList`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Collections.ReadOnlySinglyLinkedList`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.ComponentInternalAttribute">
            <summary>
            <see cref="T:PostSharp.Constraints.ReferentialConstraint"/> that, when applied on a declaration, limits the scope (namespace or type) in which this declaration 
            can be used. This constraint is useful to isolate several components from each other, even if they are implemented in
            the same assembly. The <i>ComponentInternal</i> constraint sets the visibility of a declaration between <c>internal</c> and <c>private</c>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ComponentInternalAttribute.#ctor">
            <summary>
            Initializes a <see cref="T:PostSharp.Constraints.ComponentInternalAttribute"/> restricting the target declaration from being used
            from another namespace than the namespace of the declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Constraints.ComponentInternalAttribute.Severity">
            <summary>
            Gets or sets the severity of messages emitted by this constraint.
            </summary>
            <remarks>
            <para>The default value is <see cref="F:PostSharp.Extensibility.SeverityType.Warning"/>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ComponentInternalAttribute.#ctor(System.Type[])">
            <summary>
            Initializes a <see cref="T:PostSharp.Constraints.ComponentInternalAttribute"/> restricting the target declaration from being used
            outside of given types or namespaces, given as <see cref="T:System.Type"/>.
            </summary>
            <param name="friendTypes">List of types from which the target declaration can be used. If the name of a
            type is <c>NamespaceType</c>, the whole namespace of this type is allowed.</param>
        </member>
        <member name="M:PostSharp.Constraints.ComponentInternalAttribute.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:PostSharp.Constraints.ComponentInternalAttribute"/> restricting the target declaration from being used
            outside of given types or namespaces, given by strings.
            </summary>
            <param name="friendNamespaces">List of types or namespaces from which the target declaration
            can be used.</param>
        </member>
        <member name="M:PostSharp.Constraints.ComponentInternalAttribute.ValidateReference(PostSharp.Reflection.ICodeReference)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.Constraint">
            <summary>
            Root class for all constraints based on <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>.
            A constraint is a piece validation logic executed at build time. Constraints
            are applied to elements of code ((<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>,
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>,
            <see cref="T:System.Reflection.EventInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.ParameterInfo"/>)
            typically using multicast custom attributes, and verified
            at build time for every assembly using this element of code.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.Constraint.ValidateConstraint(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.ExperimentalAttribute">
            <summary>
            Custom attribute that, when applied on a declaration, causes PostSharp to emit a warning if the declaration is being used.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ExperimentalAttribute.ValidateCode(System.Object,System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.IConstraint">
            <summary>
            A constraint is a piece of validation logic executed at build time. Constraints
            are applied to elements of code (<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>,
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>,
            <see cref="T:System.Reflection.EventInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.ParameterInfo"/>),
            typically (but not necessarily) using custom attributes or <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.IConstraint.ValidateConstraint(System.Object)">
            <summary>
            Validates the fact that the constraint has been applied on a valid element of code. When this
            method returns <c>false</c>, the constraint is silently ignored.
            </summary>
            <param name="target"></param>
            <returns><c>true</c> if the constraint has been applied on a valid element of code, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:PostSharp.Constraints.InternalAttribute">
            <summary>
            <see cref="T:PostSharp.Constraints.ReferentialConstraint"/>, when applied to a declaration, prevents it to be used from a different assembly. 
            This constraint can be used when a declaration must be made public for technical reasons, but its author does
            not want it to be used in external code.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.InternalAttribute.#ctor">
            <summary>
            Initializes a new <see cref="T:PostSharp.Constraints.InternalAttribute"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Constraints.InternalAttribute.ValidateConstraint(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Constraints.InternalAttribute.Severity">
            <summary>
            Gets or sets the severity of messages emitted by this constraint.
            </summary>
            <remarks>
            <para>The default value is <see cref="F:PostSharp.Extensibility.SeverityType.Warning"/>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.InternalAttribute.ValidateCode(System.Object,System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.InternalImplementAttribute">
            <summary>
            <see cref="T:PostSharp.Constraints.ReferentialConstraint"/> that, when applied on an interface, prevents it to be implemented
            in a different assembly. This constraint should be used when the author of an interface
            does not expect users to implement the interface and wants to reserve the possibility
            to add new methods to the interface.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.InternalImplementAttribute.#ctor">
            <summary>
            Initializes a new <see cref="T:PostSharp.Constraints.InternalImplementAttribute"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Constraints.InternalImplementAttribute.Severity">
            <summary>
            Gets or sets the severity of messages emitted by this constraint.
            </summary>
            <remarks>
            <para>The default value is <see cref="F:PostSharp.Extensibility.SeverityType.Warning"/>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.InternalImplementAttribute.ValidateCode(System.Object,System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.Internals.HasConstraintAttribute">
            <exclude />
        </member>
        <member name="T:PostSharp.Constraints.IReferentialConstraint">
            <summary>
            A referential constraint is a piece validation logic executed at build time. Referential constraints
            are applied to elements of code ((<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>,
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>,
            <see cref="T:System.Reflection.EventInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.ParameterInfo"/>),
            typically using custom attributes or <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>, and verified
            at build time for every assembly using this element of code. This is a difference to scalar constraints,
            which are only verified for the assembly where that element of code is defined.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.IReferentialConstraint.ValidateCode(System.Object,System.Reflection.Assembly)">
            <summary>
            Validates the constraint.
            </summary>
            <param name="target">Declaration (<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>,
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>,
            <see cref="T:System.Reflection.EventInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.ParameterInfo"/>) to which
            the constraint has been applied.</param>
            <param name="assembly">The assembly being currently processed.</param>
        </member>
        <member name="T:PostSharp.Constraints.IScalarConstraint">
            <summary>
            A constraint that validates a specific element of code. Use an <see cref="T:PostSharp.Constraints.IReferentialConstraint"/>
            to validate relationships between elements of code.
            </summary>
            <remarks>
            </remarks>
            <seealso cref="T:PostSharp.Constraints.ScalarConstraint"/>
        </member>
        <member name="M:PostSharp.Constraints.IScalarConstraint.ValidateCode(System.Object)">
            <summary>
            Validates the element of code to which the constraint is applied.
            </summary>
            <param name="target">Element of code to which the constraint is applied (<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>,
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>,
            <see cref="T:System.Reflection.EventInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.ParameterInfo"/>).</param>
        </member>
        <member name="T:PostSharp.Constraints.NamingConventionAttribute">
            <summary>
            Custom attribute that, when applied to a target class or an interface, validates that classes and interfaces derived from this target class or interface
            respect a giving naming convention, i.e. that their names matches a given pattern.
            </summary>
        </member>
        <member name="M:PostSharp.Constraints.NamingConventionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Constraints.NamingConventionAttribute"/>.
            </summary>
            <param name="pattern">A wildcard pattern containing a <code>*</code>, or, if the parameter starts with the <code>regex:</code> prefix, a regular expression.</param>
        </member>
        <member name="P:PostSharp.Constraints.NamingConventionAttribute.Severity">
            <summary>
            Gets or sets the severity of messages reporting violations of the current naming convention.
            </summary>
        </member>
        <member name="M:PostSharp.Constraints.NamingConventionAttribute.ValidateConstraint(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Constraints.NamingConventionAttribute.ValidateCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.ParameterValueConstraint">
            <summary>
            Base class to create architecture constraints that validate the value passed to a method parameter.
            </summary>
        </member>
        <member name="M:PostSharp.Constraints.ParameterValueConstraint.ValidateConstraint(System.Object)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Constraints.ParameterValueConstraint.ValidateTargetParameter(System.Reflection.ParameterInfo)">
            <summary>
            Validates the parameter to which the current constraint has been applied. A typical use of this method is to validate the parameter type.
            Overriding implementations should call the base implementation.
            </summary>
            <param name="parameter">The parameter to which the custom attribute has been applied.</param>
            <returns><c>true</c> if the current constraint can legally be applied to <paramref name="parameter"/>, <c>false</c> otherwise. No error message is emitted if
            the method returns <c>false</c>. The method should emit its own error message.</returns>
        </member>
        <member name="M:PostSharp.Constraints.ParameterValueConstraint.ValidateCode(System.Object,System.Reflection.Assembly)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Constraints.ParameterValueConstraint.ValidateParameterValue(System.Reflection.ParameterInfo,PostSharp.Reflection.MethodBody.IExpression)">
            <summary>
            Validates the value passed to the parameter.
            </summary>
            <param name="parameter">The parameter to which the current constraint has been applied.</param>
            <param name="expression">The expression passed to the parameter.</param>
        </member>
        <member name="T:PostSharp.Constraints.ProtectedAttribute">
            <summary>
            Custom attribute that, when applied to a target declaration, causes PostSharp to emit a warning if the declaration
            is being referenced from classes that are not derived from the target class. This constraint is similar to the
            C# keyword <c>protected</c> and should be used only when the target declaration must be made public or internal
            for non-architectural reasons.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ProtectedAttribute.#ctor">
            <summary>
            Initializes a new <see cref="T:PostSharp.Constraints.ProtectedAttribute"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Constraints.ProtectedAttribute.Severity">
            <summary>
            Gets or sets the severity of messages emitted by this constraint.
            </summary>
            <remarks>
            <para>The default value is <see cref="F:PostSharp.Extensibility.SeverityType.Warning"/>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ProtectedAttribute.ValidateConstraint(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Constraints.ProtectedAttribute.ValidateCode(System.Object,System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.ReferenceConstraint">
            <summary>
            Base class for constraints validating code references.
            </summary>
        </member>
        <member name="M:PostSharp.Constraints.ReferenceConstraint.ValidateReference(PostSharp.Reflection.ICodeReference)">
            <summary>
            Validates a reference to the target declaration of the current constraint.
            </summary>
            <param name="reference">Represents a reference to the target of the current constraint.</param>
        </member>
        <member name="M:PostSharp.Constraints.ReferenceConstraint.ValidateCode(System.Object,System.Reflection.Assembly)">
            <exclude />
        </member>
        <member name="T:PostSharp.Constraints.ReferentialConstraint">
            <summary>
            Implementation of <see cref="T:PostSharp.Constraints.IReferentialConstraint"/> based on <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ReferentialConstraint.ValidateCode(System.Object,System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Constraints.ScalarConstraint">
            <summary>
            Implementation of <see cref="T:PostSharp.Constraints.IScalarConstraint"/> based on <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Constraints.ScalarConstraint.ValidateCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Extensibility.AllowFreeInstancesAttribute">
            <exclude/>
        </member>
        <member name="M:PostSharp.Extensibility.AllowFreeInstancesAttribute.#ctor(System.String)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Extensibility.AllowFreeInstancesAttribute.#ctor(System.String,System.Int32)">
            <exclude/>
        </member>
        <member name="P:PostSharp.Extensibility.AllowFreeInstancesAttribute.FeatureName">
            <exclude/>
        </member>
        <member name="P:PostSharp.Extensibility.AllowFreeInstancesAttribute.FreeInstanceCount">
            <exclude/>
        </member>
        <member name="P:PostSharp.Extensibility.AllowFreeInstancesAttribute.ApplyToType">
            <exclude/>
        </member>
        <member name="T:PostSharp.Extensibility.AssemblyIdAttribute">
            <summary>
              Assigns a unique identifier to an assembly. This assembly identifier is used
              to generate unique attribute identifiers.
            </summary>
            <remarks>
              By default, the assembly identifier is computed from the module name
              (by using the first 4 bytes of the MD5 sum of the module name).
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.AssemblyIdAttribute.#ctor(System.Int32)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.AssemblyIdAttribute" />.
            </summary>
            <param name = "id">Assembly identifier.</param>
        </member>
        <member name="P:PostSharp.Extensibility.AssemblyIdAttribute.AssemblyId">
            <summary>
            Gets the assembly id.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.BindingContext">
            <summary>
            Enumeration of contexts in which assemblies can be loaded.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.BindingContext.None">
            <summary>
            Unspecified.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.BindingContext.Reference">
            <summary>
            Reference assemblies the ones the project is being linked against. They are typically located
            in directory <c>C:\Program Files\Reference Assemblies</c> for the proper target platform.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.BindingContext.Runtime">
            <summary>
            Runtime assemblies are the ones loaded at build time in the CLR. They are typically located
            in GAC.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity">
            <summary>
            Value returned by the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity(System.String)"/> method that should
            be disposed to mark the end of the activity and decrease the indentation level.
            </summary>
            <remarks>
            <para>Only the value returned by <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity(System.String)"/> method results in the indentation level
            to be decreased upon when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity.Dispose"/> method is invoked. Calling the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity.Dispose"/> method on the default instance has no effect.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity.Dispose">
            <summary>
            When the current <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/> has been returned by the  <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity(System.String)"/> method,
            decreases the indentation level.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger">
            <summary>
             Allows to emit build-time log records. Use the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.GetInstance(System.String)"/> method
             and then invoke <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> or <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity(System.String)"/> using the <c>?.</c>
             operator.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)">
            <summary>
              Writes a preformatted log message.
            </summary>
            <param name = "message">Message.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String,System.Object[])">
            <summary>
            Writes a log message and specifies the formatting string and an array of parameters.
            </summary>
            <param name="message">Message formatting string.</param>
            <param name="args">Formatting string arguments.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write(System.String)">
            <summary>
              Appends a preformatted string to the next message. The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "message">Message.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write(System.String,System.Object[])">
            <summary>
              Appends a string to the next message and formats it using a formatting string and an array of parameters. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "message">Message formatting string.</param>
            <param name="args">Formatting string arguments.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity(System.String)">
            <summary>
            Writes a preformatted message and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="message">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.GetInstance(System.String)">
            <summary>
            Gets a <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger"/> for a given category, or <c>null</c> if
            logging is not enabled for this category. 
            </summary>
            <param name="category">The name of the category.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger"/> for the <paramref name="category"/> if logging
            is enabled for the <paramref name="category"/>, otherwise <c>null</c>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Initialize(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger"/> facility.
            </summary>
            <param name="enabledCategories">The set of enabled categories. This set cannot be changed after initialization.</param>
        </member>
        <member name="P:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.IsInitialized">
            <summary>
            Determines whether the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Initialize(System.Collections.Generic.IEnumerable{System.String})"/> method has already been invoked.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``1(System.String,``0)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 1 argument. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``1(System.String,``0)">
            <summary>
              Writes a message given a formatting string and 1 argument. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``1(System.String,``0)">
            <summary>
            Writes a message given a formatting string and 1 argument, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``2(System.String,``0,``1)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 2 arguments. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``2(System.String,``0,``1)">
            <summary>
              Writes a message given a formatting string and 2 arguments. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``2(System.String,``0,``1)">
            <summary>
            Writes a message given a formatting string and 2 arguments, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``3(System.String,``0,``1,``2)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 3 arguments. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``3(System.String,``0,``1,``2)">
            <summary>
              Writes a message given a formatting string and 3 arguments. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``3(System.String,``0,``1,``2)">
            <summary>
            Writes a message given a formatting string and 3 arguments, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``4(System.String,``0,``1,``2,``3)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 4 arguments. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``4(System.String,``0,``1,``2,``3)">
            <summary>
              Writes a message given a formatting string and 4 arguments. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``4(System.String,``0,``1,``2,``3)">
            <summary>
            Writes a message given a formatting string and 4 arguments, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``5(System.String,``0,``1,``2,``3,``4)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 5 arguments. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``5(System.String,``0,``1,``2,``3,``4)">
            <summary>
              Writes a message given a formatting string and 5 arguments. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``5(System.String,``0,``1,``2,``3,``4)">
            <summary>
            Writes a message given a formatting string and 5 arguments, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``6(System.String,``0,``1,``2,``3,``4,``5)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 6 arguments. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
            <typeparam name="T6">Type of the 6-th parameter.</typeparam>
            <param name="arg6">Value of the 6-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``6(System.String,``0,``1,``2,``3,``4,``5)">
            <summary>
              Writes a message given a formatting string and 6 arguments. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
            <typeparam name="T6">Type of the 6-th parameter.</typeparam>
            <param name="arg6">Value of the 6-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``6(System.String,``0,``1,``2,``3,``4,``5)">
            <summary>
            Writes a message given a formatting string and 6 arguments, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
            <typeparam name="T6">Type of the 6-th parameter.</typeparam>
            <param name="arg6">Value of the 6-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Write``7(System.String,``0,``1,``2,``3,``4,``5,``6)">
            <summary>
              Appends a string to the next message and formats it using a formatting string and 7 arguments. 
              The message is sent and flushed when the <see cref="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine(System.String)"/> method is invoked.
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
            <typeparam name="T6">Type of the 6-th parameter.</typeparam>
            <param name="arg6">Value of the 6-th parameter.</param>
            <typeparam name="T7">Type of the 7-th parameter.</typeparam>
            <param name="arg7">Value of the 7-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.WriteLine``7(System.String,``0,``1,``2,``3,``4,``5,``6)">
            <summary>
              Writes a message given a formatting string and 7 arguments. 
            </summary>
            <param name = "format">Message formatting string.</param>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
            <typeparam name="T6">Type of the 6-th parameter.</typeparam>
            <param name="arg6">Value of the 6-th parameter.</param>
            <typeparam name="T7">Type of the 7-th parameter.</typeparam>
            <param name="arg7">Value of the 7-th parameter.</param>
        </member>
        <member name="M:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogger.Activity``7(System.String,``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Writes a message given a formatting string and 7 arguments, and increases the indentation level. To decrease the indentation level, dispose the <see cref="T:PostSharp.Extensibility.BuildTimeLogging.BuildTimeLogActivity"/>
            returned by this method.
            </summary>
            <param name="format">Message.</param>
            <returns>An opaque object to be disposed at the end of the activity to decrease the indentation level.</returns>
            <typeparam name="T1">Type of the 1-th parameter.</typeparam>
            <param name="arg1">Value of the 1-th parameter.</param>
            <typeparam name="T2">Type of the 2-th parameter.</typeparam>
            <param name="arg2">Value of the 2-th parameter.</param>
            <typeparam name="T3">Type of the 3-th parameter.</typeparam>
            <param name="arg3">Value of the 3-th parameter.</param>
            <typeparam name="T4">Type of the 4-th parameter.</typeparam>
            <param name="arg4">Value of the 4-th parameter.</param>
            <typeparam name="T5">Type of the 5-th parameter.</typeparam>
            <param name="arg5">Value of the 5-th parameter.</param>
            <typeparam name="T6">Type of the 6-th parameter.</typeparam>
            <param name="arg6">Value of the 6-th parameter.</param>
            <typeparam name="T7">Type of the 7-th parameter.</typeparam>
            <param name="arg7">Value of the 7-th parameter.</param>
        </member>
        <member name="T:PostSharp.Extensibility.DebuggerInterop">
            <exclude/>
        </member>
        <member name="F:PostSharp.Extensibility.DebuggerInterop.NextStateMachineId">
            <exclude/>
        </member>
        <member name="F:PostSharp.Extensibility.DebuggerInterop.IsInInspectionQuery">
            <exclude/>
        </member>
        <member name="T:PostSharp.Extensibility.EscalatePostSharpMessageAttribute">
            <summary>
              Custom attribute that, when applied on an assembly, means that a given message
              should be escalated to an error during the current <c>PostSharp</c> session.
            </summary>
            <remarks>
              Errors and fatal errors cannot be disabled.
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.EscalatePostSharpMessageAttribute.#ctor(System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.EscalatePostSharpMessageAttribute" />.
            </summary>
            <param name = "messageId">Identifier of the message to be disabled.</param>
        </member>
        <member name="P:PostSharp.Extensibility.EscalatePostSharpMessageAttribute.MessageId">
            <summary>
              Gets the identifier of the message to be disabled.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.HasInheritedAttributeAttribute">
            <summary>
              <b>Internal Only.</b> Custom attribute used internally by <c>PostSharp</c> to mark
              elements having inherited custom attributes. This custom attribute should not
              be used in custom code, otherwise <c>PostSharp</c> may not work properly.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.HasInheritedAttributeAttribute.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.HasInheritedAttributeAttribute" />.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.HasInheritedAttributeAttribute.#ctor(System.Int64[])">
            <exclude />
        </member>
        <member name="T:PostSharp.Extensibility.ICompatibilityLevelService">
            <summary>
            Exposes the PostSharp version with which the current version of PostSharp should be backward compatible.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.ICompatibilityLevelService.CompatibilityLevel">
            <summary>
            Gets the PostSharp version with which the current version of PostSharp should be backward compatible.
            </summary>
            <remarks>
            <para>
            Some breaking changes may ignore this property.
            </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Extensibility.IFormattingService">
            <summary>
            Provides a service similar to <see cref="M:System.String.Format(System.String,System.Object[])"/>, but uses
            the same formatter as the one used by PostSharp for error messages. This formatter
            does a better job at formatting objects like <see cref="T:System.Type"/> or <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IFormattingService.Format(System.String,System.Object[])">
            <summary>
            Formats a string with the default <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="format">The formatting string.</param>
            <param name="arguments">Arguments.</param>
            <returns>The formatted string where parameters in <paramref name="format"/> are replaced by formatted <paramref name="arguments"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.IFormattingService.Format(System.IFormatProvider,System.String,System.Object[])">
            <summary>
            Formats a string and specifies the <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="provider">An <see cref="T:System.IFormatProvider"/>.</param>
            <param name="format">The formatting string.</param>
            <param name="arguments">Arguments.</param>
            <returns>The formatted string where parameters in <paramref name="format"/> are replaced by formatted <paramref name="arguments"/>.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IMessageDispenser">
            <summary>
            Gets a text given its key.
            </summary>
            <seealso cref="T:PostSharp.Extensibility.MessageDispenser"/>
        </member>
        <member name="M:PostSharp.Extensibility.IMessageDispenser.GetMessage(System.String)">
            <summary>
            Gets a message text given a message key.
            </summary>
            <param name="key">Message key.</param>
            <returns>The text corresponding to <paramref name="key"/>.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IMessageLocationResolver">
            <summary>
            Provides a method that returns the file and line where a declaration (such as a <see cref="T:System.Type"/> or <see cref="T:System.Reflection.MethodInfo"/>) is declared.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IMessageLocationResolver.GetMessageLocation(System.Object)">
            <summary>
             Gets the file and line where a declaration is declared.
            </summary>
            <param name="codeElement">A <see cref="T:System.Reflection.MemberInfo"/>, <see cref="T:System.Type"/>, <see cref="T:System.Reflection.ParameterInfo"/> or <see cref="T:PostSharp.Reflection.LocationInfo"/>. </param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/> describing where <paramref name="codeElement"/> is declared, or <see cref="F:PostSharp.Extensibility.MessageLocation.Unknown"/>
            if the location cannot be determined.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IMessageSink">
            <summary>
              Receives messages.
            </summary>
            <remarks>
              Use this interface instead of events for cross-domain communication.
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.IMessageSink.Write(PostSharp.Extensibility.Message)">
            <summary>
              Writes a message to the sink.
            </summary>
            <param name = "message">A message.</param>
        </member>
        <member name="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute">
            <summary>
              Custom attribute meaning that custom attributes of a given type are
              bound to the implementation, not to the semantics.
            </summary>
            <remarks>
              <para>This custom attribute influences whether instances of a given other
                custom attribute should be moved from the semantic to the implementation,
                when the semantic is detached from the implementation.
              </para>
              <para>The <see cref="T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute"/> is currently only honored 
                when you apply an interception aspect  (<see cref="T:PostSharp.Aspects.LocationInterceptionAspect"/>) to a field.
                In this case, PostSharp creates a property from the field. The property becomes the semantic
                and the field, made private, becomes the implementation.   Most custom attributes apply to semantics,
                so they are moved from the field  the property. If a custom attribute must not be moved, it should be
                marked with the <see cref = "T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute" />
                custom attribute.
              </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.ImplementationBoundAttributeAttribute.#ctor(System.Type)">
            <summary>
              Initializes the new <see cref = "T:PostSharp.Extensibility.ImplementationBoundAttributeAttribute" />.
            </summary>
            <param name = "attributeType">Type of the custom attribute that
              should not be moved from implementation to semantic.</param>
        </member>
        <member name="P:PostSharp.Extensibility.ImplementationBoundAttributeAttribute.AttributeType">
            <summary>
              Gets the type of the custom attribute that
              should not be moved from implementation to semantic.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.InvalidAnnotationException">
            <summary>
              Exception thrown at build time by implementation of <see cref = "M:PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(System.Object)" />
              when an annotation is invalid.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.InvalidAnnotationException" /> with default message.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor(System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.InvalidAnnotationException" /> and with a specified exception message.
            </summary>
            <param name = "message">Exception message</param>
        </member>
        <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.InvalidAnnotationException" /> with a specified exception message
              and inner <see cref = "T:System.Exception" />.
            </summary>
            <param name = "message">Exception message.</param>
            <param name = "inner">Inner exception.</param>
        </member>
        <member name="M:PostSharp.Extensibility.InvalidAnnotationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Deserialization constructor.
            </summary>
            <param name = "info">Info.</param>
            <param name = "context">Context.</param>
        </member>
        <member name="T:PostSharp.Extensibility.IPostSharpEnvironment">
            <summary>
              Provides information about the current <c>PostSharp</c> environment.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.IPostSharpEnvironment.CurrentProject">
            <summary>
              Gets the currently executing project.
            </summary>
            <value>
              The current project, or <c>null</c> if there is no current project.
            </value>
        </member>
        <member name="M:PostSharp.Extensibility.IPostSharpEnvironment.LoadAssemblyFromFile(System.String)">
            <summary>
              Loads an <see cref = "T:System.Reflection.Assembly" /> given its file name.
            </summary>
            <param name = "fileName">Full assembly path.</param>
            <returns>The <see cref = "T:System.Reflection.Assembly" />.</returns>
            <remarks>
              <para>
                Use this method instead of <see cref = "M:System.Reflection.Assembly.LoadFile(System.String)" />.
              </para>
              <note>
                You cannot load two assemblies with a different path and the same identity (strong name) into PostSharp.
              </note>
            </remarks>
        </member>
        <member name="T:PostSharp.Extensibility.IProject">
            <summary>
              Provides information about the currently executing project.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.IProject.StateStore">
            <summary>
            Gets the context of the current project that serves as a project-scoped cache.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IProject.EvaluateExpression(System.String)">
            <summary>
              Evaluates an expression (that is, replace parameters by their actual value).
            </summary>
            <param name = "expression">An expression.</param>
            <returns>The evaluated expression, or <c>null</c> if one parameter could not be
              resolved.</returns>
        </member>
        <member name="P:PostSharp.Extensibility.IProject.TargetAssembly">
            <summary>
              Gets the assembly that is being transformed by PostSharp.
            </summary>
            <returns>The assembly being processed.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.IProject.GetService``1(System.Boolean)">
            <summary>
            Gets a build-time service exposed by PostSharp.
            </summary>
            <typeparam name="T">An interface derived from <see cref="T:PostSharp.Extensibility.IService"/>.</typeparam>
            <param name="throwing"><c>true</c> whether an exception should be thrown in case the service cannot be acquired, otherwise <c>false</c>.
            The default value is <c>true</c>.</param>
            <returns>The service <typeparamref name="T"/>, or <c>null</c> if the service could not be acquired and <paramref name="throwing"/>
            was set to <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.IProject.GetExtensionElements(System.String,System.String)">
            <summary>
            Gets the set of project extension elements (<see cref="T:PostSharp.Extensibility.ProjectExtensionElement"/>) given their name and XML namespace.
            </summary>
            <param name="name">Local name of the project extension element.</param>
            <param name="ns">XML namespace of the project extension element.</param>
            <returns>The set of project elements named <paramref name="name"/> in all loaded projects.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IReflectionBindingManagerService">
            <summary>
            Exposes the <see cref="M:PostSharp.Extensibility.IReflectionBindingManagerService.ResolveAssembly(System.Type)"/> method, which gets the reference identity of
            the assembly declaring a given type.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IReflectionBindingManagerService.ResolveAssembly(System.Type)">
            <summary>
            Returns the reference identity of the assembly declaring a type.
            </summary>
            <param name="type">A <see cref="T:System.Type"/>.</param>
            <returns>The identity of the reference assembly defining <see cref="T:System.Type"/>. This assembly is possibly
            different than the runtime assembly, which is available from the <see cref="P:System.Type.Assembly"/> property
            of the <see cref="T:System.Type"/> class. This method may return <c>null</c> if <paramref name="type"/> is
            an internal type of a system assembly.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IService">
            <summary>
            A service exposed by the build-time part of PostSharp.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.IServiceLocator">
            <summary>
            Exposes build-time services.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IServiceLocator.GetService``1(System.Boolean)">
            <summary>
            Gets a build-time service exposed by PostSharp.
            </summary>
            <typeparam name="T">An interface derived from <see cref="T:PostSharp.Extensibility.IService"/>.</typeparam>
            <param name="throwing"><c>true</c> whether an exception should be thrown in case the service cannot be acquired, otherwise <c>false</c>.
            The default value is <c>true</c>.</param>
            <returns>The service <typeparamref name="T"/>, or <c>null</c> if the service could not be acquired and <paramref name="throwing"/>
            was set to <c>false</c>.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IStateStore">
            <summary>
            A context that provides storage for arbitrary items.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IStateStore.Get``1">
            <summary>
            Gets a value of a given type from the store.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <returns>The value whose type is <typeparamref name="T"/>, or <c>null</c> if the store
            does not contain such value.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.IStateStore.Set``1(``0)">
            <summary>
            Adds a value to the store or replace it if a value of the same type already exists.
            </summary>
            <typeparam name="T">Type of the new value.</typeparam>
            <param name="value">The new value.</param>
        </member>
        <member name="M:PostSharp.Extensibility.IStateStore.GetOrAdd``1(System.Func{``0})">
            <summary>
            Gets a value from the cache or adds it if it does not exist yet.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="getter">The delegate invoked if no value of type <typeparamref name="T"/> is
            present in the cache.</param>
            <returns>Either the value of type <typeparamref name="T"/> present in the cache,
            either the result of the <paramref name="getter"/> delegate.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.IStateStore.GetOrNew``1">
            <summary>
            Gets a value from the cache or adds a default value if it does not exist yet.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <returns>Either the value of type <typeparamref name="T"/> present in the cache,
            either a new object of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.IValidableAnnotation">
            <summary>
              Interface that, when implemented by a custom attribute (<see cref = "T:System.Attribute" />),
              causes <c>PostSharp</c> to invoke a validation method for every instance
              of that custom attribute.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IValidableAnnotation.CompileTimeValidate(System.Object)">
            <summary>
              Method invoked at build time to ensure that the aspect has been applied to
              the right target.
            </summary>
            <param name = "target">Target element.</param>
            <returns><c>true</c> if the aspect was applied to an acceptable target, otherwise
              <c>false</c>.</returns>
            <remarks>
              The implementation of this method is expected to emit an error message
              or an exception of type <see cref = "T:PostSharp.Extensibility.InvalidAnnotationException" /> in case of error. Only returning <c>false</c> causes the aspect
              to be silently ignored.
            </remarks>
        </member>
        <member name="T:PostSharp.Extensibility.IWeavingSymbolsService">
            <summary>
            Service that allows build-time code to push annotations (both programmatic and user-visible)
            to PostSharp Tools for Visual Studio.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.IWeavingSymbolsService.PushAnnotation(System.Object,System.Type,System.String,System.String,System.Int32)">
            <summary>
            Pushes an annotation to PostSharp Tools for Visual Studio.
            </summary>
            <param name="targetDeclaration">The declaration to which the annotation relate.</param>
            <param name="annotationClass">The type of the annotation.</param>
            <param name="arguments">Arguments of the annotation.</param>
            <param name="description">A human-readable description of the annotation.</param>
            <param name="linesOfCodeAvoided">A number incrementing the number of lines of code saved on <paramref name="targetDeclaration"/>.</param>
        </member>
        <member name="T:PostSharp.Extensibility.Message">
            <summary>
              Encapsulates a message (error, warning, info, ...).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.Message.NotAvailable">
            <summary>
            When set to the <c>locationLine</c> or <c>locationColumn</c> constructor parameter or the <see cref="P:PostSharp.Extensibility.MessageLocation.StartColumn"/>,
            <see cref="P:PostSharp.Extensibility.MessageLocation.EndColumn"/>, <see cref="P:PostSharp.Extensibility.MessageLocation.StartLine"/>, <see cref="P:PostSharp.Extensibility.MessageLocation.EndLine"/>, means that the value of this property is unknown.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.Message.#ctor(PostSharp.Extensibility.MessageLocation,PostSharp.Extensibility.SeverityType,System.String,System.String,System.String,System.String,System.Exception)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.Message" /> and specifies all its properties.
            </summary>
            <param name="location">Element of code (<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>,
            <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.EventInfo"/> or <see cref="T:System.Reflection.ParameterInfo"/>)
            to which the message applies. When called from PostSharp.Sdk, the parameter can also contain a <c>MetadataDeclaration</c>.</param>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "messageText">Fully formatted message text.</param>
            <param name = "helpLink">Link to the help file page associated to this message.</param>
            <param name = "source">Name of the component emitting the message.</param>
            <param name = "innerException">The <see cref = "T:System.Exception" /> that caused this message,
              or <c>null</c> if this message was not caused by an
              exception.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.#ctor(PostSharp.Extensibility.SeverityType,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Exception)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.Message" /> and specifies all its properties.
            </summary>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "locationFile">File that caused the error, or <c>null</c> if
              the file is unknown or does not apply.</param>
            <param name = "locationLine"> Position (line) in the file that caused the error,
              or <see cref = "F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
              unknown or does not apply.</param>
            <param name = "locationColumn">Position (column) in the file that caused the error,
              or <see cref = "F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
              unknown or does not apply.</param>
            <param name = "innerException">The <see cref = "T:System.Exception" /> that caused this message,
              or <c>null</c> if this message was not caused by an
              exception.</param>
            <param name = "source">Name of the component emitting the message.</param>
            <param name = "helpLink">Link to the help file page associated to this message.</param>
            <param name = "messageText">Fully formatted message text.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.#ctor(PostSharp.Extensibility.SeverityType,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Exception)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.Message" /> and specifies all its properties.
            </summary>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "locationFile">File that caused the error, or <c>null</c> if
              the file is unknown or does not apply.</param>
            <param name = "locationStartLine">Start position (line) in the file that caused the error,
              or <see cref = "F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
              unknown or does not apply.</param>
            <param name = "locationStartColumn">Start position (column) in the file that caused the error,
              or <see cref = "F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
              unknown or does not apply.</param>
            <param name = "locationEndLine">End position (line) in the file that caused the error,
              or <see cref = "F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
              unknown or does not apply.</param>
            <param name = "locationEndColumn">End position (column) in the file that caused the error,
              or <see cref = "F:PostSharp.Extensibility.Message.NotAvailable" /> if the line is 
              unknown or does not apply.</param>
            <param name = "innerException">The <see cref = "T:System.Exception" /> that caused this message,
              or <c>null</c> if this message was not caused by an
              exception.</param>
            <param name = "source">Name of the component emitting the message.</param>
            <param name = "helpLink">Link to the help file page associated to this message.</param>
            <param name = "messageText">Fully formatted message text.</param>
        </member>
        <member name="P:PostSharp.Extensibility.Message.Severity">
            <summary>
              Gets the message severity.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.OriginalSeverity">
            <summary>
              Gets the original message severity.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.MessageId">
            <summary>
              Gets the message type identifier.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.Location">
            <summary>
            Location of the source code artifact causing the message.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.InnerException">
            <summary>
              Gets the
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.Source">
            <summary>
              Gets or sets the name of the source component.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.MessageText">
            <summary>
              Gets the message formatted text.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.Message.HelpLink">
            <summary>
              Gets the help link.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.Message.GetExceptionStackMessage(System.Exception)">
            <summary>
              Returns a string composed of the messages of
              all inner exceptions.
            </summary>
            <param name = "outerException">The outer exception.</param>
            <returns>A string composed of the messages of all
              <paramref name = "outerException" /> and all inner exceptions,
              concatenated by the string <c>--&gt;</c>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Extensibility.Message)">
            <summary>
              Writes a message by providing a <see cref = "T:PostSharp.Extensibility.Message" /> object.
            </summary>
            <param name = "message">A <see cref = "T:PostSharp.Extensibility.Message" />.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Extensibility.MessageLocation,PostSharp.Extensibility.SeverityType,System.String,System.String)">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "message">Error message.</param>
            <param name="messageLocation">Element of code (<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>,
            <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.EventInfo"/> or <see cref="T:System.Reflection.ParameterInfo"/>)
            to which the message applies. When called from PostSharp.Sdk, the parameter can also contain a <c>MetadataDeclaration</c>.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Extensibility.MessageLocation,PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "format">Error message formatting string.</param>
            <param name = "arguments">Formatting string arguments.</param>
            <param name="messageLocation">Element of code (<see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>,
            <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.EventInfo"/> or <see cref="T:System.Reflection.ParameterInfo"/>)
            to which the message applies. When called from PostSharp.Sdk, the parameter can also contain a <c>MetadataDeclaration</c>.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(System.Reflection.MemberInfo,PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "format">Error message formatting string.</param>
            <param name = "arguments">Formatting string arguments.</param>
            <param name="codeElement">Element of code to which the message applies.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(System.Type,PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "format">Error message formatting string.</param>
            <param name = "arguments">Formatting string arguments.</param>
            <param name="type">Element of code to which the message applies.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(System.Reflection.ParameterInfo,PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "format">Error message formatting string.</param>
            <param name = "arguments">Formatting string arguments.</param>
            <param name="codeElement">Element of code to which the message applies.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(System.Reflection.Assembly,PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "format">Error message formatting string.</param>
            <param name = "arguments">Formatting string arguments.</param>
            <param name="codeElement">Element of code to which the message applies.</param>
        </member>
        <member name="M:PostSharp.Extensibility.Message.Write(PostSharp.Reflection.LocationInfo,PostSharp.Extensibility.SeverityType,System.String,System.String,System.Object[])">
            <summary>
              Writes a message.
            </summary>
            <param name = "severity">Severity.</param>
            <param name = "errorCode">Error code.</param>
            <param name = "format">Error message formatting string.</param>
            <param name = "arguments">Formatting string arguments.</param>
            <param name="codeElement">Element of code to which the message applies.</param>
        </member>
        <member name="T:PostSharp.Extensibility.MessageDispenser">
            <summary>
            Provides a base implementation of <see cref="T:PostSharp.Extensibility.IMessageDispenser"/>
            where the message key is supposed to be in format <c>PRE0000</c>, where
            <c>PRE</c> is a prefix and <c>0000</c> is an integer. Keys for help URLs
            have the format <c>PRE0000?</c>.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MessageDispenser.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MessageDispenser"/>.
            </summary>
            <param name="prefix">Prefix of all messages provided by the new dispenser.</param>
        </member>
        <member name="P:PostSharp.Extensibility.MessageDispenser.Prefix">
            <summary>
            Gets the message prefix.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MessageDispenser.GetMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Extensibility.MessageDispenser.GetMessage(System.Int32)">
            <summary>
            Gets the message text of a given number.
            </summary>
            <param name="number">Message number.</param>
            <returns>The message text corresponding to <paramref name="number"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageDispenser.GetHelpUrl(System.Int32)">
            <summary>
            Gets the message help URL of a given number.
            </summary>
            <param name="number">Message number.</param>
            <returns>The message help URL corresponding to <paramref name="number"/>.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.MessageException">
            <summary>
              Exception embedding a <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MessageException.message">
            <summary>
              The <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MessageException.#ctor(PostSharp.Extensibility.Message)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.MessageException" /> from
              an existing <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
            <param name = "message">A <see cref = "T:PostSharp.Extensibility.Message" />.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Deserializes a <see cref = "T:PostSharp.Extensibility.MessageException" />.
            </summary>
            <param name = "info">Serialization information.</param>
            <param name = "context">Serialization context.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Serializes the current object.
            </summary>
            <param name = "info">Serialization information.</param>
            <param name = "context">Serialization context.</param>
        </member>
        <member name="P:PostSharp.Extensibility.MessageException.MessageObject">
            <summary>
              Gets the <see cref = "T:PostSharp.Extensibility.Message" /> em
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MessageException.GetMessageText(PostSharp.Extensibility.Message)">
            <summary>
              Gets the message text.
            </summary>
            <param name = "message">A <see cref = "T:PostSharp.Extensibility.Message" />.</param>
            <returns>The message text.</returns>
        </member>
        <member name="T:PostSharp.Extensibility.MessageLocation">
            <summary>
            Represents the location of a message, which means, for the end-user, a line in a file of source code.
            From the aspect developer, the location can be known as an object representing an element of code
            (for instance a <see cref="T:System.Type"/> or <see cref="T:System.Reflection.MethodInfo"/>). Such implicit locations are resolved
            by PostSharp to a file and line number.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MessageLocation.Unknown">
            <summary>
            Represents an unknown or indeterminate location of the error message.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from a <see cref="T:PostSharp.Reflection.SymbolSequencePoint"/>.
            </summary>
            <param name="symbolSequencePoint">A <see cref="T:PostSharp.Reflection.SymbolSequencePoint"/>.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/> corresponding to <paramref name="symbolSequencePoint"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Explicit(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> explicitly by specifying a filename, line, and column.
            </summary>
            <param name="file">File name.</param>
            <param name="lineStart">Starting line number.</param>
            <param name="columnStart">Starting column number.</param>
            <param name="lineEnd">Ending line number.</param>
            <param name="columnEnd">Ending column number.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Explicit(System.String,System.Int32,System.Int32)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> explicitly by specifying a filename, line, and column.
            </summary>
            <param name="file">File name.</param>
            <param name="line">Line number.</param>
            <param name="column">Column number.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Explicit(System.String)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> explicitly by specifying a filename, when the
            </summary>
            <param name="file">File name.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(System.Object)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from an object representing an
            element of code (<see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>,
            <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:PostSharp.Reflection.MethodBody.IExpression"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.ParameterInfo"/>, <see cref="T:System.Reflection.EventInfo"/>,
            <see cref="T:System.Reflection.PropertyInfo"/> or, if
            you are using PostSharp SDK, any <c>Declaration</c>).
            </summary>
            <param name="codeElement">an object representing an
            element of code (<see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>,
            <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.ParameterInfo"/>, <see cref="T:System.Reflection.EventInfo"/>,
            <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:PostSharp.Reflection.MethodBody.IExpression"/> or, if you are using PostSharp SDK, any <c>Declaration</c>.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/> representing <paramref name="codeElement"/>.</returns>
            <remarks>
                <para>If <paramref name="codeElement"/> is <c>null</c> or cannot mapped to a location of code,
            this method silently returns <see cref="F:PostSharp.Extensibility.MessageLocation.Unknown"/>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(System.Reflection.MemberInfo)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from a <see cref="T:System.Reflection.MemberInfo"/> (<see cref="T:System.Type"/>, 
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>,
            <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.EventInfo"/>).
            </summary>
            <param name="member">An element of code (<see cref="T:System.Type"/>, 
            <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>,
            <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.EventInfo"/>).</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(System.Reflection.ParameterInfo)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from a <see cref="T:System.Reflection.ParameterInfo"/>.
            </summary>
            <param name="parameter">A <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(PostSharp.Reflection.LocationInfo)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from a <see cref="T:PostSharp.Reflection.LocationInfo"/>.
            </summary>
            <param name="location">A <see cref="T:PostSharp.Reflection.LocationInfo"/>.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(System.Reflection.Assembly)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <param name="assembly">An <see cref="T:System.Reflection.Assembly"/> (<see cref="T:System.Reflection.Assembly"/> or its wrapper).</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageLocation.Of(PostSharp.Reflection.MethodBody.IExpression)">
            <summary>
            Builds a <see cref="T:PostSharp.Extensibility.MessageLocation"/> from an <see cref="T:PostSharp.Reflection.MethodBody.IExpression"/>.
            </summary>
            <param name="expression">An <see cref="T:PostSharp.Reflection.MethodBody.IExpression"/>.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.MessageLocation"/>.</returns>
        </member>
        <member name="P:PostSharp.Extensibility.MessageLocation.CodeElement">
            <summary>
            Element of code (reflection object or <c>Declaration</c>) from which the location must be resolved.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MessageLocation.File">
            <summary>
              Gets the name of the file that caused the message.
            </summary>
            <value>
              Absolute path to the file or <c>null</c> if the file name
              is unknown or not applicable.
            </value>
        </member>
        <member name="P:PostSharp.Extensibility.MessageLocation.StartLine">
            <summary>
              Gets the starting line in the file that caused the message.
            </summary>
            <summary>
              An integer greater or equal to 1, or 0
              if the line is unknown or does not apply.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MessageLocation.StartColumn">
            <summary>
              Gets the starting column in the file that caused the message.
            </summary>
            <summary>
              An integer greater or equal to 1, or 0
              if the column is unknown or does not apply.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MessageLocation.EndLine">
            <summary>
              Gets the ending line in the file that caused the message.
            </summary>
            <summary>
              An integer greater or equal to 1, or 0
              if the line is unknown or does not apply.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MessageLocation.EndColumn">
            <summary>
              Gets the ending column in the file that caused the
              message.
            </summary>
            <summary>
              An integer greater or equal to 1, or 0
              if the column is unknown or does not apply.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.MessageSource">
            <summary>
              Provides commodity methods to work with an <see cref = "T:PostSharp.Extensibility.IMessageSink" />.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.#ctor(System.String,System.Resources.ResourceManager)">
            <summary>
            Instantiates a <see cref="T:PostSharp.Extensibility.MessageSource"/> backed by a <see cref="T:System.Resources.ResourceManager"/>.
            </summary>
            <param name="source">Source name.</param>
            <param name="resourceManager">The <see cref="T:System.Resources.ResourceManager"/>.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.#ctor(System.String,PostSharp.Extensibility.IMessageDispenser)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.MessageSource" /> backed by a <see cref = "T:PostSharp.Extensibility.IMessageDispenser" />.
            </summary>
            <param name = "source">Name of the component emitting. the messages.</param>
            <param name = "messageDispenser">The <see cref = "T:PostSharp.Extensibility.IMessageDispenser" /> that will be used to
              retrieve message texts.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.CreateMessage(PostSharp.Extensibility.MessageLocation,PostSharp.Extensibility.SeverityType,System.String,System.Exception,System.Object[])">
            <summary>
            Creates a <see cref="T:PostSharp.Extensibility.Message"/> from the current <see cref="T:PostSharp.Extensibility.MessageSource"/>.
            </summary>
            <param name="location">Location of the source code artifact causing the message.</param>
            <param name="severity">Severity.</param>
            <param name="messageId">Message identifier (resolved by the current <see cref="T:PostSharp.Extensibility.MessageSource"/>).</param>
            <param name="innerException">Exception causing the message, or <c>null</c>.</param>
            <param name="arguments">Arguments of the message text.</param>
            <returns>A <see cref="T:PostSharp.Extensibility.Message"/>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.MessageLocation,PostSharp.Extensibility.SeverityType,System.String,System.Exception,System.Object[])">
            <summary>
              Emits a <see cref = "T:PostSharp.Extensibility.Message" /> and specifies an inner <see cref="T:System.Exception"/>.
            </summary>
            <param name="location">Location of the source code artifact that caused the message.</param>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "arguments">Array of arguments used to format the message text,
              or <c>null</c> if this message has no argument.</param>
            <param name = "innerException">The <see cref = "T:System.Exception" /> that caused this message,
              or <c>null</c> if this message was not caused by an
              exception.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.MessageLocation,PostSharp.Extensibility.SeverityType,System.String,System.Object[])">
            <summary>
              Emits a <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
            <param name="location">Location of the source code artifact that caused the message.</param>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "arguments">Array of arguments used to format the message text,
              or <c>null</c> if this message has no argument.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.Write(System.Reflection.MemberInfo,PostSharp.Extensibility.SeverityType,System.String,System.Object[])">
            <summary>
              Emits a <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
            <param name="codeElement">Source code artifact (<see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>,
            <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.EventInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>) that caused the message.</param>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "arguments">Array of arguments used to format the message text,
              or <c>null</c> if this message has no argument.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.Write(System.Reflection.ParameterInfo,PostSharp.Extensibility.SeverityType,System.String,System.Object[])">
            <summary>
              Emits a <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
            <param name="codeElement">Source code artifact that caused the message.</param>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "arguments">Array of arguments used to format the message text,
              or <c>null</c> if this message has no argument.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.Write(System.Reflection.Assembly,PostSharp.Extensibility.SeverityType,System.String,System.Object[])">
            <summary>
              Emits a <see cref = "T:PostSharp.Extensibility.Message" />.
            </summary>
            <param name="codeElement">Source code artifact that caused the message.</param>
            <param name = "severity">Message severity (fatal error, error, info, debug).</param>
            <param name = "messageId">Identifier of the message type.</param>
            <param name = "arguments">Array of arguments used to format the message text,
              or <c>null</c> if this message has no argument.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MessageSource.Write(PostSharp.Extensibility.Message)">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Extensibility.MessageSource.MessageSink">
            <summary>
              Gets the current message sink.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.MetricAttribute">
            <summary>
            Custom attribute that, when applied on an aspect, causes the aspect to increment some metric at build time.
            </summary>
            <remarks>
             These metrics are used by PostSharp to collect usage information and are transferred to the makers
            of PostSharp only if you opted in for the Customer Experience Improvement Program.
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MetricAttribute.MetricName">
            <summary>
            Gets the name of the metric.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MetricAttribute.Operand">
            <summary>
            Gets the operand of the metric.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MetricAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MetricAttribute"/>.
            </summary>
            <param name="metricName">Metric name.</param>
            <param name="operand">Metric operand.</param>
        </member>
        <member name="P:PostSharp.Extensibility.MetricAttribute.AllowImplementationMetrics">
            <summary>
            Determines whether the usage of features used by the target aspects must be instrumented.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.MulticastAttribute">
            <summary>
            Custom attribute that can be applied to multiple elements
            using wildcards.
            </summary>
            <remarks>
            <para>Each class derived from <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>
            should be decorated with an instance of <see cref="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute"/>.
            </para>
            <para>
            Note to implementors: The properties of this class that start with the word 'Attribute' only have an effect if they are
            set at the point where the attribute is used (in brackets). Setting them in the constructor of your subclass has no effect.
            </para>
            <para>
            Multicasting is performed by the <b>MulticastAttributeTask</b>, which should be
            included in the project. After multicasting, custom attribute instances are
            available on the <b>CustomAttributeDictionaryTask</b> class.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements">
            <summary>
            Gets or sets the kind of elements to which this custom attributes applies.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetAssemblies">
            <summary>
            Gets or sets the assemblies to which the current attribute apply.
            </summary>
            <value>
            Wildcard or regular expression specifying to which assemblies
            this instance applies, or <c>null</c> if this instance applies
            only to elements of the current assembly. Wildcard expressions should
            start with the <c>regex:</c> prefix.
            </value>
            <remarks>
            When this property is not specified or is <c>null</c>, the current
            attribute is multicasted only in the current assembly. Otherwise, it
            is multicasted also to external assemblies, i.e. to declarations that
            are <i>referenced</i> by the current assembly.
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetTypes">
            <summary>
            Gets or sets the expression specifying to which types
            this instance applies.
            </summary>
            <value>
            A wildcard or regular expression specifying to which types
            this instance applies, or <c>null</c> this instance
            applies either to all types. Regular expressions should
            start with the <c>regex:</c> prefix.
            </value>
            <remarks>
            <para>Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/> are only the module and/or the assembly.
            </para>
            <para>Unless you use a wildcard or a regex, you must specify the fully qualified name of the type.</para>
            <para>Nested types are delimited by a plus sign (<c>+</c>) in place of a dot (<c>.</c>).</para>
            <para>If the type is generic, add a backtick and its type arity at the end.</para>
            <para>Examples:
            <list type="bullet">
               <item>Namespace.OuterType`1+NestedType`2</item>
               <item>regex:Namespac.*Nested.*</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetTypeAttributes">
            <summary>
            Gets or sets the attributes of types to which this attribute applies. Visibility, scope (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Instance"/> or <see cref="F:PostSharp.Extensibility.MulticastAttributes.Static"/>)
              and generation are the only categories that are taken into account; attributes of other categories are ignored.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetExternalTypeAttributes">
            <summary>
            Gets or sets the visibilities of types to which this attribute applies,
            when this type is external to the current module.
            </summary>
            <remarks>
            On type-level, the only meaningful enumeration values are related to visibility.
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetMembers">
            <summary>
            Gets or sets the expression specifying to which members 
            this instance applies.
            </summary>
            <value>
            A wildcard or regular expression specifying to which members
            this instance applies, or <c>null</c> this instance
            applies either to all members whose kind is given in <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/>.
            Regular expressions should start with the <c>regex:</c> prefix.
            </value>
            <remarks>
            <para>Ignored if the only <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/> are only types.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetMemberAttributes">
            <summary>
            Gets or sets the visibilities, scopes, virtualities, and other characteristics 
             of members to which this attribute applies.
            </summary>
            <remarks>
            <para>Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/> are only the module, the assembly,
            and/or types.
            </para>
            <para>
            The <see cref="T:PostSharp.Extensibility.MulticastAttributes"/> enumeration is a multi-part flag: there is one
            part for visibility, one for scope, one for virtuality, and so on.
            If you specify one part, it will override the values defined on the custom attribute definition.
            If you do not specify it, the values defined on the custom attribute definition will be inherited.
            Note that custom attributes may apply restrictions on these attributes. For instance, 
            a custom attribute may not be valid on abstract methods. You are obviously not allowed
            to 'enlarge' the set of possible targets.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetExternalMemberAttributes">
            <summary>
            Gets or sets the visibilities, scopes, virtualities, and implementation
             of members to which this attribute applies, when the member is external to the current module.
            </summary>
            <remarks>
            <para>Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/> are only the module, the assembly,
            and/or types.
            </para>
            <para>
            The <see cref="T:PostSharp.Extensibility.MulticastAttributes"/> enumeration is a multi-part flag: there is one
            part for visibility, one for scope, one for virtuality, and one for implementation.
            If you specify one part, it will override the values defined on the custom attribute definition.
            If you do not specify it, the values defined on the custom attribute definition will be inherited.
            Note that custom attributes may apply restrictions on these attributes. For instance, 
            a custom attribute may not be valid on abstract methods. You are obviously not allowed
            to 'enlarge' the set of possible targets.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetParameters">
            <summary>
            Gets or sets the expression specifying to which parameters 
            this instance applies.
            </summary>
            <value>
            A wildcard or regular expression specifying to which parameters
            this instance applies, or <c>null</c> this instance
            applies either to all members whose kind is given in <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/>.
            Wildcard expressions should
            start with the <c>regex:</c> prefix.
            </value>
            <remarks>
            <para>Ignored if the only <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/> are only types.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetParameterAttributes">
            <summary>
            Gets or sets the passing style (by value, <b>out</b> or <b>ref</b>)
             of parameters to which this attribute applies.
            </summary>
            <remarks>
            <para>Ignored if the <see cref="P:PostSharp.Extensibility.MulticastAttribute.AttributeTargetElements"/> do not include parameters.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeExclude">
            <summary>
            If true, indicates that this attribute <i>removes</i> all other instances of the
            same attribute type from the set of elements defined by the current instance.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributePriority">
            <summary>
            Gets or sets the priority of the current attribute in case that multiple 
            instances are defined on the same element (lower values are processed before).
            </summary>
            <remarks>
            You should use only 16-bit values in user code. Top 16 bits are reserved for the system.
            
            When the multicast attribute is applied via an XML configuration file, the default value
            is set to 1-based ordinal of the attribute appearance in the XML configuration file.
            When the multicast attribute is applied in the source code, the default value is 0.
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeReplace">
            <summary>
            Determines whether this attribute replaces other attributes found on the
            target declarations.
            </summary>
            <value>
            <c>true</c> if the current instance will replace previous ones, or <c>false</c>
            if it will be added to previous instances.
            </value>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeInheritance">
            <summary>
            Determines whether this attribute is inherited
            </summary>
            <remarks>
            <para>If this property is not set to <c>MulticastInheritance.None</c>,
            a copy of this attribute will be propagated
            along the lines of inheritance of the target element:</para>
            <list type="bullet">
            <item>On <b>classes</b>: all classed derived from that class.</item>
            <item>On <b>interfaces</b>: all classes implementing this interface.</item>
            <item>On <b>virtual, abstract or interface methods</b>: all methods overriding 
            or implementing this method.</item>
            <item>On <b>parameters</b> or <b>return value</b> of virtual, abstract or interface methods:
            corresponding parameter or return value on all methods or overriding or implementing the
            parent method of the target parameter or return value.</item>
            </list>
            </remarks>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttribute.AttributeId">
            <exclude />
        </member>
        <member name="T:PostSharp.Extensibility.MulticastAttributes">
            <summary>
              Attributes of elements to which multicast custom attributes (<see cref = "T:PostSharp.Extensibility.MulticastAttribute" />)
              apply.
            </summary>
            <remarks>
            <para>
            If you specify this in a <see cref="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute"/>, then the annotated attribute can only be multicast
            to elements that have these attributes. For example, if you create an aspect and annotate it with <c>[MulticastAttributeUsage(TargetMemberAttributes=MulticastAttributes.Protected)]</c>,
            then multicasting will never apply the aspect to any type member that isn't <c>protected</c>.
            </para>
            <para>
            If you specify this in a property of <see cref="T:PostSharp.Extensibility.MulticastAttribute" />, then that specific
            multicast will be even more narrowed just to elements that have these attributes. For example, if you annotate a class with the aspect from the previous
            paragraph with <c>[MyAspect(TargetMemberAttributes=MulticastAttributes.Virtual)]</c>, then it will only apply to that class's members that are both
            protected and, for methods, virtual.
            </para>
            <para>
            There are 8 categories of flags. If you specify at least one flag for a category, you narrow the multicast just to elements
            that have one of the flags you specified in the category. For example, if you specify <c>Public | Protected</c>, you multicast
            to elements that are public or protected, but not private. Their other attributes (such as whether they are instance or static) do not matter. 
            </para>
            <para>
            The categories are visibility (public, private, ...); scope (static or instance); abstraction (abstract or non-abstract); virtuality (virtual
            or non-virtual); implementation (managed or unmanaged); literality (literal or nonliteral); generation (compiler-generated or user-created); and
            parameter (in, ref, or out).
            </para>
            <para>
            If a category doesn't make sense for an element, then specifying its flags will have no effect for that element. For example, if you narrow
            your multicast down to virtual elements, it will still apply to fields or types (which can't be virtual). 
            </para>
            </remarks>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Default">
            <summary>
              Specifies that the set of target attributes is inherited from
              the parent custom attribute.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Private">
            <summary>
              Private (visible inside the current type).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Protected">
            <summary>
              Protected (visible inside derived types).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Internal">
            <summary>
              Internal (visible inside the current assembly).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.InternalAndProtected">
            <summary>
              Internal <i>and</i> protected (visible inside derived types that are defined in the current assembly).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.InternalOrProtected">
            <summary>
              Internal <i>or</i> protected (visible inside all derived types and in the current assembly).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Public">
            <summary>
              Public (visible everywhere).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyVisibility">
            <summary>
              Any visibility.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Static">
            <summary>
              Static scope.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Instance">
            <summary>
              Instance scope.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyScope">
            <summary>
              Any scope (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.Static" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.Instance" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Abstract">
            <summary>
              Abstract methods.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.NonAbstract">
            <summary>
              Concrete (non-abstract) methods.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyAbstraction">
            <summary>
              Any abstraction (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.Abstract" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.NonAbstract" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Virtual">
            <summary>
              Virtual methods.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.NonVirtual">
            <summary>
              Non-virtual methods.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyVirtuality">
            <summary>
              Any virtuality (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.Virtual" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.NonVirtual" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Managed">
            <summary>
              Managed code implementation.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.NonManaged">
            <summary>
              Non-managed code implementation (external or system).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyImplementation">
            <summary>
              Any implementation (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.Managed" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.NonManaged" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.Literal">
            <summary>
              Literal fields.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.NonLiteral">
            <summary>
              Non-literal fields.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyLiterality">
            <summary>
              Any field literality (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.Literal" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.NonLiteral" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.InParameter">
            <summary>
              Input parameters.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.CompilerGenerated">
            <summary>
              Compiler-generated code.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.UserGenerated">
            <summary>
              User-generated code (anything expected <see cref = "F:PostSharp.Extensibility.MulticastAttributes.CompilerGenerated" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyGeneration">
            <summary>
              Any code generation (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.CompilerGenerated" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.UserGenerated" />)l
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.OutParameter">
            <summary>
              Output (<b>out</b> in C#) parameters.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.RefParameter">
            <summary>
              Input/Output (<b>ref</b> in C#) parameters.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.AnyParameter">
            <summary>
              Any kind of parameter passing (<see cref = "F:PostSharp.Extensibility.MulticastAttributes.InParameter" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.OutParameter" /> | <see cref = "F:PostSharp.Extensibility.MulticastAttributes.RefParameter" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributes.All">
            <summary>
              All members.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute">
            <summary>
              Custom attribute that determines the usage of a <see cref = "T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastAttributeUsageAttribute.validOn">
            <summary>
              Kinds of targets that instances of the related <see cref = "T:PostSharp.Extensibility.MulticastAttribute" />
              apply to.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.MulticastAttributeUsageAttribute.#ctor(PostSharp.Extensibility.MulticastTargets)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.MulticastAttributeUsageAttribute" />.
            </summary>
            <param name = "validOn">Kinds of targets that instances of the related <see cref = "T:PostSharp.Extensibility.MulticastAttribute" />
              apply to.</param>
        </member>
        <member name="M:PostSharp.Extensibility.MulticastAttributeUsageAttribute.#ctor">
            <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.MulticastAttributeUsageAttribute"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.ValidOn">
            <summary>
              Gets the kinds of targets that instances of the related <see cref = "T:PostSharp.Extensibility.MulticastAttribute" />
              apply to.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.AllowMultiple">
            <summary>
              Determines whether many instances of the custom attribute are allowed on a single declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.Inheritance">
            <summary>
              Determines whether the custom attribute in inherited along the lines of inheritance
              of the target element.
            </summary>
            <seealso cref = "P:PostSharp.Extensibility.MulticastAttribute.AttributeInheritance" />
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.AllowExternalAssemblies">
            <summary>
              Determines whether this attribute can be applied to declaration of external assemblies
              (i.e. to other assemblies than the one in which the custom attribute is instantiated).
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.PersistMetaData">
            <summary>
              Determines whether the custom attribute should be persisted in metadata, so that
              it would be available for <c>System.Reflection</c>.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetMemberAttributes">
            <summary>
              Gets or sets the attributes of the members (fields or methods) to which
              the custom attribute can be applied.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetExternalMemberAttributes">
            <summary>
              Gets or sets the attributes of the members (fields or methods) to which
              the custom attribute can be applied, when the members are external to
              the current module.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetParameterAttributes">
            <summary>
              Gets or sets the attributes of the parameter to which
              the custom attribute can be applied.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetTypeAttributes">
            <summary>
              Gets or sets the attributes of the types to which
              the custom attribute can be applied. Visibility, scope (<see cref="F:PostSharp.Extensibility.MulticastAttributes.Instance"/> or <see cref="F:PostSharp.Extensibility.MulticastAttributes.Static"/>)
              and generation are the only categories that are taken into account; attributes of other categories are ignored. If the custom attribute relates to
              fields or methods, this property specifies which attributes of the declaring type are acceptable.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastAttributeUsageAttribute.TargetExternalTypeAttributes">
            <summary>
              Gets or sets the attributes of the types to which
              the custom attribute can be applied, when the type is external to
              the current module. If the custom attribute relates to
              fields or methods, this property specifies which attributes
              of the declaring type are acceptable.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.MulticastImplementationDetailsTypeAttribute">
            <exclude/>
        </member>
        <member name="M:PostSharp.Extensibility.MulticastImplementationDetailsTypeAttribute.#ctor(System.Type)">
            <exclude/>
        </member>
        <member name="P:PostSharp.Extensibility.MulticastImplementationDetailsTypeAttribute.MulticastImplementationDetailsType">
            <exclude/>
        </member>
        <member name="T:PostSharp.Extensibility.MulticastInheritance">
            <summary>
              Kind of inheritance of <see cref = "T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastInheritance.None">
            <summary>
              No inheritance.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastInheritance.Strict">
            <summary>
              The instance is inherited to children of the original element,
              but multicasting is not applied to members of children.
            </summary>
            <remarks>
              See https://doc.postsharp.net/multicast-inheritance.
            </remarks>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastInheritance.Multicast">
            <summary>
              The instance is inherited to children of the original element
              and multicasting is applied to members of children.
            </summary>
            <remarks>
              See https://doc.postsharp.net/multicast-inheritance.
            </remarks>
        </member>
        <member name="T:PostSharp.Extensibility.MulticastTargets">
            <summary>
              Kinds of targets to which multicast custom attributes (<see cref = "T:PostSharp.Extensibility.MulticastAttribute" />)
              can apply.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Default">
            <summary>
              Specifies that the set of target elements is inherited from
              the parent custom attribute.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Class">
            <summary>
              Class.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Struct">
            <summary>
              Structure.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Enum">
            <summary>
              Enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Delegate">
            <summary>
              Delegate.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Interface">
            <summary>
              Interface.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.AnyType">
            <summary>
              Any type (<see cref = "F:PostSharp.Extensibility.MulticastTargets.Class" />, <see cref = "F:PostSharp.Extensibility.MulticastTargets.Struct" />, <see cref = "F:PostSharp.Extensibility.MulticastTargets.Enum" />,
              <see cref = "F:PostSharp.Extensibility.MulticastTargets.Delegate" /> or <see cref = "F:PostSharp.Extensibility.MulticastTargets.Interface" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Field">
            <summary>
              Field.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Method">
            <summary>
              Method (but not constructor).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.InstanceConstructor">
            <summary>
              Instance constructor.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.StaticConstructor">
            <summary>
              Static constructor.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Property">
            <summary>
              Property (but not methods inside the property).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Event">
            <summary>
              Event (but not methods inside the event).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.AnyMember">
            <summary>
              Any member (<see cref = "F:PostSharp.Extensibility.MulticastTargets.Field" />, <see cref = "F:PostSharp.Extensibility.MulticastTargets.Method" />, <see cref = "F:PostSharp.Extensibility.MulticastTargets.InstanceConstructor" />,
              <see cref = "F:PostSharp.Extensibility.MulticastTargets.StaticConstructor" />,
              <see cref = "F:PostSharp.Extensibility.MulticastTargets.Property" />, <see cref = "F:PostSharp.Extensibility.MulticastTargets.Event" />).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Assembly">
            <summary>
              Assembly.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.Parameter">
            <summary>
              Method or property parameter.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.ReturnValue">
            <summary>
              Method or property return value.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.MulticastTargets.All">
            <summary>
              All element kinds.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.PostSharpEnvironment">
            <summary>
              Provides access to the current <c>PostSharp</c> environment (<see cref = "T:PostSharp.Extensibility.IPostSharpEnvironment" />).
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.PostSharpEnvironment.Current">
            <summary>
              Gets the current <c>PostSharp</c> environment, or <c>null</c>
              if the <c>PostSharp</c> Platform is not loaded in the current
              context.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.PostSharpEnvironment.CurrentProject">
            <summary>
            Gets the current PostSharp project.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.PostSharpEnvironment.IsPostSharpRunning">
            <summary>
              Determines whether the <c>PostSharp</c> Platform is currently loaded.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.ProjectExtensionElement">
            <summary>
            Represents a custom element (or section) in the XML project type.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.ProjectExtensionElement.Name">
            <summary>
            Gets the local name of the custom element.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.ProjectExtensionElement.Namespace">
            <summary>
            Gets the XML namespace of the custom element.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.ProjectExtensionElement.XElement">
            <summary>
            Gets the <c>XElement</c> materializing the project extension.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.RequireLicenseAttribute">
            <exclude/>
            <summary>
            Custom attribute that, when applied to an aspect, causes PostSharp to require some license in order to weave the aspect.
            </summary>
            <remarks>
            <para>When several instances of this custom attributes are available, the license check will be satisfied with any of them.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.RequireLicenseAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.RequireLicenseAttribute"/>.
            </summary>
            <param name="product">Identifier of the licensed product.</param>
        </member>
        <member name="P:PostSharp.Extensibility.RequireLicenseAttribute.Product">
            <summary>
            Gets the identifier of the required licensed product.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.RequireLicenseAttribute.Features">
            <summary>
            Gets or sets the bitmask of required licensed features.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.RequireLicenseAttribute.Description">
            <summary>
            Gets or sets the human-readable description of the license requirement.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.RequirePostSharpAttribute">
            <summary>
              Custom attribute that, when applied on another custom attribute (a class derived 
              from <see cref = "T:System.Attribute" />), means that assemblies with elements
              annotated with that custom attribute should be processed by <c>PostSharp</c>.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.RequirePostSharpAttribute.#ctor(System.String,System.String)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Extensibility.RequirePostSharpAttribute" /> and specifies the required plug-in name and task name.
            </summary>
            <param name = "plugIn">Name of the required plug-in (file name without extension).</param>
            <param name = "task">Name of the required task (should be defined in <paramref name = "plugIn" />).</param>
        </member>
        <member name="M:PostSharp.Extensibility.RequirePostSharpAttribute.#ctor(System.String)">
            <summary>
            Initializes a new <see cref = "T:PostSharp.Extensibility.RequirePostSharpAttribute" /> and specifies the required plug-in name.
            All implicit (auto-included) tasks of that plug-in will be added to the project.
            </summary>
            <param name = "plugIn">Name of the required plug-in (file name without extension).</param>
        </member>
        <member name="M:PostSharp.Extensibility.RequirePostSharpAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Extensibility.RequirePostSharpAttribute"/> and specifies the required <see cref="T:PostSharp.Extensibility.IService"/> type.
            </summary>
            <param name="serviceType">A type derived from <see cref="T:PostSharp.Extensibility.IService"/>.</param>
        </member>
        <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.PlugIn">
            <summary>
              Gets the name of the required plug-in (file name without the extension).
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.Task">
            <summary>
              Gets the name of the required task (should be defined in <see cref = "P:PostSharp.Extensibility.RequirePostSharpAttribute.PlugIn" />).
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.ServiceType">
            <summary>
            Gets the type of the required <see cref="T:PostSharp.Extensibility.IService"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.AssemblyReferenceOnly">
            <summary>
            Determines whether the requirement should apply only to assemblies referencing the declaration to
            which the custom attribute is applied. If <c>true</c>, the requirement will not apply to the assembly
            where the custom attribute is used.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.RequirePostSharpAttribute.AnyTypeReference">
            <summary>
            Determines whether the current attribute applies to any project that has any
            reference of the target type. If <c>false</c>, the requirement will apply only
            to assemblies that use the target type as a custom attribute. If <c>true</c>,
            the requirement will apply to any assembly that references the target type. The default value is <c>false</c>.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.ServiceCache">
            <summary>
            Caches the instances of the most often used services.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.ServiceLocatorExtensions.GetServiceChecked``1(PostSharp.Extensibility.IProject)">
            <summary>
            A helper method that checks whether the project is <c>null</c> before attempting to get a service.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.SeverityType">
            <summary>
              Types of message severities.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.Debug">
            <summary>
              Debugging information (typically trace).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.Verbose">
            <summary>
              Verbose (information of low importance).
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.Info">
            <summary>
              Information. Error messages of this severity are not shown in Visual Studio's Error List.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.ImportantInfo">
            <summary>
              Important information. It is shown in Visual Studio's Error List under Messages.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.CommandLine">
            <summary>
              Command line.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.Warning">
            <summary>
              Warning. It is shown in Visual Studio's Error List under Warnings.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.Error">
            <summary>
              Error. It is shown in Visual Studio's Error List under Errors. The project build fails.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.Fatal">
            <summary>
              Fatal error. It is shown in Visual Studio's Error List under Errors. The project build fails and ends immediately.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.SeverityType.None">
            <summary>
            No message.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.SuppressAnnotationValidationAttribute">
            <summary>
            Instructs PostSharp that the validation of <see cref="T:PostSharp.Extensibility.IValidableAnnotation"/> is done by another component, and should
            not be processed by the default component.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.SuppressWarningAttribute">
            <summary>
            Instructs PostSharp to ignore warnings and information messages. Errors cannot be ignored.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Extensibility.SuppressWarningAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:PostSharp.Extensibility.SuppressWarningAttribute"/>.
            </summary>
            <param name="messageId">Identifier of the ignored warning.</param>
        </member>
        <member name="P:PostSharp.Extensibility.SuppressWarningAttribute.MessageId">
            <summary>
            Gets the identifier of the ignored warning.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.SuppressWarningAttribute.Reason">
            <summary>
            Gets or set the reason (a human-readable text) why the warning must be ignored.
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.TargetFrameworkFamily">
            <summary>
            Represents a variant of family (variant) of the .NET Framework, e.g. <see cref="F:PostSharp.Extensibility.TargetFrameworkFamily.NetCore"/>, <see cref="F:PostSharp.Extensibility.TargetFrameworkFamily.NetFramework"/>,
            <see cref="F:PostSharp.Extensibility.TargetFrameworkFamily.Silverlight"/> or <see cref="F:PostSharp.Extensibility.TargetFrameworkFamily.NetPortable"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Extensibility.TargetFrameworkFamily.Value">
            <summary>
            Gets the string identity of the current object.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.TargetFrameworkFamily.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Extensibility.TargetFrameworkFamily.IsNull">
            <summary>
            Determines whether the current object represents a null instance.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.TargetFrameworkFamily.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Extensibility.TargetFrameworkFamily.Equals(PostSharp.Extensibility.TargetFrameworkFamily)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Extensibility.TargetFrameworkFamily.Equals(System.String)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Extensibility.TargetFrameworkFamily.op_Equality(PostSharp.Extensibility.TargetFrameworkFamily,PostSharp.Extensibility.TargetFrameworkFamily)">
            <summary>
            Determines whether two <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> instances are equal.
            </summary>
            <param name="x">A <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/>.</param>
            <param name="y">A <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/>.</param>
            <returns><c>true</c> if <paramref name="x"/> and <paramref name="y"/> are equal, otherwise  <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Extensibility.TargetFrameworkFamily.op_Inequality(PostSharp.Extensibility.TargetFrameworkFamily,PostSharp.Extensibility.TargetFrameworkFamily)">
            <summary>
            Determines whether two <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> instances are different.
            </summary>
            <param name="x">A <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/>.</param>
            <param name="y">A <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/>.</param>
            <returns><c>true</c> if <paramref name="x"/> and <paramref name="y"/> are different, otherwise  <c>false</c></returns>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.NetFramework">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing the full .NET Framework.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.NetCore">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing .NET Core and .NET Framework for Windows Store.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.NETCoreApp">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing .NET Core Framework.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.NetPortable">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing .NET Portable Class Library.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.NetStandard">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing .NET Standard Class Library.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.Silverlight">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing Silverlight.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.Xamarin_iOS">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing Xamarin.iOS.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.MonoAndroid">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing MonoAndroid.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.MonoTouch">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing MonoTouch.
            </summary>
        </member>
        <member name="F:PostSharp.Extensibility.TargetFrameworkFamily.WindowsPhone">
            <summary>
            Instance of <see cref="T:PostSharp.Extensibility.TargetFrameworkFamily"/> representing Windows Phone (Silverlight).
            </summary>
        </member>
        <member name="T:PostSharp.Extensibility.VerbatimMessageLocation">
            <summary>
            The wrapper class used to specify that the given code element must be formatted in the message verbatim.
            For example, display a compiler-generated method name explicitly instead of redirecting to the user-generated method.
            </summary>
        </member>
        <member name="M:PostSharp.Extensibility.VerbatimMessageLocation.#ctor(System.Object)">
            <summary>
            Creates a new instance of <see cref="T:PostSharp.Extensibility.VerbatimMessageLocation"/>.
            </summary>
            <param name="codeElement">The code element that must be formatted verbatim in the message.</param>
        </member>
        <member name="P:PostSharp.Extensibility.VerbatimMessageLocation.CodeElement">
            <summary>
            The underlying code element that will be formatted verbatim in the message.
            </summary>
        </member>
        <member name="T:PostSharp.Post">
            <summary>
              Provides some methods that are transformed during post-compilation.
            </summary>
        </member>
        <member name="M:PostSharp.Post.Cast``2(``0)">
            <summary>
              At post-compile time, casts an instance of a type into another.
              A post-compile time error is reported if the source type cannot be
              assigned to the target type.
            </summary>
            <typeparam name = "TSource">Source type.</typeparam>
            <typeparam name = "TTarget">Target type.</typeparam>
            <param name = "o">Instance to be casted.</param>
            <returns>The object <paramref name = "o" /> casted as <typeparamref name = "TTarget" />.</returns>
            <remarks>
              The purpose of this method is to make a source code compilable even when
              an interface will be implemented at post-compile time.
              PostSharp ensures that <typeparamref name = "TTarget" /> is assignable from
              <typeparamref name = "TSource" />. If yes, the call to this method is
              simply suppressed. If types are not assignable, a build error is issued.
            </remarks>
        </member>
        <member name="P:PostSharp.Post.IsTransformed">
            <summary>
              Determines whether the calling program has been transformed by PostSharp. Calls to this property are replaced
            at build time.
            </summary>
            <value>
              <c>true</c> if the calling program has been transformed by PostSharp, otherwise
              <c>false</c>.
            </value>
        </member>
        <member name="M:PostSharp.Post.GetMutableRef``1(``0@)">
            <summary>
            Gets a mutable reference from a read-only <c>in</c> reference. Calls to this method are replaced
            at build time. 
            </summary>
            <param name="reference">A read-only reference.</param>
            <typeparam name="T">Reference type.</typeparam>
            <returns>Exactly <paramref name="reference"/>.</returns>
        </member>
        <member name="M:PostSharp.Post.GetValue``1(``0)">
            <summary>
              When used to retrieve the value of a field, forces the compiler to retrieve a copy
              of the field value instead of an address to this field. This allows to call
              instance methods of value-type fields without loading the field address.
            </summary>
            <typeparam name = "T">Type of the value to retrieve (this type parameter can generally be omitted).</typeparam>
            <param name = "value">Value.</param>
            <returns><paramref name = "value" />, exactly.</returns>
        </member>
        <member name="T:PostSharp.Reflection.CodeReferenceKind">
            <summary>
              Kinds of code references (<see cref = "T:PostSharp.Reflection.ICodeReference" />).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.CodeReferenceKind.None">
            <summary>
              No code reference.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.CodeReferenceKind.TypeInheritance">
            <summary>
              Type inheritance. The base type is the <see cref = "P:PostSharp.Reflection.ICodeReference.ReferencedDeclaration" />;
              the child type is the <see cref = "P:PostSharp.Reflection.ICodeReference.ReferencingDeclaration" />.
              See <see cref = "T:PostSharp.Reflection.TypeInheritanceCodeReference" />.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.CodeReferenceKind.MemberType">
            <summary>
              Member type (field or property type, method return type, or parameter type).
              The member type is the <see cref = "P:PostSharp.Reflection.ICodeReference.ReferencedDeclaration" />.
              See <see cref = "T:PostSharp.Reflection.MemberTypeCodeReference" />.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.CodeReferenceKind.MethodUsage">
            <summary>
              Operand of an instruction in a method body. The <see cref = "P:PostSharp.Reflection.ICodeReference.ReferencingDeclaration" />
              is the method. See <see cref="T:PostSharp.Reflection.MethodUsageCodeReference"/>.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.CustomAttributeInstance">
            <summary>
              Instance of a custom attribute on a target declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.CustomAttributeInstance.Construction">
            <summary>
              Gets the <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> (including given constructor
              arguments and named arguments) used to construct
              the <see cref = "P:PostSharp.Reflection.CustomAttributeInstance.Attribute" />.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.CustomAttributeInstance.Attribute">
            <summary>
              Gets the custom attribute.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.CustomAttributeInstance.Target">
            <summary>
              Gets the declaration on which the custom attribute is defined.
            </summary>
            <value>
              A reflection object: <see cref = "T:System.Reflection.Assembly" />, <see cref = "T:System.Type" />, <see cref = "T:System.Reflection.MethodInfo" />,
              <see cref = "T:System.Reflection.ConstructorInfo" />, <see cref = "T:System.Reflection.ParameterInfo" />, <see cref = "T:System.Reflection.PropertyInfo" />,
              <see cref = "T:System.Reflection.EventInfo" />, <see cref = "T:System.Reflection.FieldInfo" />.
            </value>
        </member>
        <member name="T:PostSharp.Reflection.CustomReflectionBinder">
            <summary>
              Custom implementation of a reflection <see cref = "T:System.Reflection.Binder" /> that select
              methods based on exact matches using the <see cref = "T:PostSharp.Reflection.ReflectionTypeComparer" />.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.CustomReflectionBinder.Instance">
            <summary>
              Singleton instance.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.CustomReflectionBinder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.CustomReflectionBinder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.CustomReflectionBinder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.CustomReflectionBinder.ReorderArgumentArray(System.Object[]@,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.CustomReflectionBinder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.CustomReflectionBinder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Reflection.DeclarationIdentifier">
            <summary>
            Encapsulates a unique identifier of a declaration. The identifier does not contain the kind of declaration. Different declarations of different kinds can have the same identifier.
            </summary>
            <remarks>
            <para>
            The <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> concept provides an efficient mechanism to correlate
            data that depend on the target declaration of the advice. Typically, such data can be computed at build time
            and serialized into the aspect, then consumed at run time. Without the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> concept,
            the data would be stored in a dictionary, for instance <c>Dictionary&lt;MethodInfo,MethodData&gt;</c> where <c>MethodData</c>
            is a custom class. However, relying on a dictionary has some performance costs. Thanks to the
            the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> concept, data can be stored in an array, because the <see cref="P:PostSharp.Reflection.DeclarationIdentifier.MemberIndex"/> 
            is guaranteed to be unique in a given type for a given kind of member (for instance, <see cref="P:PostSharp.Reflection.DeclarationIdentifier.MemberIndex"/> is unique for all methods in the same type).
            Array lookups are much faster than dictionary lookups and do not rely on reflection, which gives a significant performance benefit.
            </para>
            <note>
            <para>
            Although the CIL specification allows for up to 2^24 types in the same assembly and 2^24 methods (or other members) in the same type, the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/>
            implementation assumes that there will be no more than 2^16 types in the same assembly and 2^16 members of the same kind in the same type. 
            The <see cref="P:PostSharp.Reflection.DeclarationIdentifier.AssemblyId"/> property to be coded on 32 bits. The <see cref="P:PostSharp.Reflection.DeclarationIdentifier.AssemblyId"/> is computed
            by running the MD5 algorithm on the full assembly name. The probability of hash collision is approximately 10^-6 for an application of 100 assemblies and 10^-5
            for an application of 1,000 assemblies. Collisions can be avoided by adding the <see cref="T:PostSharp.Extensibility.AssemblyIdAttribute"/> custom attribute to one of the assemblies causing
            a hash collision. Note that hash collisions are not automatically detected by PostSharp. However, you can build a hash collision detection program by looking at
            the <see cref="T:PostSharp.Extensibility.AssemblyIdAttribute"/> custom attribute on all assemblies of your application after PostSharp has been executed.
            </para>
            </note>
            </remarks>
            <see cref="P:PostSharp.Aspects.AdviceArgs.DeclarationIdentifier"/>
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.#ctor(System.Int64)">
            <exclude/>
        </member>
        <member name="F:PostSharp.Reflection.DeclarationIdentifier.MaxTypeIndex">
            <summary>
            Maximum number of types per assembly supported by the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> class.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.DeclarationIdentifier.MaxMemberIndex">
            <summary>
            Maximum number of the same kind in the same type supported by the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> class.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.DeclarationIdentifier.Null">
            <summary>
            Gets a null instance of the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> type/
            </summary>
            <seealso cref="P:PostSharp.Reflection.DeclarationIdentifier.IsNull"/>
        </member>
        <member name="P:PostSharp.Reflection.DeclarationIdentifier.IsNull">
            <summary>
            Determines whether the current <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> is null.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.DeclarationIdentifier.MemberIndex">
            <summary>
            Gets a number that uniquely identifies the member inside its declaring type, for the given member kind. 
            </summary>
            <remarks>
            <para>The value of this property is guaranteed to be smaller than the total number of methods in the declaring type.</para>
            <para>The value is guaranteed to be unique only in the declaring type, not in the set of base types. Numbering of members restarts at 0 for every derived type.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.DeclarationIdentifier.TypeIndex">
            <summary>
            Gets a number that uniquely identifies the type inside its declaring assembly.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.DeclarationIdentifier.AssemblyId">
            <summary>
            Gets a 29-bit of the name of the assembly containing the declaration represented by the current <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.GetDeclaringTypeIdentifier">
            <summary>
            Gets the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> that represents the declaring type of the declaration represented by the current <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/>.
            </summary>
            <returns>The <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> that represents the declaring type of the declaration represented by the current <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/>.
            If the current <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> already represents a type, this method returns the current <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/>.
            </returns>
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.GetDeclarationIdentifier(System.Reflection.MemberInfo)">
            <summary>
            Gets the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> for a given declaration.
            </summary>
            <param name="declaration">A <see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.EventInfo"/> or <see cref="T:System.Reflection.PropertyInfo"/>.</param>
            <returns>A <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> that identifies <paramref name="declaration"/>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.Equals(PostSharp.Reflection.DeclarationIdentifier)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.op_Equality(PostSharp.Reflection.DeclarationIdentifier,PostSharp.Reflection.DeclarationIdentifier)">
            <summary>
            Determines whether two instances of the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> type are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.DeclarationIdentifier.op_Inequality(PostSharp.Reflection.DeclarationIdentifier,PostSharp.Reflection.DeclarationIdentifier)">
            <summary>
            Determines whether two instances of the <see cref="T:PostSharp.Reflection.DeclarationIdentifier"/> type are different.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:PostSharp.Reflection.IAssemblyName">
            <summary>
              Defines the semantics of an assembly name.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.Name">
            <summary>
              Gets the assembly friendly name.
            </summary>
            <value>
              The assembly friendly name.
            </value>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.Version">
            <summary>
              Gets the assembly version.
            </summary>
            <value>
              A <see cref = "P:PostSharp.Reflection.IAssemblyName.Version" />.
            </value>
        </member>
        <member name="M:PostSharp.Reflection.IAssemblyName.GetPublicKey">
            <summary>
              Gets the assembly public key.
            </summary>
            <value>
              An array of bytes containing the public key,
              or <c>null</c> if no public key is specified (for instance if
              only the public key token is given).
            </value>
            <returns>An array of bytes containing the public key,
              or <c>null</c> if no public key is specified.</returns>
        </member>
        <member name="M:PostSharp.Reflection.IAssemblyName.GetPublicKeyToken">
            <summary>
              Gets the assembly public key token.
            </summary>
            <returns>An array of bytes containing the public key token,
              or <c>null</c> if no public key is specified.</returns>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.Culture">
            <summary>
              Gets the assembly culture name.
            </summary>
            <value>
              The standard assembly culture name, or <c>null</c> if the assembly
              is culture-neutral.
            </value>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.IsStronglyNamed">
            <summary>
              Determines whether the current assembly (or assembly reference) contains a strong name signature.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.IsRetargetable">
            <summary>
            Determines whether the reference is retargetable by the CLR, i.e. can be accommodated by
            an assembly whose identity does not match the current assembly reference.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.ProcessorArchitecture">
            <summary>
              Gets the processor architecture that the current assembly targets.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.IAssemblyName.BindingContext">
            <summary>
            Gets the <see cref="P:PostSharp.Reflection.IAssemblyName.BindingContext"/> in which the assembly name is valid.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.AssemblyProcessorArchitecture">
            <summary>
            Processor architectures of an assembly.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.None">
            <summary>
            None (or not set).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.MSIL">
            <summary>
            MSIL (platform-neutral).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.X86">
            <summary>
            32-bit x86.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.IA64">
            <summary>
            Itanium 64-bit
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.Amd64">
            <summary>
            64-bit x86
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.Arm">
            <summary>
            ARM.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.Arm64">
            <summary>
            ARM64.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.AssemblyProcessorArchitecture.NoPlatform">
            <summary>
            Reference assembly only (the assembly cannot be executed at run time).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.ICodeReference">
            <summary>
              Represents a reference between two declarations.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ICodeReference.ReferencingDeclaration">
            <summary>
              Gets the declaration referencing the other.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ICodeReference.ReferencedDeclaration">
            <summary>
              Gets the declaration referenced by the other.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ICodeReference.ReferenceKind">
            <summary>
              Gets the kind of code reference.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.IMetadataDispenser">
            <summary>
              Semantics of service that deserializes metadata objects (i.e. reflection objects) that have 
              been serialized by <see cref = "T:PostSharp.Reflection.IMetadataEmitter" />.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.IMetadataDispenser.GetMetadata(System.Int32)">
            <summary>
              Gets the reflection object corresponding to the given index.
            </summary>
            <param name = "index">Index returned by <see cref = "M:PostSharp.Reflection.IMetadataEmitter.GetMetadataIndex(System.Object)" />
              at build time.</param>
            <returns>The reflection object corresponding to <paramref name = "index" />.</returns>
        </member>
        <member name="T:PostSharp.Reflection.IMetadataEmitter">
            <summary>
              Semantics of a service that allows build-time code to serialize references
              to metadata objects (i.e. reflection objects) in a way that is compatible with obfuscators.
              References are deserialized at run-time using <see cref = "T:PostSharp.Reflection.IMetadataDispenser" />.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.IMetadataEmitter.GetMetadataIndex(System.Object)">
            <summary>
              Gets the index of a serialized metadata reference.
            </summary>
            <param name = "metadata">A reflection object.</param>
            <returns>The index of <paramref name = "metadata" />, to be serialized
              and deserialized at runtime with <see cref = "M:PostSharp.Reflection.IMetadataDispenser.GetMetadata(System.Int32)" />.</returns>
        </member>
        <member name="M:PostSharp.Reflection.IReflectionHelperService.GetBackingField(System.Reflection.PropertyInfo)">
            <summary>
            Gets the backing field of a given property.
            </summary>
            <param name="propertyInfo">A property.</param>
            <returns>The <see cref="T:System.Reflection.FieldInfo"/> representing the backing field of <paramref name="propertyInfo"/>, or <c>null</c> if <paramref name="propertyInfo"/>
            is not an automatic property.</returns>
        </member>
        <member name="M:PostSharp.Reflection.IReflectionHelperService.GetAutomaticPropertyName(System.String)">
            <summary>
            Gets the name of the automatic property given the name of the corresponding backing field.
            </summary>
            <param name="fieldName">A name of the backing field for the automatic property.</param>
            <returns>The name of the property that corresponds to the provided name of the backing field,
            or <c>null</c> if the name of the field was not in the expected format.</returns>
        </member>
        <member name="T:PostSharp.Reflection.ISourceDocument">
            <summary>
              Represents a file of source code.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ISourceDocument.FileName">
            <summary>
              Full path of the file.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ISourceDocument.Language">
            <summary>
              Language (<see cref = "T:System.Guid" /> according to Microsoft PDB specification).
            </summary>
            <remarks>
            <para>The language GUID varies according to the kind of PDB file (native or portable).</para>
            </remarks>
        </member>
        <member name="T:PostSharp.Reflection.LocationInfo">
            <summary>
              Represents a <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.PropertyInfo" /> or
              <see cref = "T:System.Reflection.ParameterInfo" />, which all have the semantics of a location (get value, set value).
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Reflection.FieldInfo)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.LocationInfo" /> from a <see cref = "T:System.Reflection.FieldInfo" />.
            </summary>
            <param name = "fieldInfo">The field represented by the <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Reflection.PropertyInfo)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.LocationInfo" /> from a <see cref = "T:System.Reflection.PropertyInfo" />.
            </summary>
            <param name = "propertyInfo">The property represented by the <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Reflection.ParameterInfo)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.LocationInfo" /> from a <see cref = "T:System.Reflection.ParameterInfo" />.
            </summary>
            <param name = "parameterInfo">The parameter represented by the <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="serializationInfo"></param>
            <param name="context"></param>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfo(System.Object)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.LocationInfo" /> from a
              <see cref = "T:System.Reflection.FieldInfo" />, <see cref = "T:System.Reflection.PropertyInfo" />, or <see cref = "T:System.Reflection.ParameterInfo" />.
            </summary>
            <param name = "reflectionInfo"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfoArray(System.Collections.Generic.ICollection{System.Reflection.FieldInfo})">
            <summary>
              Converts a collection of <see cref = "P:PostSharp.Reflection.LocationInfo.FieldInfo" /> into an array of <see cref = "T:PostSharp.Reflection.LocationInfo" />.
            </summary>
            <param name = "fields">A collection of <see cref = "P:PostSharp.Reflection.LocationInfo.FieldInfo" />.</param>
            <returns>An array of <see cref = "T:PostSharp.Reflection.LocationInfo" />.</returns>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfoArray(System.Collections.Generic.ICollection{System.Reflection.PropertyInfo})">
            <summary>
              Converts a collection of <see cref = "P:PostSharp.Reflection.LocationInfo.PropertyInfo" /> into an array of <see cref = "T:PostSharp.Reflection.LocationInfo" />.
            </summary>
            <param name = "properties">A collection of <see cref = "P:PostSharp.Reflection.LocationInfo.PropertyInfo" />.</param>
            <returns>An array of <see cref = "T:PostSharp.Reflection.LocationInfo" />.</returns>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.ToLocationInfoArray(System.Collections.Generic.ICollection{System.Reflection.ParameterInfo})">
            <summary>
              Converts a collection of <see cref = "P:PostSharp.Reflection.LocationInfo.ParameterInfo" /> into an array of <see cref = "T:PostSharp.Reflection.LocationInfo" />.
            </summary>
            <param name = "parameters">A collection of <see cref = "P:PostSharp.Reflection.LocationInfo.ParameterInfo" />.</param>
            <returns>An array of <see cref = "T:PostSharp.Reflection.LocationInfo" />.</returns>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.LocationType">
            <summary>
              Gets the type of values that can be stored in the location.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.LocationKind">
            <summary>
              Gets the location kind (<see cref = "F:PostSharp.Reflection.LocationKind.Field" />,
              <see cref = "F:PostSharp.Reflection.LocationKind.Property" />,
              <see cref = "F:PostSharp.Reflection.LocationKind.Parameter" /> or
              <see cref = "F:PostSharp.Reflection.LocationKind.ReturnValue" />).
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.PropertyInfo">
            <summary>
              Gets the underlying <see cref = "T:System.Reflection.PropertyInfo" />,
              or <c>null</c> if the underlying code element is not a property.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.FieldInfo">
            <summary>
              Gets the underlying <see cref = "T:System.Reflection.FieldInfo" />,
              or <c>null</c> if the underlying code element is not a field.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.ParameterInfo">
            <summary>
              Gets the underlying <see cref = "T:System.Reflection.ParameterInfo" />,
              or <c>null</c> if the underlying code element is not a parameter.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.MemberInfo">
            <summary>
              Gets the underlying <see cref = "T:System.Reflection.MemberInfo" />,
              or <c>null</c> if the underlying code element is not a field or a property.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.DeclaringType">
            <summary>
              Gets the declaring type of the underlying field, property, parameter, or return value.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.Name">
            <summary>
              Gets the name of the underlying field, property, parameter, or return value.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.LocationInfo.IsStatic">
            <summary>
              Determines whether the underlying field or property is static.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.GetValue(System.Object)">
            <summary>
              Returns the value of the field or property represented by the current object.
            </summary>
            <param name = "instance">The object whose field  or property value will be returned (<c>null</c> if the
              field or property is static).</param>
            <returns>The value of the field or property.</returns>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.GetValue(System.Object,System.Object[])">
            <summary>
              Returns the value of the field or property represented by the current object 
              with optional index values for indexed properties.
            </summary>
            <param name = "instance">The object whose field  or property value will be returned (<c>null</c> if the
              field or property is static).</param>
            <param name = "index">Optional index values for indexed properties. <c>null</c> for fields or non-index
              properties.</param>
            <returns>The value of the field or property.</returns>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.SetValue(System.Object,System.Object)">
            <summary>
              Sets the value of the field or property represented by the current object to a given value.
            </summary>
            <param name = "instance">The object whose field  or property value will be changed (<c>null</c> if the
              field or property is static).</param>
            <param name = "value">New value.</param>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.SetValue(System.Object,System.Object,System.Object[])">
            <summary>
              Sets the value of the field or property represented by the current object to a given value
              with optional index values for indexed properties.
            </summary>
            <param name = "instance">The object whose field  or property value will be changed (<c>null</c> if the
              field or property is static).</param>
            <param name = "value">New value.</param>
            <param name = "index">Optional index values for indexed properties. <c>null</c> for fields or non-index
              properties.</param>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.ToString">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.Equals(PostSharp.Reflection.LocationInfo)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.op_Equality(PostSharp.Reflection.LocationInfo,PostSharp.Reflection.LocationInfo)">
            <summary>
              Determines whether two instances of <see cref = "T:PostSharp.Reflection.LocationInfo" /> represent the same element of code.
            </summary>
            <param name = "left">A <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
            <param name = "right">A <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
            <returns><c>true</c> if <paramref name = "left" /> and <paramref name = "right" /> are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.LocationInfo.op_Inequality(PostSharp.Reflection.LocationInfo,PostSharp.Reflection.LocationInfo)">
            <summary>
              Determines whether two instances of <see cref = "T:PostSharp.Reflection.LocationInfo" /> represent different elements of code.
            </summary>
            <param name = "left">A <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
            <param name = "right">A <see cref = "T:PostSharp.Reflection.LocationInfo" />.</param>
            <returns><c>true</c> if <paramref name = "left" /> and <paramref name = "right" /> are different, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:PostSharp.Reflection.LocationKind">
            <summary>
              Enumerates the kinds of code elements that can be encapsulated by a <see cref = "T:PostSharp.Reflection.LocationInfo" />.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.LocationKind.Field">
            <summary>
              <see cref = "T:System.Reflection.FieldInfo" />.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.LocationKind.Property">
            <summary>
              <see cref = "T:System.Reflection.PropertyInfo" />.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.LocationKind.Parameter">
            <summary>
              A <see cref = "T:System.Reflection.ParameterInfo" /> representing a parameter (not a <see cref = "F:PostSharp.Reflection.LocationKind.ReturnValue" />).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.LocationKind.ReturnValue">
            <summary>
              A <see cref = "T:System.Reflection.ParameterInfo" /> representing a return value.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MemberTypeCodeReference">
            <summary>
            Represents a relationship between a type and a member of this type.
            A member can be a <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>, or
            <see cref="T:System.Reflection.ParameterInfo"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MemberTypeCodeReference.Type">
            <summary>
            Gets the member type.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MemberTypeCodeReference.Member">
            <summary>
            Gets the member (<see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>, or
            <see cref="T:System.Reflection.ParameterInfo"/>).
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MemberTypeCodeReference.PostSharp#Reflection#ICodeReference#ReferencingDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Reflection.MemberTypeCodeReference.PostSharp#Reflection#ICodeReference#ReferencedDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Reflection.MemberTypeCodeReference.PostSharp#Reflection#ICodeReference#ReferenceKind">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.AddressAlignment">
            <summary>
            Enumeration of address alignments for access to unmanaged memory represented
            by <see cref="T:PostSharp.Reflection.MethodBody.ICopyBufferExpression"/>, <see cref="T:PostSharp.Reflection.MethodBody.IFieldExpression"/> or <see cref="T:PostSharp.Reflection.MethodBody.IValueOfExpression"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.AddressAlignment.Default">
            <summary>
            Default alignment (machine word).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.AddressAlignment.Unaligned1">
            <summary>
            1-byte alignment.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.AddressAlignment.Unaligned2">
            <summary>
            2-byte alignment.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.AddressAlignment.Unaligned4">
            <summary>
            4-byte alignment.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IAddressOfExpression">
            <summary>
            Expression that takes the address of the operand. Equivalent to the C# operator <c>&amp;</c>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IAddressOfExpression.IsReadOnly">
            <summary>
            Determines whether the returned pointer is a read-only pointer.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IBinaryExpression">
            <summary>
            Expression that has two operands, <see cref="P:PostSharp.Reflection.MethodBody.IBinaryExpression.Left"/> and <see cref="P:PostSharp.Reflection.MethodBody.IBinaryExpression.Right"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBinaryExpression.Left">
            <summary>
            Gets the left operand.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBinaryExpression.Right">
            <summary>
            Gets the right operand.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IBlockExpression">
            <summary>
            Block containing other blocks or instructions.
            </summary>
            <remarks>
            <para>A block typically contains other blocks or instructions. Blocks that contain instructions also implement the <see cref="T:PostSharp.Reflection.MethodBody.ISequenceExpression"/> interface. </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBlockExpression.Label">
            <summary>
            Gets a string that uniquely identifies the block (inside the current method body) as a possible branching target.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBlockExpression.ExceptionHandlerKind">
            <summary>
            Gets the kind of exception handler of the current block (<see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Catch"/>, <see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.None"/>
            or <see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Finally"/>), or <see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.None"/> if the current block is not an exception handler.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBlockExpression.ParentExceptionHandler">
            <summary>
            Gets the parent exception handler in the current block is in the <see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Catch"/>, <see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Filter"/> or <see cref="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Finally"/> role.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBlockExpression.Items">
            <summary>
            Gets the collection of items in the block.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBlockExpression.ExceptionHandlers">
            <summary>
            Gets the collection of exception handlers that protect the block, in which the current block is in the <c>try</c> role.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IBlockExpression.LocalVariables">
            <summary>
            Gets the collection of local variables defined for the current block.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.ExceptionHandlerKind">
            <summary>
            Kinds of <see cref="T:PostSharp.Reflection.MethodBody.IExceptionHandler"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.None">
            <summary>
            Not an exception handler.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Catch">
            <summary>
            Catch without filter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Filter">
            <summary>
            Filter with catch block.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.ExceptionHandlerKind.Finally">
            <summary>
            Finally.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IConditionalExpression">
            <summary>
            Conditional expression, corresponding to the <c>if</c> keyword in C#.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IConditionalExpression.Condition">
            <summary>
            Gets the condition expression (the return type does not need to be <c>bool</c>. Zero and <c>null</c> values are considered <c>false</c>).
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IConditionalExpression.IfTrue">
            <summary>
            Gets the expression executed when <see cref="P:PostSharp.Reflection.MethodBody.IConditionalExpression.Condition"/> evaluates to <c>true</c> or a non-null and non-zero vale.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IConditionalExpression.IfFalse">
            <summary>
            Gets the expression executed when <see cref="P:PostSharp.Reflection.MethodBody.IConditionalExpression.Condition"/> evaluates to <c>false</c>, zero, or <c>null</c>.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IConstantExpression">
            <summary>
            Expression representing a build-time constant.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IConstantExpression.Value">
            <summary>
            Gets the constant value.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.ICopyBufferExpression">
            <summary>
            Expression equivalent to the <c>cpblk</c> instruction.
            </summary>
            <remarks>
            <para>This expression type has no equivalent in C#.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ICopyBufferExpression.Source">
            <summary>
            Gets the source address.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ICopyBufferExpression.Destination">
            <summary>
            Gets the destination address.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ICopyBufferExpression.Length">
            <summary>
            Gets the number of bytes to be copied.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ICopyBufferExpression.IsVolatile">
            <summary>
            Determines whether the buffers can be modified from a different thread.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ICopyBufferExpression.Alignment">
            <summary>
            Gets the alignment of source and destination buffers.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IExceptionHandler">
            <summary>
            Represents an exception handler (either <c>catch</c>, <c>finally</c> or <c>filter</c>) attached to a block.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.ExceptionType">
            <summary>
            Gets the type of handled exception, or <c>null</c> if all exceptions are handled.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.TryBlock">
            <summary>
            Gets the <c>try</c> block.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.FilterBlock">
            <summary>
            Gets the exception filtering block, or <c>null</c> if all exceptions are handled.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.HandlerBlock">
            <summary>
            Gets the exception handling block.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.HandlerLocalVariable">
            <summary>
            Gets the local variable containing the exception in the <see cref="P:PostSharp.Reflection.MethodBody.IExceptionHandler.HandlerBlock"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.FilterLocalVariable">
            <summary>
            Gets the local variable containing the exception in the <see cref="P:PostSharp.Reflection.MethodBody.IExceptionHandler.FilterBlock"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExceptionHandler.ExceptionHandlerKind">
            <summary>
            Gets the kind of exception handling clause.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IExpression">
            <summary>
            Represents an expression or an instruction.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IExpression.ReturnType">
            <summary>
            Gets the type of the return value of the current expression,
            or <see cref="T:System.Void"/> if the expression does not return anything (i.e. for pure instructions, for instance a <c>goto</c>
            or <c>throw</c> instruction).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IFieldExpression">
            <summary>
            Expression that represents a field.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IFieldExpression.Instance">
            <summary>
            Gets the object containing the field, or <c>null</c> if the field is static.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IFieldExpression.Field">
            <summary>
            Gets the field.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IFieldExpression.IsVolatile">
            <summary>
            Determine whether the field is can be written by a different thread than the current one.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IFieldExpression.Alignment">
            <summary>
            Gets the field alignment.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IGotoExpression">
            <summary>
            Unconditional branching instruction.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IGotoExpression.Target">
            <summary>
            Instruction block that must receive control.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IInitBufferExpression">
            <summary>
            Expression equivalent to the <c>initblk</c> instruction.
            </summary>
            <remarks>
            <para>This expression type has no equivalent in C#.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IInitBufferExpression.Buffer">
            <summary>
            Gets the address of the buffer to be initialized.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IInitBufferExpression.Length">
            <summary>
            Gets the number of bytes to be initialized.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IInitBufferExpression.IsVolatile">
            <summary>
            Determines whether the buffers can be modified from a different thread.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IInitBufferExpression.Alignment">
            <summary>
            Gets the alignment of the buffers.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.ILocalVariable">
            <summary>
            Expression that represents a local variable.
            </summary>
            <remarks>
                <para>There are three kind of local variable, but consumers of this class should be oblivious to these kinds:
            local variables defined in user code, local variables introduced by the compiler, and pseudo-variables introduced
            by the AST decompiler to emulate the stack.</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ILocalVariable.Name">
            <summary>
            Gets the name of the local variable.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ILocalVariable.VariableType">
            <summary>
            Gets the type of the local variable.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ILocalVariable.Slot">
            <summary>
            Gets the ordinal of the local variable.
            </summary>
            <remarks>
            Several local variables may be assigned the same slot if they are used in different scopes.
            </remarks>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.ILocalVariableExpression">
            <summary>
            Expression that represents a local variable.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ILocalVariableExpression.LocalVariable">
            <summary>
            Gets the local variable.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ILocalVariableExpression.TrivialValue">
            <summary>
            Gets the value of the <see cref="T:PostSharp.Reflection.MethodBody.ILocalVariable"/> at this specific point of the program execution, in case this value
            can be determined trivially.
            </summary>
            <remarks>
            <para>
            If the value cannot be determined in a trivial way, it is possible to perform a non-trivial data flow analysis
            by using the <see cref="M:PostSharp.Reflection.MethodBody.ILocalVariableExpression.GetPossibleAssignments"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.ILocalVariableExpression.GetPossibleAssignments">
            <summary>
            Returns an array of all possible assignments of the <see cref="T:PostSharp.Reflection.MethodBody.ILocalVariable"/> at this specific point of the program execution.
            </summary>
            <returns>List of possible assignments.</returns>
            <remarks>
                <para>
                    The result list contains either assignment expressions (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>) or 
                    <see cref="T:PostSharp.Reflection.MethodBody.IAddressOfExpression"/> when the address of the variable is passed to a method through a reference argument.
                </para>
                <para>Result of this method is cached.</para>
            </remarks>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IMetadataExpression">
            <summary>
            Expression that depends on a metadata declaration. This expression
            is used when compiling the <c>typeof</c>, <c>sizeof</c> or <c>default</c> keywords of C#, among others.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMetadataExpression.Declaration">
            <summary>
            Gets the declaration (<see cref="T:System.Type"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IMethodBody">
            <summary>
            Represents the body of a method.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodBody.Method">
            <summary>
            Gets the method whose body is represented by the current object.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodBody.RootBlock">
            <summary>
            Gets the root instruction block of the method.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IMethodBodyElement">
            <summary>
            Represents an element of the syntax tree representing a method body.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodBodyElement.ParentMethodBody">
            <summary>
            Gets the parent method body.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodBodyElement.ParentElement">
            <summary>
            Gets the parent element in the tree.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodBodyElement.MethodBodyElementKind">
            <summary>
            Gets the kind of syntax element.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IMethodBodyService">
            <summary>
            Service that exposes the method <see cref="M:PostSharp.Reflection.MethodBody.IMethodBodyService.GetMethodBody(System.Reflection.MethodBase,PostSharp.Reflection.MethodBody.MethodBodyAbstractionLevel)"/>, which allows to decompile
            a method and get a AST representation.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.IMethodBodyService.GetMethodBody(System.Reflection.MethodBase,PostSharp.Reflection.MethodBody.MethodBodyAbstractionLevel)">
            <summary>
            Decompiles a method and gets an AST representation of it.
            </summary>
            <param name="method">The method to decompile.</param>
            <param name="abstractionLevel">The required level of abstraction and detail.</param>
            <returns>AST representing the <paramref name="method"/> at the required level of abstraction and detail.</returns>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IMethodCallExpression">
            <summary>
            Expression representing a method call.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodCallExpression.Instance">
            <summary>
            Gets the instance on which the method is called, or <c>null</c> if the method is static.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodCallExpression.Method">
            <summary>
            Gets the called method.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodCallExpression.Arguments">
            <summary>
            Gets the method arguments.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodCallExpression.IsVirtual">
            <summary>
            Determines whether the call is a virtual call.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodCallExpression.IsTail">
            <summary>
            Determines whether the call is a tail call (see <see cref="F:System.Reflection.Emit.OpCodes.Tailcall"/>).
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodCallExpression.ConstrainedType">
            <summary>
            Gets the type to which the virtual method call is constrained to (see <see cref="F:System.Reflection.Emit.OpCodes.Constrained"/>).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IMethodPointerExpression">
            <summary>
            Expression that represents a C-like pointer to a method.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodPointerExpression.Instance">
            <summary>
            Gets the instance on which the method is defined, or <c>null</c> if the method is static.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IMethodPointerExpression.Method">
            <summary>
            Gets the method.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.INewArrayExpression">
            <summary>
            Expression that returns a new array.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.INewArrayExpression.Length">
            <summary>
            Gets the number of elements in the array.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.INewArrayExpression.ElementType">
            <summary>
            Gets the type of elements of the array.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.INewObjectExpression">
            <summary>
            Expression that creates a new object by invoking a constructor.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.INewObjectExpression.Constructor">
            <summary>
            Gets the constructor.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.INewObjectExpression.Arguments">
            <summary>
            Gets the arguments passed to the constructor.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IParameterExpression">
            <summary>
            Expression that represents a method parameter.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IParameterExpression.Parameter">
            <summary>
            Gets the parameter.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.ISequenceExpression">
            <summary>
            Sequence of instructions.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ISequenceExpression.Predecessors">
            <summary>
            Gets the list of sequences that can branch to the current sequence.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ISequenceExpression.Successors">
            <summary>
            Gets the list of sequences to which the current sequence branch.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ISequenceExpression.LocalVariableAssignments">
            <summary>
            Gets the list of local variables that the current sequence assigns, and the value to which the local variable is assigned when the current sequence
            is fully executed.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IStatementExpression">
            <summary>
            Represents a statement. A statement is the root of an expression tree.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IStatementExpression.PreviousSibling">
            <summary>
            Gets a previous sibling of the current expression within <see cref="T:PostSharp.Reflection.MethodBody.IBlockExpression" />.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IStatementExpression.NextSibling">
            <summary>
            Gets a next sibling of the current expression within <see cref="T:PostSharp.Reflection.MethodBody.IBlockExpression" />.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IStatementExpression.Expression">
            <summary>
            Expression evaluated by the statement.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.ISwitchExpression">
            <summary>
            Expression that represent a switch (conditional statement with multiple branches).
            </summary>
            <remarks>
                <para>This interface represents the MSIL <c>switch</c> statement, not the C#
                      statement. The main difference is that switch cases have no value: the value of a switch case is equal to
                      its position in the list of <see cref="P:PostSharp.Reflection.MethodBody.ISwitchExpression.Targets"/>.
            </para>
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ISwitchExpression.Condition">
            <summary>
            Gets the condition expression.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.ISwitchExpression.Targets">
            <summary>
            Gets the list of target blocks.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IUnaryExpression">
            <summary>
            Represents an expression with a single operand.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IUnaryExpression.Value">
            <summary>
            Operand of the unary expression.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IValueOfExpression">
            <summary>
            Expression that returns the value stored at an address. Equivalent to the C# keyword <c>*</c>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IValueOfExpression.IsVolatile">
            <summary>
            Determines whether if the location at the address is volatile, i.e. if it can be changed
            by a different thread than the current one.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.IValueOfExpression.Alignment">
            <summary>
            Gets the alignment of the value at the address.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.IZeroaryExpression">
            <summary>
            Expression with no operand.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.LocalVariableAssignment">
            <summary>
            Represents the assignment of a local variable to an expression.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.LocalVariableAssignment.LocalVariable">
            <summary>
            Gets the local variable being assigned.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodBody.LocalVariableAssignment.Expression">
            <summary>
            Gets the expression to which the local variable is being assigned.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.MethodBodyAbstractionLevel">
            <summary>
            Enumerates the level of abstraction and the level of details produced by the AST decompiler.
            </summary>
            <see cref="T:PostSharp.Reflection.MethodBody.IMethodBodyService"/>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyAbstractionLevel.Structure">
            <summary>
            Returns only the block structure (exception handlers).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyAbstractionLevel.ExpressionTree">
            <summary>
            Returns the expression tree.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.MethodBodyElementKind">
            <summary>
            Enumeration of kinds of syntax elements (<see cref="T:PostSharp.Reflection.MethodBody.IMethodBodyElement"/>).
            </summary>
            <see cref="T:PostSharp.Reflection.MethodBody.IMethodBodyElement"/>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Add">
            <summary>
            Addition (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.AddChecked">
            <summary>
            Addition with overflow checking (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.And">
            <summary>
            Bitwise <c>And</c> (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ArrayIndex">
            <summary>
            Element of an array (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/> where <see cref="P:PostSharp.Reflection.MethodBody.IBinaryExpression.Left"/> is the
            array and <see cref="P:PostSharp.Reflection.MethodBody.IBinaryExpression.Right"/> is the index).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ArrayLength">
            <summary>
            Length of an array (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Assign">
            <summary>
            Assignment (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Goto">
            <summary>
            Unconditional branch (<see cref="T:PostSharp.Reflection.MethodBody.IGotoExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Variable">
            <summary>
            Local variable expression (<see cref="T:PostSharp.Reflection.MethodBody.ILocalVariableExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Conditional">
            <summary>
            Conditional expression (<see cref="T:PostSharp.Reflection.MethodBody.IConditionalExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Cast">
            <summary>
            Cast (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/> where <see cref="P:PostSharp.Reflection.MethodBody.IExpression.ReturnType"/> is the destination type).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Divide">
            <summary>
            Division (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.LessThan">
            <summary>
            Less than (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.LessThanOrEqual">
            <summary>
            Less than or equal (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Modulo">
            <summary>
            Modulo (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.MultiplyChecked">
            <summary>
            Multiply with overflow checking (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Multiply">
            <summary>
            Multiply (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.GreaterThan">
            <summary>
            Greater than (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.GreaterThanOrEqual">
            <summary>
            Greater than (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Substract">
            <summary>
            Substract (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.SubstractChecked">
            <summary>
            Substract with overflow checking (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Parameter">
            <summary>
            Parameter (<see cref="T:PostSharp.Reflection.MethodBody.IParameterExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.This">
            <summary>
            Current object (<c>this</c> keyword in C#, <see cref="T:PostSharp.Reflection.MethodBody.IZeroaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.AddressOf">
            <summary>
            Referencing operator (<c>&amp;</c> in C#, see <see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Constant">
            <summary>
            Constant (<see cref="T:PostSharp.Reflection.MethodBody.IConstantExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Equal">
            <summary>
            Equal (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Not">
            <summary>
            Logical negation (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Different">
            <summary>
            Different (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ValueOf">
            <summary>
            Dereferencing operator (<c>*</c> in C#, see <see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Or">
            <summary>
            Bitwise <c>Or</c> (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Xor">
            <summary>
            Bitwise <c>And</c> (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ShiftLeft">
            <summary>
            Bitwise shift to left (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ShiftRight">
            <summary>
            Bitwise shift to right (<see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Negate">
            <summary>
            Bitwise negation (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.SafeCast">
            <summary>
            Safe cast (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/> where <see cref="P:PostSharp.Reflection.MethodBody.IExpression.ReturnType"/> is the destination type).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Unbox">
            <summary>
            Unbox (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Throw">
            <summary>
            Throw exception (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Field">
            <summary>
            Field (<see cref="T:PostSharp.Reflection.MethodBody.IFieldExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Box">
            <summary>
            Box (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.NewArray">
            <summary>
            Create new array (<see cref="T:PostSharp.Reflection.MethodBody.INewArrayExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.TypedReferenceValue">
            <summary>
            Get value of typed reference (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.CheckFinite">
            <summary>
            Check that the value is finite (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.MakeTypedReference">
            <summary>
            Make typed reference (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ArgumentList">
            <summary>
            Get argument list (<see cref="T:PostSharp.Reflection.MethodBody.IZeroaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.MethodPointer">
            <summary>
            Get pointer of method (<see cref="T:PostSharp.Reflection.MethodBody.IMethodPointerExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.LocalAlloc">
            <summary>
            Allocate on local stack (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.DefaultValue">
            <summary>
            Default value for given type (<see cref="T:PostSharp.Reflection.MethodBody.IMetadataExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.CopyBuffer">
            <summary>
            Copy buffer (<see cref="T:PostSharp.Reflection.MethodBody.ICopyBufferExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.InitBuffer">
            <summary>
            Initialize buffer (<see cref="T:PostSharp.Reflection.MethodBody.IInitBufferExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.LoadToken">
            <summary>
            Load metadata token (<see cref="T:PostSharp.Reflection.MethodBody.IMetadataExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.SizeOf">
            <summary>
            Size of type (<see cref="T:PostSharp.Reflection.MethodBody.IMetadataExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.TypedReferenceType">
            <summary>
            Get type of typed reference (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.ConvertChecked">
            <summary>
            Convert to integral type with overflow check (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Convert">
            <summary>
            Convert to integral type (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.MethodCall">
            <summary>
            Method call (<see cref="T:PostSharp.Reflection.MethodBody.IMethodCallExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Return">
            <summary>
            Return (<see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.NewObject">
            <summary>
            Creates new object (<see cref="T:PostSharp.Reflection.MethodBody.INewObjectExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Switch">
            <summary>
            Switch (<see cref="T:PostSharp.Reflection.MethodBody.ISwitchExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Block">
            <summary>
            Instruction block (<see cref="T:PostSharp.Reflection.MethodBody.IBlockExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.MethodBody">
            <summary>
            Method body (<see cref="T:PostSharp.Reflection.MethodBody.IMethodBody"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.LocalVariableDefinition">
            <summary>
            Local variable definition (<see cref="T:PostSharp.Reflection.MethodBody.ILocalVariable"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Statement">
            <summary>
            Statement (<see cref="T:PostSharp.Reflection.MethodBody.IStatementExpression"/>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodBody.MethodBodyElementKind.Rethrow">
            <summary>
            Re-throw exception (<see cref="T:PostSharp.Reflection.MethodBody.IZeroaryExpression"/>).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.MethodBodyFormatter">
            <summary>
            Formats an <see cref="T:PostSharp.Reflection.MethodBody.IMethodBodyElement"/> to a textual representation, for debugging purposes.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.#ctor(System.IO.TextWriter)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Reflection.MethodBody.MethodBodyFormatter"/>.
            </summary>
            <param name="writer">A  <see cref="T:System.IO.TextWriter"/> where the textual representation will be written.</param>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitBlockExpression(PostSharp.Reflection.MethodBody.IBlockExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitSwitchExpression(PostSharp.Reflection.MethodBody.ISwitchExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitZeroaryExpression(PostSharp.Reflection.MethodBody.IZeroaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitParameterExpression(PostSharp.Reflection.MethodBody.IParameterExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitNewArrayExpression(PostSharp.Reflection.MethodBody.INewArrayExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitMethodCallExpression(PostSharp.Reflection.MethodBody.IMethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitMetadataExpression(PostSharp.Reflection.MethodBody.IMetadataExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitVariableExpression(PostSharp.Reflection.MethodBody.ILocalVariableExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitInitBufferExpression(PostSharp.Reflection.MethodBody.IInitBufferExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitGotoExpression(PostSharp.Reflection.MethodBody.IGotoExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitFieldExpression(PostSharp.Reflection.MethodBody.IFieldExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitBinaryExpression(PostSharp.Reflection.MethodBody.IBinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitUnaryExpression(PostSharp.Reflection.MethodBody.IUnaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitConditionalExpression(PostSharp.Reflection.MethodBody.IConditionalExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitConstantExpression(PostSharp.Reflection.MethodBody.IConstantExpression)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyFormatter.VisitCopyBufferExpression(PostSharp.Reflection.MethodBody.ICopyBufferExpression)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Reflection.MethodBody.MethodBodyVisitor">
            <summary>
            Abstract implementation of a visitor of method bodies (<see cref="T:PostSharp.Reflection.MethodBody.IMethodBody"/> and <see cref="T:PostSharp.Reflection.MethodBody.IExpression"/>).
            </summary>
            <remarks>
                <para>
                    This class provides an abstract implementation, which only ensures that the proper visiting method
                    gets called for every node of the tree, without any other effect. Concrete implementations typically
                    override specific visiting methods, and call the base implementation to ensure that children nodes
                    are being processed too.
                </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitMethodBody(PostSharp.Reflection.MethodBody.IMethodBody)">
            <summary>
            Visits a method body and, recursively, all syntax nodes.
            </summary>
            <param name="methodBody">The method body to be visited.</param>
            <returns><paramref name="methodBody"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitBlockExpression(PostSharp.Reflection.MethodBody.IBlockExpression)">
            <summary>
            Visits an instruction block and, recursively, all syntax nodes.
            </summary>
            <param name="instructionBlock">The method body to be visited.</param>
            <returns><paramref name="instructionBlock"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitStatementExpression(PostSharp.Reflection.MethodBody.IStatementExpression)">
            <summary>
            Visits an instruction block and, recursively, all syntax nodes.
            </summary>
            <param name="statementExpression">The statement to be visited.</param>
            <returns><paramref name="statementExpression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitSyntaxElement(PostSharp.Reflection.MethodBody.IMethodBodyElement)">
            <summary>
            Visits a syntax element and, recursively, all children elements.
            </summary>
            <param name="syntaxElement">The element to be visited.</param>
            <returns><paramref name="syntaxElement"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitAddressOfExpression(PostSharp.Reflection.MethodBody.IAddressOfExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IAddressOfExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitValueOfExpression(PostSharp.Reflection.MethodBody.IValueOfExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IValueOfExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitLocalVariable(PostSharp.Reflection.MethodBody.ILocalVariable)">
            <summary>
            Visits a local variable definition.
            </summary>
            <param name="localVariable">The local variable to be visited.</param>
            <returns><paramref name="localVariable"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitSwitchExpression(PostSharp.Reflection.MethodBody.ISwitchExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.ISwitchExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitZeroaryExpression(PostSharp.Reflection.MethodBody.IZeroaryExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IZeroaryExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitParameterExpression(PostSharp.Reflection.MethodBody.IParameterExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IParameterExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitNewArrayExpression(PostSharp.Reflection.MethodBody.INewArrayExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.INewArrayExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitMethodPointerExpression(PostSharp.Reflection.MethodBody.IMethodPointerExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IMethodPointerExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitNewObjectExpression(PostSharp.Reflection.MethodBody.INewObjectExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.INewObjectExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitMethodCallExpression(PostSharp.Reflection.MethodBody.IMethodCallExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IMethodCallExpression"/>  and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitMetadataExpression(PostSharp.Reflection.MethodBody.IMetadataExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IMetadataExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitVariableExpression(PostSharp.Reflection.MethodBody.ILocalVariableExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.ILocalVariableExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitInitBufferExpression(PostSharp.Reflection.MethodBody.IInitBufferExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IInitBufferExpression"/> and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitGotoExpression(PostSharp.Reflection.MethodBody.IGotoExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IGotoExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
            <returns><paramref name="expression"/>, unless the override returns something else.</returns>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitFieldExpression(PostSharp.Reflection.MethodBody.IFieldExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IFieldExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitBinaryExpression(PostSharp.Reflection.MethodBody.IBinaryExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IBinaryExpression"/> and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitUnaryExpression(PostSharp.Reflection.MethodBody.IUnaryExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/> and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitConditionalExpression(PostSharp.Reflection.MethodBody.IConditionalExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IUnaryExpression"/> and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitConstantExpression(PostSharp.Reflection.MethodBody.IConstantExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.IGotoExpression"/>.
            </summary>
            <param name="expression">The element to be visited.</param>
        </member>
        <member name="M:PostSharp.Reflection.MethodBody.MethodBodyVisitor.VisitCopyBufferExpression(PostSharp.Reflection.MethodBody.ICopyBufferExpression)">
            <summary>
            Visits an expression of type <see cref="T:PostSharp.Reflection.MethodBody.ICopyBufferExpression"/> and, recursively, all children elements.
            </summary>
            <param name="expression">The element to be visited.</param>
        </member>
        <member name="T:PostSharp.Reflection.MethodUsageCodeReference">
            <summary>
            Represents a relationship between a declaration (<see cref="T:System.Type"/>,
            <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.MethodInfo"/> or <see cref="T:System.Reflection.ConstructorInfo"/>)
            and a method whose instructions (method body) use the declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.UsingMethod">
            <summary>
            Gets the method (<see cref="T:System.Reflection.MethodInfo"/> or <see cref="T:System.Reflection.ConstructorInfo"/>)
            whose body uses the declaration.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.UsedDeclaration">
            <summary>
            Gets the declaration (<see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>
            or <see cref="T:System.Reflection.ConstructorInfo"/>) used by the method.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.UsedType">
            <summary>
            Gets the <see cref="T:System.Type"/> used by the method. If the current
            object represents a reference to a <see cref="T:System.Reflection.MethodInfo"/>
            or <see cref="T:System.Reflection.ConstructorInfo"/>, this property returns the declaring
            type of the method or constructor.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.Instructions">
            <summary>
            Gets the instructions that reference <see cref="P:PostSharp.Reflection.MethodUsageCodeReference.UsedDeclaration"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.PostSharp#Reflection#ICodeReference#ReferencingDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.PostSharp#Reflection#ICodeReference#ReferencedDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Reflection.MethodUsageCodeReference.PostSharp#Reflection#ICodeReference#ReferenceKind">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Reflection.MethodUsageInstructions">
            <summary>
            Instructions whose operands can reference a declaration.
            </summary>
            <seealso cref="T:PostSharp.Reflection.MethodUsageCodeReference"/>.
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.None">
            <summary>
            No instruction.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.LoadField">
            <summary>
            Get field value.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.StoreField">
            <summary>
            Set field value.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.Call">
            <summary>
            Call to a static or sealed method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.CallVirtual">
            <summary>
            Call to a virtual method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.NewObject">
            <summary>
            Creation of a new instance (invoke the constructor).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.LoadFieldAddress">
            <summary>
            Get field address.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.LoadMetadata">
            <summary>
            Load the metadata token (for instance <c>typeof</c>).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.LoadMethodAddress">
            <summary>
            Load the address of a static or sealed method (delegate instantiation).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.LoadMethodAddressVirtual">
            <summary>
            Load the address of a virtual method (delegate instantiation).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.Cast">
            <summary>
            Type casting.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.IsInstance">
            <summary>
            "Safe" type casting (<c>as</c> or <c>is</c> in C#).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.SizeOf">
            <summary>
            Get the size of a value type (<c>sizeof</c> in C#).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.MethodUsageInstructions.NewArray">
            <summary>
            Create a new array of a type.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.ObjectConstruction">
            <summary>
              Specifies how an object should be constructed, i.e. specifies the constructor to be
              used, the arguments to be passed to this constructor, and the fields or properties to
              be set.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.ObjectConstruction.#ctor(System.String,System.Object[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> by specifying a type name and a list of constructor arguments.
            </summary>
            <param name = "typeName">Name of the object type.</param>
            <param name = "constructorArguments">Arguments passed to the constructor.</param>
        </member>
        <member name="M:PostSharp.Reflection.ObjectConstruction.#ctor(System.Type,System.Object[])">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> by specifying a type name and a list of constructor arguments.
            </summary>
            <param name = "type">Object type.</param>
            <param name = "constructorArguments">Arguments passed to the constructor.</param>
        </member>
        <member name="M:PostSharp.Reflection.ObjectConstruction.#ctor(System.Reflection.ConstructorInfo,System.Object[])">
            <summary>
              Initializes a new type-safe <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> from a <see cref = "T:System.Reflection.ConstructorInfo" />.
            </summary>
            <param name = "constructor">Constructor.</param>
            <param name = "constructorArguments">Arguments passed to the constructor.</param>
        </member>
        <member name="M:PostSharp.Reflection.ObjectConstruction.#ctor(System.Reflection.CustomAttributeData)">
            <summary>
              Initializes a new type-safe <see cref = "T:PostSharp.Reflection.ObjectConstruction" /> from a <see cref = "T:System.Reflection.CustomAttributeData" />
            </summary>
            <param name = "customAttributeData">A <see cref = "T:System.Reflection.CustomAttributeData" /></param>
        </member>
        <member name="P:PostSharp.Reflection.ObjectConstruction.TypeName">
            <summary>
              Gets the assembly-qualified type name of the object.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ObjectConstruction.Constructor">
            <summary>
              Gets the custom attribute constructor.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ObjectConstruction.ConstructorArguments">
            <summary>
              Gets the arguments passed to the custom attribute constructor.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.ObjectConstruction.NamedArguments">
            <summary>
              Gets the collection of named arguments.
            </summary>
            <remarks>
              This collection is a dictionary associating the name of public a field or property of the
              custom attributes to the value that should be assigned to it.
            </remarks>
        </member>
        <member name="T:PostSharp.Reflection.ParameterKind">
            <summary>
            Enumerates all possible kinds of method parameters. The parameter kind indicates whether the parameter is by ref or by value and its direction.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ParameterKind.InValue">
            <summary>
            Normal (input) parameter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ParameterKind.ByRefIn">
            <summary>
            The read-only parameter passed by reference (<c>in</c> parameters since C# 7.2).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ParameterKind.ByRefOut">
            <summary>
            <c>out</c> parameter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ParameterKind.ByRefInOut">
            <summary>
            <c>ref</c> parameter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ParameterKind.ReturnValue">
            <summary>
            The return value parameter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ParameterKind.ReturnRef">
            <summary>
            The reference return value parameter (<c>ref</c> returns since C# 7.0).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.ParameterKindExtensions">
            <summary>
            Extensions for the <see cref="T:PostSharp.Reflection.ParameterKind"/> class.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.ParameterKindExtensions.IsInputParameter(PostSharp.Reflection.ParameterKind)">
            <summary>
            Determines whether a parameter of a given <see cref="T:PostSharp.Reflection.ParameterKind"/> has a meaningful input value.
            </summary>
            <param name="parameterKind"></param>
            <returns><c>true</c> if <paramref name="parameterKind"/> equals to <see cref="F:PostSharp.Reflection.ParameterKind.InValue"/>, <see cref="F:PostSharp.Reflection.ParameterKind.ByRefIn"/> or <see cref="F:PostSharp.Reflection.ParameterKind.ByRefInOut"/>,
            otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ParameterKindExtensions.IsOutputParameter(PostSharp.Reflection.ParameterKind)">
            <summary>
            Determines whether a parameter of a given <see cref="T:PostSharp.Reflection.ParameterKind"/> has a meaningful output value (but is not the return parameter; in C#, that's <c>ref</c> and <c>out</c> parameters).
            </summary>
            <param name="parameterKind"></param>
            <returns><c>true</c> if <paramref name="parameterKind"/> equals to  <see cref="F:PostSharp.Reflection.ParameterKind.ByRefOut"/> or <see cref="F:PostSharp.Reflection.ParameterKind.ByRefInOut"/>,
            otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ParameterKindExtensions.IsReturn(PostSharp.Reflection.ParameterKind)">
            <summary>
            Determines whether a parameter of a given <see cref="T:PostSharp.Reflection.ParameterKind"/> represents a return parameter.
            </summary>
            <returns><c>true</c> if <paramref name="parameterKind"/> equals to <see cref="F:PostSharp.Reflection.ParameterKind.ReturnValue"/> or <see cref="F:PostSharp.Reflection.ParameterKind.ReturnRef"/>,
            otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ParameterKindExtensions.IsByRefParameter(PostSharp.Reflection.ParameterKind)">
            <summary>
            Determines whether a parameter of a given <see cref="T:PostSharp.Reflection.ParameterKind"/> is passed by reference (but is not the return parameter).
            </summary>
            <param name="parameterKind"></param>
            <returns><c>true</c> if <paramref name="parameterKind"/> equals to <see cref="F:PostSharp.Reflection.ParameterKind.ByRefIn"/>, <see cref="F:PostSharp.Reflection.ParameterKind.ByRefOut"/> or <see cref="F:PostSharp.Reflection.ParameterKind.ByRefInOut"/>,
            otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ParameterKindExtensions.IsParameter(PostSharp.Reflection.ParameterKind)">
            <summary>
            Determines whether a parameter is a "real" parameter, and not the return parameter.
            </summary>
            <param name="parameterKind"></param>
            <returns><c>true</c> if <paramref name="parameterKind"/> equals to <see cref="F:PostSharp.Reflection.ParameterKind.InValue"/>, <see cref="F:PostSharp.Reflection.ParameterKind.ByRefIn"/>, <see cref="F:PostSharp.Reflection.ParameterKind.ByRefOut"/> or <see cref="F:PostSharp.Reflection.ParameterKind.ByRefInOut"/>,
            otherwise <c>false</c>.</returns>
        </member>
        <member name="T:PostSharp.Reflection.ReflectionExtensions">
            <summary>
            Provides utility methods to work with the <c>System.Reflection</c> namespace.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionExtensions.GetAutomaticProperty(System.Reflection.FieldInfo)">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> whose a given field is the backing field from the current type or base types.
            </summary>
            <param name="field">A field.</param>
            <returns>The <see cref="T:System.Reflection.PropertyInfo"/> representing the property whose <paramref name="field"/> is the backing field, or <c>null</c>
            if <paramref name="field"/> is not the backing field of an automatic property.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionExtensions.GetAutomaticProperty(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> whose a given field is the backing field and specifies whether base types should be considered.
            </summary>
            <param name="field">A field.</param>
            <param name="inherit"><c>true</c> if the property should be looked for in the base, otherwise <c>false</c>.</param>
            <returns>The <see cref="T:System.Reflection.PropertyInfo"/> representing the property whose <paramref name="field"/> is the backing field, or <c>null</c>
            if <paramref name="field"/> is not the backing field of an automatic property.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionExtensions.IsAutomaticProperty(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether a given property is an automatic property.
            </summary>
            <param name="propertyInfo">A property.</param>
            <returns><c>true</c> if <paramref name="propertyInfo"/> represents an automatic property, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionExtensions.GetBackingField(System.Reflection.PropertyInfo)">
            <summary>
            Gets the backing field of a given property.
            </summary>
            <param name="propertyInfo">A property.</param>
            <returns>The <see cref="T:System.Reflection.FieldInfo"/> representing the backing field of <paramref name="propertyInfo"/>, or <c>null</c> if <paramref name="propertyInfo"/>
            is not an automatic property.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionExtensions.GetStateMachineKind(System.Reflection.MethodInfo)">
            <summary>
            Gets the kind of state machine (for example, <see cref="F:PostSharp.Reflection.StateMachineKind.Async"/>, <see cref="F:PostSharp.Reflection.StateMachineKind.Iterator"/> or <see cref="F:PostSharp.Reflection.StateMachineKind.None"/>) that implements a given method.
            </summary>
            <param name="method">A method.</param>
            <returns>A <see cref="T:PostSharp.Reflection.StateMachineKind"/> value, or <see cref="F:PostSharp.Reflection.StateMachineKind.None"/> if <paramref name="method"/> is not implemented by a state machine.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionExtensions.GetStateMachinePublicMethod(System.Reflection.MethodInfo)">
            <summary>
            Gets the public (or kick-off) method given a <c>MoveNext</c> method.
            </summary>
            <param name="method">The move next method.</param>
            <returns>The public (kick-off method) corresponding to <paramref name="method"/>.</returns>
        </member>
        <member name="T:PostSharp.Reflection.ReflectionHelper">
            <summary>
            Provides helper methods for work with <see cref="N:System.Reflection"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetProperty(System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <ignore />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetProperty(System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Boolean)">
            <ignore />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetEvent(System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <ignore />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetField(System.Type,System.String)">
            <ignore />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetLocation(System.Type,System.String,System.String,PostSharp.Reflection.LocationKind)">
            <ignore />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetLocation(System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <ignore />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.IsAvailableInTargetFramework(System.Reflection.MemberInfo)">
            <summary>
            Determines whether a given <see cref="T:System.Reflection.MemberInfo"/> is available in the target framework
            of the current project.
            </summary>
            <param name="memberInfo">A declaration that necessarily exists in the build-time framework.</param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.IsAvailableInTargetFramework(System.Type)">
            <summary>
            Determines whether a given <see cref="T:System.Type"/> is available in the target framework
            of the current project.
            </summary>
            <param name="type">A declaration that necessarily exists in the build-time framework.</param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.IsCompilerGenerated(System.Reflection.MemberInfo)">
            <summary>
            Determines whether a <see cref="T:System.Reflection.MemberInfo"/> is compiler-generated.
            </summary>
            <param name="member">A <see cref="T:System.Reflection.MemberInfo"/>.</param>
            <returns><c>true</c> if <paramref name="member"/> is compiler-generated, <c>false</c> if it is hand-coded.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.IsCompilerGenerated(System.Type)">
            <summary>
            Determines whether a <see cref="T:System.Type"/> is compiler-generated.
            </summary>
            <param name="type">A <see cref="T:System.Type"/>.</param>
            <returns><c>true</c> if <paramref name="type"/> is compiler-generated, <c>false</c> if it is hand-coded.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.IsFunctionPointer(System.Type)">
            <summary>
            Gets a value
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetSemanticInfo(System.Reflection.MemberInfo)">
            <summary>
            Gets the <see cref="T:PostSharp.Reflection.SemanticInfo"/> for a given member.
            </summary>
            <param name="member">A member.</param>
            <returns>The <see cref="T:PostSharp.Reflection.SemanticInfo"/> for <paramref name="member"/>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetSemanticInfo(System.Type)">
            <summary>
            Gets the <see cref="T:PostSharp.Reflection.SemanticInfo"/> for a given type.
            </summary>
            <param name="type">A type.</param>
            <returns>The <see cref="T:PostSharp.Reflection.SemanticInfo"/> for <paramref name="type"/>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.AreInternalsVisibleToCurrentProject(System.Reflection.Assembly)">
            <summary>
            Determines whether the internals of a given assembly are visible to the current project.
            </summary>
            <param name="definingAssembly">The assembly containing the internal declaration.</param>
            <returns><c>true</c> if <paramref name="definingAssembly"/> equals the assembly being processed or if <paramref name="definingAssembly"/> contains an <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> attribute
            for the assembly being processed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.AreInternalsVisibleTo(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Determines whether the <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> attribute relationship exists between two assemblies.
            </summary>
            <param name="definingAssembly">The assembly defining the <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> attribute.</param>
            <param name="referencingAssembly">The assembly referenced by the <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> attribute.</param>
            <returns><c>true</c> if <paramref name="definingAssembly"/> equals <paramref name="referencingAssembly"/> or if <paramref name="definingAssembly"/> contains an <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> attribute
            for <paramref name="referencingAssembly"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.GetAssemblyQualifiedTypeName(System.String,System.String)">
            <summary>
            Gets a properly-escaped assembly-qualified type name from its components.
            </summary>
            <param name="typeName">The type name.</param>
            <param name="assemblyName">The assembly name.</param>
            <returns>A string of the form <code>TypeName, AssemblyName</code>, where commas in <paramref name="typeName"/> have been properly escaped.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionHelper.ParseAssemblyQualifiedTypeName(System.String,System.String@,System.String@)">
            <summary>
            Parses an escaped assembly-qualified type name into its components.
            </summary>
            <param name="assemblyQualifiedTypeName">The escaped assembly-qualified type name.</param>
            <param name="typeName">The type name.</param>
            <param name="assemblyName">The assembly name.</param>
        </member>
        <member name="T:PostSharp.Reflection.ReflectionSearch">
            <summary>
              Set of static methods providing broader access to assembly metadata than
              the <c>System.Reflection</c> namespace. These methods are only
              available at build time.
            </summary>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>    
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetCustomAttributesOfType(System.Type)">
            <summary>
              Gets all custom attributes of a given type in the assembly being currently processed.
            </summary>
            <param name="customAttributeType"><see cref="T:System.Type" /> of the custom attribute.</param>
            <returns>The set of all custom attributes of type <paramref name="customAttributeType" />
              defined in  the assembly being currently processed.</returns>
            <remarks>
              <para>
      <note>
        This method returns custom attributes from the internal annotation repository of PostSharp. This repository contains more
        than only custom attributes added in source code. For instance, if you use
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        to add a custom attribute to several elements of code in a single line of code, this method will return
        one custom attribute instance for every target of the
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        .
      </note>
    </para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetCustomAttributesOfType(System.Type,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets all custom attributes of a given type in the assembly being currently processed and specifies 
              additional options.
            </summary>
            <param name="customAttributeType"><see cref="T:System.Type" /> of the custom attribute.</param>
            <param name="options">Either <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeDerivedTypes" /> or <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.None" />.</param>
            <returns>The set of all custom attributes of type <paramref name="customAttributeType" /> (or any type derived
              from <paramref name="customAttributeType" />, if the option <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeDerivedTypes" /> 
              is <c>true</c>) defined in  the assembly being currently processed.</returns>
            <remarks>
              <para>
      <note>
        This method returns custom attributes from the internal annotation repository of PostSharp. This repository contains more
        than only custom attributes added in source code. For instance, if you use
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        to add a custom attribute to several elements of code in a single line of code, this method will return
        one custom attribute instance for every target of the
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        .
      </note>
    </para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetCustomAttributesOnTarget(System.Object)">
            <summary>
              Gets all custom attributes on a given element of code, including those who have been added indirectly, for
              instance through <see cref="T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
            <param name="target">Element of code (<see cref="T:System.Type" />, <see cref="T:System.Reflection.MethodInfo" />, ...) whose
              custom attributes are requested.</param>
            <returns>The set of all custom attributes added, directly or indirectly, to <paramref name="target" />.</returns>
            <remarks>
              <para>
      <note>
        This method returns custom attributes from the internal annotation repository of PostSharp. This repository contains more
        than only custom attributes added in source code. For instance, if you use
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        to add a custom attribute to several elements of code in a single line of code, this method will return
        one custom attribute instance for every target of the
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        .
      </note>
    </para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetCustomAttributesOnTarget(System.Object,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets all custom attributes on a given element of code, including those who have been added indirectly, for
              instance through <see cref="T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
            <param name="target">Element of code (<see cref="T:System.Type" />, <see cref="T:System.Reflection.MethodInfo" />, ...) whose
              custom attributes are requested.</param>
            <param name="options">This parameter has no effect and is kept only for backwards compatibility.</param>
            <returns>The set of all custom attributes added, directly or indirectly, to <paramref name="target" />.</returns>
            <remarks>
              <para>
      <note>
        This method returns custom attributes from the internal annotation repository of PostSharp. This repository contains more
        than only custom attributes added in source code. For instance, if you use
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        to add a custom attribute to several elements of code in a single line of code, this method will return
        one custom attribute instance for every target of the
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        .
      </note>
    </para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetCustomAttributesOnTarget``1(System.Object,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets all custom attributes of a given type on a given element of code, including those who have been added indirectly, for
              instance through <see cref="T:PostSharp.Extensibility.MulticastAttribute" /> and specifies additional options.
            </summary>
            <typeparam name="T">Type of the custom attribute.</typeparam>
            <param name="target">Element of code (<see cref="T:System.Type" />, <see cref="T:System.Reflection.MethodInfo" />, ...) whose
              custom attributes are requested.</param>
            <param name="options"><see cref="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeDerivedTypes" /> or <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.None" />.</param>
            <returns>The set of all custom attributes added, directly or indirectly, to <paramref name="target" />.</returns>
            <remarks>
              <para>
      <note>
        This method returns custom attributes from the internal annotation repository of PostSharp. This repository contains more
        than only custom attributes added in source code. For instance, if you use
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        to add a custom attribute to several elements of code in a single line of code, this method will return
        one custom attribute instance for every target of the
        <see cref="T:PostSharp.Extensibility.MulticastAttribute" />
        .
      </note>
    </para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.HasCustomAttribute(System.Object,System.Type,System.Boolean)">
            <summary>
            Determines whether a declaration has a custom attribute of a given type, including those who have been added indirectly, for
              instance through <see cref = "T:PostSharp.Extensibility.MulticastAttribute" />.
            </summary>
            <param name = "target">Element of code (<see cref = "T:System.Type" />, <see cref = "T:System.Reflection.MethodInfo" />, ...) whose
              custom attributes are requested.</param>
            <param name="type">The type of custom attributes.</param>
            <param name="inherit"><c>true</c> to consider custom attributes derived from <paramref name="type"/>, <c>false</c> to consider
            only custom attributes strictly of type <paramref name="type"/>.</param>
            <returns>True if <paramref name="type"/> has a custom attribute of type <paramref name="type"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetDeclarationsUsedByMethod(System.Reflection.MethodBase)">
            <summary>
              Gets all declarations (<see cref="T:System.Type" />,
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />) used
              by the body of a given method or constructor.
            </summary>
            <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />.</param>
            <returns>An array of <see cref="T:PostSharp.Reflection.MethodUsageCodeReference" /> containing one
              item for each declaration used by the body of <paramref name="method" />.</returns>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetDeclarationsUsedByMethod(System.Reflection.MethodBase,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets all declarations (<see cref="T:System.Type" />,
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />) used
              by the body of a given method or constructor and specifies additional options.
            </summary>
            <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />.</param>
            <param name="options">This parameter has no effect and is kept only for backwards compatibility.</param>
            <returns>An array of <see cref="T:PostSharp.Reflection.MethodUsageCodeReference" /> containing one
              item for each declaration used by the body of <paramref name="method" />.
            </returns>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetMethodsUsingDeclaration(System.Reflection.MemberInfo)">
            <summary>
              Gets the set of methods and constructors whose body references a given (<see cref="T:System.Type" />,
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />).
            </summary>
            <param name="declaration">The <see cref="T:System.Type" />,
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />
              whose references are requested.</param>
            <returns>An array of <see cref="T:PostSharp.Reflection.MethodUsageCodeReference" /> containing one
              item for each method or constructor whose body references <paramref name="declaration" />.
            </returns>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetMethodsUsingDeclaration(System.Reflection.MemberInfo,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets the set of methods and constructors whose body references a given (<see cref="T:System.Type" />,
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />).
            </summary>
            <param name="declaration">The <see cref="T:System.Type" />,
              <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.MethodInfo" /> or <see cref="T:System.Reflection.ConstructorInfo" />
              whose references are requested.</param>
            <param name="options">This parameter has no effect and is kept only for backwards compatibility.</param>
            <returns>An array of <see cref="T:PostSharp.Reflection.MethodUsageCodeReference" /> containing one
              item for each method or constructor whose body references <paramref name="declaration" />.
            </returns>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetDerivedTypes(System.Type)">
            <summary>
              Gets the set of types derived from a given class or implementing a given interface.
            </summary>
            <param name="baseType">A class or interface.</param>
            <returns>The set of types derived from or implementing <paramref name="baseType" />.</returns>
            <remarks>
              <para>This method returns only types defined in the assembly being currently processed.</para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetDerivedTypes(System.Type,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets the set of types derived from a given class or implementing a given interface.
              and specifies additional options.
            </summary>
            <param name="baseType">A class or interface.</param>
            <param name="options">Either <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeTypeElement" /> (partial type match), or 
            <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeDerivedTypes" /> (deep search), but not both, or <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.None" />.</param>
            <returns>The set of types derived from or implementing <paramref name="baseType" />.</returns>
            <remarks>
              <para>This method returns only types defined in the assembly being currently processed.</para>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetMembersOfType(System.Type)">
            <summary>
              Gets all members (<see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.PropertyInfo" />, or
              <see cref="T:System.Reflection.ParameterInfo" />) of the assembly being processed of a given type.
            </summary>
            <param name="memberType">Member type.</param>
            <returns>The set of all members of type <paramref name="memberType" /> in the assembly being processed</returns>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionSearch.GetMembersOfType(System.Type,PostSharp.Reflection.ReflectionSearchOptions)">
            <summary>
              Gets all members (<see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.PropertyInfo" />, or
              <see cref="T:System.Reflection.ParameterInfo" />) of the assembly being processed of a given type and specifies additional options.
            </summary>
            <param name="memberType">Member type.</param>
            <param name="options">Either <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeTypeElement" /> or <see cref="F:PostSharp.Reflection.ReflectionSearchOptions.None" />.</param>
            <returns>The set of all members of type <paramref name="memberType" /> in the assembly being processed</returns>
            <remarks>
            <para>
      <note>
        This feature is available only at build time.
      </note>
    </para>
            </remarks>
        </member>
        <member name="T:PostSharp.Reflection.ReflectionSearchOptions">
            <summary>
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:PostSharp.Reflection.ReflectionSearchOptions.None">
            <summary>
            No option.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeDerivedTypes">
            <summary>
            Include relationships referencing a derived type (instead of exactly that type).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ReflectionSearchOptions.IncludeTypeElement">
            <summary>
            Include relationships referencing a type signature including the given type (instead of only the given type).
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.ReflectionTypeComparer">
            <summary>
              Comparer of reflection types (<see cref = "T:System.Type" />) based on content, not reference.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.ReflectionTypeComparer.instance">
            <summary>
              Singleton instance.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetInstance">
            <summary>
              Gets an instance of <see cref = "T:PostSharp.Reflection.ReflectionTypeComparer" /> that does not perform
              substitution of generic parameters.
            </summary>
            <returns>An instance of <see cref = "T:PostSharp.Reflection.ReflectionTypeComparer" />.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetInstance(System.Type[],System.Type[],System.Type[],System.Type[])">
            <summary>
              Gets an instance of <see cref = "T:PostSharp.Reflection.ReflectionTypeComparer" /> that performs
              substitution of generic parameters.
            </summary>
            <param name = "leftGenericMethodParameters">Array of types to be substituted to the
              generic method parameters of the left member.</param>
            <param name = "leftGenericTypeParameters">Array of types to be substituted to the
              generic type parameters of the left member.</param>
            <param name = "rightGenericMethodParameters">Array of types to be substituted to the
              generic method parameters of the right member.</param>
            <param name = "rightGenericTypeParameters">Array of types to be substituted to the
              generic type parameters of the right member.</param>
            <returns>An instance of <see cref = "T:PostSharp.Reflection.ReflectionTypeComparer" />.</returns>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionTypeComparer.Equals(System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetHashCode(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionTypeComparer.Equals(System.Type[],System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.ReflectionTypeComparer.GetHashCode(System.Type[])">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Reflection.Semantics">
            <summary>
            Enumerates the possible semantics of a declaration in the source programming language.
            For instance an MSIL method can be in C# a property getter, an operator, an anonymous method, and so on.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.InstanceConstructor">
            <summary>
            Explicitly-defined instance constructor.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.StaticConstructor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.DefaultConstructor">
            <summary>
            Default instance constructor (compiler-implemented).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Event">
            <summary>
            Normal event.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherCompilerGeneratedEvent">
            <summary>
            Any compiler-generated event that does not have another semantic in the current enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.EventAdder">
            <summary>
            Event adder.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.EventRemover">
            <summary>
            Event remover.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.EventRaiser">
            <summary>
            Event raiser (does not exist in C#).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.AnyEventAccessor">
            <summary>
            Event adder, remover, or raiser.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.PropertyGetter">
            <summary>
            Property getter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.PropertySetter">
            <summary>
            Property setter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.AnyPropertyAccessor">
            <summary>
            Property getter or setter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Operator">
            <summary>
            Operator (unary, binary, implicit, or explicit).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.AnonymousMethod">
            <summary>
            Anonymous method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.LocalFunction">
            <summary>
            Local function.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Method">
            <summary>
            Normal method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherCompilerGeneratedMethod">
            <summary>
            Any compiler-generated method that does not have another semantic in the current enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Finalizer">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherSpecialMethod">
            <summary>
            Any special method (with either the <see cref="F:System.Reflection.MethodAttributes.SpecialName"/> or <see cref="F:System.Reflection.MethodAttributes.RTSpecialName"/> set)
            that does not have a semantic in the current enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherCompilerGeneratedField">
            <summary>
            Any compiler-generated field that does not have another semantic in the current enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Field">
            <summary>
            Normal field.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.PropertyBackingField">
            <summary>
            Field backing an automatic property.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.EventBackingField">
            <summary>
            Field backing an automatic event.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.AnonymousMethodCacheField">
            <summary>
            Compiler-generated field used as a cache for anonymous methods.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Property">
            <summary>
            Normal property.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherCompilerGeneratedProperty">
            <summary>
            Any compiler-generated property that does not have another semantic in the current enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Type">
            <summary>
            Normal type.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.ComClass">
            <summary>
            VB COM Class.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.CompilerGeneratedTypeMember">
            <summary>
            Any member of a compiler-generated type.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.CompilerGeneratedMethodParameter">
            <summary>
            Any parameter of a compiler-generated method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.Parameter">
            <summary>
            Parameter.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherDeclaration">
            <summary>
            Any declaration not represented in this enumeration.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.CodeContractsField">
            <summary>
            Field supporting Code Contracts.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.AsyncStateMachineType">
            <summary>
            Type implementing an async state machine.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.IteratorStateMachineType">
            <summary>
            Type implementing an iterator state machine.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Semantics.OtherCompilerGeneratedType">
            <summary>
            Any compiler-generated type that does not have another semantic in the current enumeration.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.SemanticInfo">
            <summary>
            Provides information about the semantic of a declaration in the source programming language.
            For instance an MSIL method can be in C# a property getter, an operator, an anonymous method, and so on.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SemanticInfo.Semantic">
            <summary>
            Gets the semantic of the MSIL method in the source language.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SemanticInfo.IsCompilerGenerated">
            <summary>
            Determines whether the declaration is compiler-generated.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SemanticInfo.IsSelectable">
            <summary>
            Determines whether the declaration can be safely selected in a pointcut using the standard <c>System.Reflection</c> API.
            </summary>
            <remarks>
            This property is <c>false</c> for declarations such as anonymous methods or local functions because their MSIL implementation
            can move from one type to another because of a mere change of the method body in C#. It is also <c>false</c> for
            implementation details such as anonymous method cache fields, or closure types, which should never be advised.
            </remarks>
        </member>
        <member name="P:PostSharp.Reflection.SemanticInfo.DisplayName">
            <summary>
            Gets a human-readable description of the <see cref="P:PostSharp.Reflection.SemanticInfo.Semantic"/> property.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.StateMachineKind">
            <summary>
            Enumeration of kinds of state machines.
            </summary>
            <seealso cref="M:PostSharp.Reflection.ReflectionExtensions.GetStateMachineKind(System.Reflection.MethodInfo)"/>
        </member>
        <member name="F:PostSharp.Reflection.StateMachineKind.None">
            <summary>
            The method is not implemented by a state machine.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.StateMachineKind.Iterator">
            <summary>
            Iterator method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.StateMachineKind.Async">
            <summary>
            Async method.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.StateMachineKind.AsyncIterator">
            <summary>
            Async method that returns IAsyncEnumerable&lt;T&gt;. New in C# 8.0.
            </summary>
        </member>
        <member name="T:PostSharp.Reflection.SymbolSequencePoint">
            <summary>
              Maps a point in IL instructions to location in source code.
            </summary>
            <remarks>
              This class implements the <see cref = "T:System.IComparable`1" /> interface.
              This allows sorting sequence points according to their IL offsets and performing
              binary searches in sorted arrays.
            </remarks>
        </member>
        <member name="F:PostSharp.Reflection.SymbolSequencePoint.startLine">
            <summary>
              Start line in the source code.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.SymbolSequencePoint.startColumn">
            <summary>
              Start column in the source code.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.SymbolSequencePoint.endLine">
            <summary>
              End line in the source code.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.SymbolSequencePoint.endColumn">
            <summary>
              End column in the source code.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.SymbolSequencePoint.offset">
            <summary>
              Offset in the IL binary code.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.SymbolSequencePoint.Hidden">
            <summary>
              Gets a symbol meaning that the associated instructions have no source code.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,PostSharp.Reflection.ISourceDocument,System.Object)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.SymbolSequencePoint" />.
            </summary>
            <param name = "offset">The offset of the current sequence point in the IL stream,
              w.r.t. the first byte of the method body.</param>
            <param name = "startLine">The start line in the source file.</param>
            <param name = "startColumn">The start column in the source file.</param>
            <param name = "endLine">The end line in the source file.</param>
            <param name = "endColumn">The end column in the source file.</param>
            <param name = "document">Source file.</param>
            <param name="sourceDeclaration">The source code element declaration containing this symbol sequence point.</param>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,PostSharp.Reflection.ISourceDocument,System.Object)">
            <summary>
              Initializes a new <see cref = "T:PostSharp.Reflection.SymbolSequencePoint" />.
            </summary>
            <param name = "startLine">The start line in the source file.</param>
            <param name = "startColumn">The start column in the source file.</param>
            <param name = "endLine">The end line in the source file.</param>
            <param name = "endColumn">The end column in the source file.</param>
            <param name = "document">Source file.</param>
            <param name="sourceDeclaration">The source code element declaration containing this symbol sequence point.</param>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.IsHidden">
            <summary>
              Determines whether the current symbol means that the associated
              instructions have no source code.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.IsSpecial">
            <summary>
            Determines whether the current symbol is a special, non-standard, defined
            by PostSharp and supported by PostSharp Tools for Visual Studio.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.StartLine">
            <summary>
              Gets the start line in the source file.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.EndLine">
            <summary>
              Gets the end line in the source file.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.StartColumn">
            <summary>
              Gets the start column in the source file.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.EndColumn">
            <summary>
              Gets the end column in the source file.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.Offset">
            <summary>
              Gets the offset in the IL method body.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.SourceDocument">
            <summary>
            Document (file of source code) containing the current sequence point.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.SourceDeclaration">
            <summary>
            The source code element declaration containing the current sequence point.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.SymbolSequencePoint.Kind">
            <summary>
            The kind of the symbol sequence point.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.CompareTo(PostSharp.Reflection.SymbolSequencePoint)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.Equals(PostSharp.Reflection.SymbolSequencePoint)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.op_Equality(PostSharp.Reflection.SymbolSequencePoint,PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
              Determines whether two sequence points are equal.
            </summary>
            <param name = "left">A <see cref = "T:PostSharp.Reflection.SymbolSequencePoint" />.</param>
            <param name = "right">A <see cref = "T:PostSharp.Reflection.SymbolSequencePoint" />.</param>
            <returns><c>true</c> if both sequence points are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.op_Inequality(PostSharp.Reflection.SymbolSequencePoint,PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
              Determines whether two sequence points are different.
            </summary>
            <param name = "left">A <see cref = "T:PostSharp.Reflection.SymbolSequencePoint" />.</param>
            <param name = "right">A <see cref = "T:PostSharp.Reflection.SymbolSequencePoint" />.</param>
            <returns><c>true</c> if both sequence points are different, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.ToString">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.op_LessThan(PostSharp.Reflection.SymbolSequencePoint,PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
            Operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.op_LessThanOrEqual(PostSharp.Reflection.SymbolSequencePoint,PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
            Operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.op_GreaterThan(PostSharp.Reflection.SymbolSequencePoint,PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
            Operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Reflection.SymbolSequencePoint.op_GreaterThanOrEqual(PostSharp.Reflection.SymbolSequencePoint,PostSharp.Reflection.SymbolSequencePoint)">
            <summary>
            Operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:PostSharp.Reflection.TypeInheritanceCodeReference">
            <summary>
            Represents a inheritance relationship between two types.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.TypeInheritanceCodeReference.BaseType">
            <summary>
            Gets the base type. If the base type is a generic type, this property contains
            a generic type instance.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.TypeInheritanceCodeReference.DerivedType">
            <summary>
            Gets the derived type.
            </summary>
        </member>
        <member name="P:PostSharp.Reflection.TypeInheritanceCodeReference.PostSharp#Reflection#ICodeReference#ReferencingDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Reflection.TypeInheritanceCodeReference.PostSharp#Reflection#ICodeReference#ReferencedDeclaration">
            <inheritdoc />
        </member>
        <member name="P:PostSharp.Reflection.TypeInheritanceCodeReference.PostSharp#Reflection#ICodeReference#ReferenceKind">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Reflection.Visibility">
            <summary>
              Visibility of types and type members.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Visibility.Public">
            <summary>
              Public.
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Visibility.Family">
            <summary>
              Family (protected).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Visibility.Assembly">
            <summary>
              Assembly (internal).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Visibility.FamilyOrAssembly">
            <summary>
              Family or assembly (protected internal).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Visibility.FamilyAndAssembly">
            <summary>
              Family and assembly (no C# equivalent: protected types inside the current assembly).
            </summary>
        </member>
        <member name="F:PostSharp.Reflection.Visibility.Private">
            <summary>
              Private.
            </summary>
        </member>
        <member name="M:PostSharp.Reflection.ReflectionApiWrapper.IsAsyncMethod(System.Reflection.MethodInfo)">
            <summary>
            Returns true if the method is backed by an async state machine. This includes async streams.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.ActivatorProvider">
            <summary>
            Provides instances of classes implementing the <see cref="T:PostSharp.Serialization.IActivator"/> interface. You should not use this class in user code.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ActivatorProvider.GetActivator(System.Type)">
            <summary>
            Gets an instance of a given class implementing the <see cref="T:PostSharp.Serialization.IActivator"/> interface.
            </summary>
            <param name="type">A type implementing the <see cref="T:PostSharp.Serialization.IActivator"/> interface.</param>
            <returns>An instance of type <paramref name="type"/>.</returns>
        </member>
        <member name="T:PostSharp.Serialization.ActivatorSecurityToken">
            <summary>
            Security token passed to the <see cref="M:PostSharp.Serialization.IActivator.CreateInstance(System.Type,PostSharp.Serialization.ActivatorSecurityToken)"/> method of the <see cref="T:PostSharp.Serialization.IActivator"/> interface.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.ActivatorTypeAttribute">
            <summary>
            Custom attribute that, when applied to an assembly, points to a type in the assembly implementing <see cref="T:PostSharp.Serialization.IActivator"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ActivatorTypeAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.ActivatorTypeAttribute"/>.
            </summary>
            <param name="activatorType">A type derived from <see cref="T:PostSharp.Serialization.IActivator"/> in the current assembly. This type must be public and have
            a default constructor.</param>
        </member>
        <member name="P:PostSharp.Serialization.ActivatorTypeAttribute.ActivatorType">
            <summary>
            Gets the activator type.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.DottedString">
            <summary>
            Encapsulates dotted strings such as namespaces and type names, so their
            serialization by <see cref="T:PostSharp.Serialization.PortableFormatter"/> can be optimized.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.DottedString.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.DottedString"/>.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="F:PostSharp.Serialization.DottedString.Null">
            <summary>
            Gets an instance of <see cref="T:PostSharp.Serialization.DottedString"/> representing a <c>null</c> string.
            </summary>
        </member>
        <member name="P:PostSharp.Serialization.DottedString.IsNull">
            <summary>
            Determines whether the current <see cref="T:PostSharp.Serialization.DottedString"/> represents a <c>null</c> string.
            </summary>
        </member>
        <member name="P:PostSharp.Serialization.DottedString.Value">
            <summary>
            Gets the string encapsulated by the current <see cref="T:PostSharp.Serialization.DottedString"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.DottedString.op_Implicit(PostSharp.Serialization.DottedString)~System.String">
            <summary>
            Converts a <see cref="T:PostSharp.Serialization.DottedString"/> into a <see cref="T:System.String"/>.
            </summary>
            <param name="dottedString">A <see cref="T:PostSharp.Serialization.DottedString"/>.</param>
            <returns>The <see cref="T:System.String"/> encapsulated by <paramref name="dottedString"/>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.DottedString.op_Implicit(System.String)~PostSharp.Serialization.DottedString">
            <summary>
            Converts a <see cref="T:System.String"/> into a <see cref="T:PostSharp.Serialization.DottedString"/>.
            </summary>
            <param name="str">A <see cref="T:System.String"/>.</param>
            <returns>A <see cref="T:PostSharp.Serialization.DottedString"/> encapsulating <paramref name="str"/>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.DottedString.Equals(PostSharp.Serialization.DottedString)">
            <summary>
            Determines whether the current<see cref="T:PostSharp.Serialization.DottedString"/> is equal to another one.
            </summary>
            <param name="other">Another <see cref="T:PostSharp.Serialization.DottedString"/>.</param>
            <returns><c>true</c> if the current <see cref="T:PostSharp.Serialization.DottedString"/> equals <c>other</c>, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.DottedString.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.DottedString.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.DottedString.ToString">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.DottedString.op_Equality(PostSharp.Serialization.DottedString,PostSharp.Serialization.DottedString)">
            <summary>
            Operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:PostSharp.Serialization.DottedString.op_Inequality(PostSharp.Serialization.DottedString,PostSharp.Serialization.DottedString)">
            <summary>
            Operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:PostSharp.Serialization.IActivator">
            <summary>
            Exposes a method <see cref="M:PostSharp.Serialization.IActivator.CreateInstance(System.Type,PostSharp.Serialization.ActivatorSecurityToken)"/>, which allows to create an instance of a type using the <see cref="T:System.Activator"/> facility.
            </summary>
            <remarks>
            <para>PostSharp generates implementations of this interface in each assembly that contains serializable classes. It allows
            to create objects in the security context of this assembly (instead of from the security context of <c>PostSharp.dll</c>).</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Serialization.IActivator.CreateInstance(System.Type,PostSharp.Serialization.ActivatorSecurityToken)">
            <summary>
            Creates an instance of a give type.
            </summary>
            <param name="objectType">Type of object whose an instance is requested.</param>
            <param name="securityToken">A security token.</param>
            <returns>A new instance of type <paramref name="objectType"/>.</returns>
            <remarks>
                <para>For security reasons, implementations should throw an exception or return <c>null</c> if <paramref name="securityToken"/> is <c>nuill</c>.</para>
            </remarks>
        </member>
        <member name="T:PostSharp.Serialization.IArgumentsReader">
            <summary>
            Provides read access to the collection of deserialized arguments.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.IArgumentsReader.TryGetValue``1(System.String,``0@,System.String)">
            <summary>
            Attempts to read a value from the collection, and does not throw an exception if the value does not exist.
            </summary>
            <typeparam name="T">Value type.</typeparam>
            <param name="name">Argument name.</param>
            <param name="value">At output, set to the value of the argument named <paramref name="name"/> in the given optional <paramref name="scope"/>.</param>
            <param name="scope">An optional prefix of <paramref name="name"/>, similar to a namespace.</param>
            <returns><c>true</c> if the value is defined, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.IArgumentsReader.GetValue``1(System.String,System.String)">
            <summary>
            Reads a value from the collection, and throws an exception if the value does not exist.
            </summary>
            <typeparam name="T">Value type.</typeparam>
            <param name="name">Argument name.</param>
            <param name="scope">An optional prefix of <paramref name="name"/>, similar to a namespace.</param>
            <returns>The value of the argument named <paramref name="name"/> in the given optional <paramref name="scope"/>.</returns>
        </member>
        <member name="P:PostSharp.Serialization.IArgumentsReader.MetadataDispenser">
            <summary>
            When deserializing PostSharp aspects, gets the <see cref="T:PostSharp.Reflection.IMetadataDispenser"/> corresponding to the <see cref="P:PostSharp.Serialization.IArgumentsWriter.MetadataEmitter"/> 
            used at build time.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.IArgumentsWriter">
            <summary>
            Provides write access to a collection of arguments that need to be serialized.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.IArgumentsWriter.SetValue(System.String,System.Object,System.String)">
            <summary>
            Sets the value of an argument.
            </summary>
            <param name="name">Argument name.</param>
            <param name="value">Argument value. The value can be <c>null</c> or must be serializable.</param>
            <param name="scope">An optional prefix of <paramref name="name"/>, similar to a namespace.</param>
        </member>
        <member name="P:PostSharp.Serialization.IArgumentsWriter.MetadataEmitter">
            <summary>
            When serializing PostSharp access, gets a facility that can be used to serialize metadata (<c>System.Reflection</c>) objects
            as MSIL, therefore making them transparent to obfuscation. 
            </summary>
            <see cref="P:PostSharp.Serialization.IArgumentsReader.MetadataDispenser"/>
        </member>
        <member name="T:PostSharp.Serialization.ImportSerializerAttribute">
            <summary>
            Custom attribute that, when applied to a serializable type, specifies that the serializer of this type has
            a dependency on another serializer. The custom attribute can be applied at assembly level; it then
            applies to all serializable types in this assembly.
            </summary>
            <remarks>
            <para>This custom attribute is useful to add serializers to types of third-party assemblies.
            For types whose source code you can modify, it is preferable to use <see cref="T:PostSharp.Serialization.PSerializableAttribute"/> or <see cref="T:PostSharp.Serialization.SerializerAttribute"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PostSharp.Serialization.ImportSerializerAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.ImportSerializerAttribute"/>.
            </summary>
            <param name="objectType">Type of the object to be made serializable.</param>
            <param name="serializerType">Serializer type. This type must implement <see cref="T:PostSharp.Serialization.ISerializer"/> or <see cref="T:PostSharp.Serialization.ISerializerFactory"/>,
            and must have a public default constructor. If <paramref name="serializerType"/> is a generic type, if must have the same number
            of generic type parameters as <paramref name="objectType"/>, and have a compatible set of constraints.</param>
            <seealso cref="T:PostSharp.Serialization.SerializerAttribute"/>
        </member>
        <member name="P:PostSharp.Serialization.ImportSerializerAttribute.ObjectType">
            <summary>
            Gets the type of the object to be made serializable
            </summary>
        </member>
        <member name="P:PostSharp.Serialization.ImportSerializerAttribute.SerializerType">
            <summary>
            Gets the serializer type.
            </summary>
            <remarks>
            This type must implement <see cref="T:PostSharp.Serialization.ISerializer"/> or <see cref="T:PostSharp.Serialization.ISerializerFactory"/>,
            and must have a public default constructor. If <see cref="P:PostSharp.Serialization.ImportSerializerAttribute.SerializerType"/> is a generic type, if must have the same number
            of generic type parameters as <see cref="P:PostSharp.Serialization.ImportSerializerAttribute.ObjectType"/>, and have a compatible set of constraints.
            </remarks>
        </member>
        <member name="T:PostSharp.Serialization.ISerializationCallback">
            <summary>
            Interface that can be implemented by serializable classes.
            It defines methods <see cref="M:PostSharp.Serialization.ISerializationCallback.OnDeserialized"/> and <see cref="M:PostSharp.Serialization.ISerializationCallback.OnSerializing"/> called during serialization.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ISerializationCallback.OnDeserialized">
            <summary>
            Method called after the object has been deserialized.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ISerializationCallback.OnSerializing">
            <summary>
            Method called before the object is being serialized.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.ISerializer">
            <summary>
            Defines the semantics of an object serializer.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ISerializer.Convert(System.Object,System.Type)">
            <summary>
            Converts a value into a given target type.
            </summary>
            <param name="value">Value to be converted.</param>
            <param name="targetType">target type.</param>
            <returns>The <paramref name="value"/> converted to <paramref name="targetType"/>.</returns>
            <remarks>
                <para>This method allows for additional flexibility if the serialization-time type is
                        not equal to the deserialization-time. The current method is invoked
            at deserialization time to perform the conversion.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Serialization.ISerializer.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)">
            <summary>
            Creates an instance of the given type.
            </summary>
            <param name="type">Type of the instance to be created.</param>
            <param name="constructorArguments">Gives access to arguments required to create the instance.</param>
            <returns>An instance of type <paramref name="type"/> initialized using <paramref name="constructorArguments"/>.</returns>
            <remarks>
                <para>This method is invoked during deserialization. If <see cref="P:PostSharp.Serialization.ISerializer.IsTwoPhase"/> is <c>true</c>, the <see cref="M:PostSharp.Serialization.ISerializer.DeserializeFields(System.Object@,PostSharp.Serialization.IArgumentsReader)"/>
                method is called later to complete deserialization.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Serialization.ISerializer.DeserializeFields(System.Object@,PostSharp.Serialization.IArgumentsReader)">
            <summary>
            Completes the second phase of deserialization by setting fields and other properties.
            </summary>
            <param name="obj">The object being deserialized.</param>
            <param name="initializationArguments">Gives access to field values.</param>
            <remarks>
                <para>This method is only invoked if <see cref="P:PostSharp.Serialization.ISerializer.IsTwoPhase"/> is <c>true</c>.</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Serialization.ISerializer.SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <summary>
            Serializes an object
            </summary>
            <param name="obj"></param>
            <param name="constructorArguments">Gives access to arguments that will be passed to the <see cref="M:PostSharp.Serialization.ISerializer.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)"/> method during deserialization.</param>
            <param name="initializationArguments">Gives access to arguments that will be passed to the <see cref="M:PostSharp.Serialization.ISerializer.DeserializeFields(System.Object@,PostSharp.Serialization.IArgumentsReader)"/> method during deserialization.</param>
        </member>
        <member name="P:PostSharp.Serialization.ISerializer.IsTwoPhase">
            <summary>
            Determines whether <see cref="M:PostSharp.Serialization.ISerializer.DeserializeFields(System.Object@,PostSharp.Serialization.IArgumentsReader)"/> should be invoked during deserialization.
            The value is <c>false</c> if <see cref="M:PostSharp.Serialization.ISerializer.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)"/> return fully created object, <c>true</c> otherwise.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.ISerializerDiscoverer">
            <summary>
            Exposes a method <seealso cref="M:PostSharp.Serialization.ISerializerDiscoverer.DiscoverSerializers(System.Type)"/> that allows implementations
            of the <seealso cref="T:PostSharp.Serialization.ISerializerFactoryProvider"/> interface to discover serializer types
            for each type being serialized.
            </summary>
            <remarks>
            Only implementations of <seealso cref="T:PostSharp.Serialization.ISerializerFactoryProvider"/> may implement this interface.
            </remarks>
            <seealso cref="T:PostSharp.Serialization.ISerializerFactoryProvider"/>
        </member>
        <member name="M:PostSharp.Serialization.ISerializerDiscoverer.DiscoverSerializers(System.Type)">
            <summary>
            Invoked by <seealso cref="T:PostSharp.Serialization.PortableFormatter"/> once for every type that needs to be serialized,
            before <seealso cref="M:PostSharp.Serialization.ISerializerFactoryProvider.GetSurrogateType(System.Type)"/> is invoked.
            </summary>
            <param name="objectType">Type being serialized.</param>
        </member>
        <member name="T:PostSharp.Serialization.ISerializerFactory">
            <summary>
            Defines a method <see cref="M:PostSharp.Serialization.ISerializerFactory.CreateSerializer(System.Type)"/>, which creates instances of the <see cref="T:PostSharp.Serialization.ISerializer"/> interface for
            given object types.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ISerializerFactory.CreateSerializer(System.Type)">
            <summary>
            Creates an instance of the <see cref="T:PostSharp.Serialization.ISerializer"/> interface for a given object type.
            </summary>
            <param name="objectType">Type of object being serialized or deserialized.</param>
            <returns>A new instance implementing the <see cref="T:PostSharp.Serialization.ISerializer"/> interface.</returns>
        </member>
        <member name="T:PostSharp.Serialization.ISerializerFactoryProvider">
            <summary>
            Provides instances of the <see cref="T:PostSharp.Serialization.ISerializerFactory"/> interface given the object type.
            </summary>
            <seealso cref="T:PostSharp.Serialization.ISerializerDiscoverer"/>
        </member>
        <member name="M:PostSharp.Serialization.ISerializerFactoryProvider.GetSurrogateType(System.Type)">
            <summary>
            Gets the surrogate type for a given object type. 
            </summary>
            <param name="objectType">Type of the object being serialized.</param>
            <returns>The surrogate type for <paramref name="objectType"/>, or <c>null</c> (or <paramref name="objectType"/>) is <paramref name="objectType"/>
            does not require a surrogate type.</returns>
            <remarks>
                <para>This method is called only during serialization. The surrogate type is the type whose name will be serialized; therefore, it will also
                        be the type that will be deserialized.</para>
            <para>It is <i>not</i> the responsibility of this class to call the next provider (<see cref="P:PostSharp.Serialization.ISerializerFactoryProvider.NextProvider"/>).</para>
            </remarks>
        </member>
        <member name="M:PostSharp.Serialization.ISerializerFactoryProvider.GetSerializerFactory(System.Type)">
            <summary>
            Gets the instance of <see cref="T:PostSharp.Serialization.ISerializerFactory"/>
            </summary>
            <param name="objectType">Type of object being serialized or deserialized. If a surrogate type has been specified during serialization,
            this parameter is set to the surrogate type during deserialization.</param>
            <returns>An instance of <see cref="T:PostSharp.Serialization.ISerializerFactory"/> able to serialize or deserialize <paramref name="objectType"/>, or <c>null</c>
            if there is no known serializer factory for this object. </returns>
            <remarks>
            <para>It is <i>not</i> the responsibility of this class to call the next provider (<see cref="P:PostSharp.Serialization.ISerializerFactoryProvider.NextProvider"/>).</para>
            </remarks>
        </member>
        <member name="P:PostSharp.Serialization.ISerializerFactoryProvider.NextProvider">
            <summary>
            Gets the next provider in the chain.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.PNonSerializedAttribute">
            <summary>
            Custom attribute that, when applied to a field of a class annotated with <see cref="T:PostSharp.Serialization.PSerializableAttribute"/>,
            specifies that this field should not be serialized.
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.PortableFormatter">
            <summary>
            A serializer designed to serialize the internal structure of types with support for cyclic object graphs.
            The <see cref="T:PostSharp.Serialization.PortableFormatter"/> is very similar in function and design to the <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>,
            but is supported on most platforms and does not require full trust. Both formatters have similar usage:
            <see cref="T:System.SerializableAttribute"/> is replaced by <see cref="T:PostSharp.Serialization.PSerializableAttribute"/> and
            <see cref="T:System.NonSerializedAttribute"/> by <see cref="T:PostSharp.Serialization.PNonSerializedAttribute"/>.
            </summary>
            <see cref="T:PostSharp.Serialization.PSerializableAttribute"/>
            
        </member>
        <member name="M:PostSharp.Serialization.PortableFormatter.#ctor">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.PortableFormatter"/>.
            </summary>
        </member>
        <member name="P:PostSharp.Serialization.PortableFormatter.DefaultBinder">
            <summary>
            Gets the default <see cref="T:PostSharp.Serialization.PortableSerializationBinder"/> that is used by a <see cref="T:PostSharp.Serialization.PortableFormatter"/> to bind types to/from type names if no
            <see cref="T:PostSharp.Serialization.PortableSerializationBinder"/> is specified.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.PortableFormatter.#ctor(PostSharp.Serialization.PortableSerializationBinder,PostSharp.Serialization.ISerializerFactoryProvider)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.PortableFormatter"/>.
            </summary>
            <param name="binder">A <see cref="T:PostSharp.Serialization.PortableSerializationBinder"/> customizing bindings between types and type names, or <c>null</c> to use the default implementation.</param>
            <param name="serializerProvider">A custom implementation of <see cref="T:PostSharp.Serialization.ISerializerFactoryProvider"/>, or <c>null</c> to use the default implementation.</param>
        </member>
        <member name="M:PostSharp.Serialization.PortableFormatter.Serialize(System.Object,System.IO.Stream)">
            <summary>
            Serializes an object (and the complete graph whose this object is the root) into a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="obj">The object to serialize.</param>
            <param name="stream">The stream where <paramref name="obj"/> needs to be serialized.</param>
        </member>
        <member name="M:PostSharp.Serialization.PortableFormatter.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes a stream.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> containing a serialized object graph.</param>
            <returns>The root object of the object graph serialized in <paramref name="stream"/>.</returns>
        </member>
        <member name="P:PostSharp.Serialization.PortableFormatter.Binder">
            <summary>
            Gets the <see cref="T:PostSharp.Serialization.PortableSerializationBinder"/> used by the current <see cref="T:PostSharp.Serialization.PortableFormatter"/> to bind types to/from type names.
            </summary>
        </member>
        <member name="P:PostSharp.Serialization.PortableFormatter.MetadataDispenser">
            <summary>
            When deserializing PostSharp aspects, gets the <see cref="T:PostSharp.Reflection.IMetadataDispenser"/> corresponding to the <see cref="P:PostSharp.Serialization.IArgumentsWriter.MetadataEmitter"/> 
            used at build time.
            </summary>
        </member>
        <member name="P:PostSharp.Serialization.PortableFormatter.MetadataEmitter">
            <summary>
            When serializing PostSharp access, gets or sets a facility that can be used to serialize metadata (<c>System.Reflection</c>) objects
            as MSIL, therefore making them transparent to obfuscation. 
            </summary>
        </member>
        <member name="T:PostSharp.Serialization.PortableFormatterConstructorContext">
            <exclude/>
        </member>
        <member name="T:PostSharp.Serialization.PortableSerializationBinder">
            <summary>
            Binds types to names and names to types. Used by the <see cref="T:PostSharp.Serialization.PortableFormatter"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationBinder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PostSharp.Serialization.PortableSerializationBinder"/> class.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationBinder.BindToType(System.String,System.String)">
            <summary>
            Gets a <see cref="T:System.Type"/> given a type name and an assembly name.
            </summary>
            <param name="typeName">The type name.</param>
            <param name="assemblyName">The assembly name.</param>
            <returns>The required <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationBinder.BindToName(System.Type,System.String@,System.String@)">
            <summary>
            Gets the name and the assembly name of a given <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/>.</param>
            <param name="typeName">At output, the name of <paramref name="type"/>.</param>
            <param name="assemblyName">At output, the name of <paramref name="assemblyName"/>.</param>
        </member>
        <member name="T:PostSharp.Serialization.PortableSerializationException">
            <summary>
            Exception thrown by the <see cref="T:PostSharp.Serialization.PortableFormatter"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationException.#ctor">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.PortableSerializationException"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.PortableSerializationException"/> and specifies the message.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.PortableSerializationException"/> and specifies the message and inner exception.
            </summary>
            <param name="message">Message.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:PostSharp.Serialization.PortableSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:PostSharp.Serialization.PSerializableAttribute">
            <summary>
            Custom attribute that, when applied to a type, causes PostSharp to generate a serializer for use by the <see cref="T:PostSharp.Serialization.PortableFormatter"/>.
            </summary>
            <remarks>
            <para>Fields that should not be serialized must be annotated with <see cref="T:PostSharp.Serialization.PNonSerializedAttribute"/>.</para>
                <para>This class inherits from <see cref="T:PostSharp.Extensibility.MulticastAttribute"/>, so it is possible to use multicasting to
            add this aspect to several classes using a single line, or to add this aspect to derived classes through inheritance.</para>
            </remarks>
            <seealso cref="T:PostSharp.Serialization.PortableFormatter"/>
        </member>
        <member name="T:PostSharp.Serialization.ReferenceTypeSerializer">
            <summary>
            Base serializer for all reference types.
            </summary>
            <remarks>
            This type is intentionally non-generic because it is intended to be derived several times, making strong typing less convenient.
            </remarks>
        </member>
        <member name="P:PostSharp.Serialization.ReferenceTypeSerializer.PostSharp#Serialization#ISerializer#IsTwoPhase">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.ReferenceTypeSerializer.PostSharp#Serialization#ISerializer#DeserializeFields(System.Object@,PostSharp.Serialization.IArgumentsReader)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.ReferenceTypeSerializer.PostSharp#Serialization#ISerializer#SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.ReferenceTypeSerializer.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)">
            <summary>
            Creates an instance of the given type.
            </summary>
            <param name="type">Type of the instance to be created.</param>
            <param name="constructorArguments">Gives access to arguments required to create the instance.</param>
            <returns>An instance of type <paramref name="type"/> initialized using <paramref name="constructorArguments"/>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.ReferenceTypeSerializer.SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <summary>
            Serializes an object
            </summary>
            <param name="obj"></param>
            <param name="constructorArguments">Gives access to arguments that will be passed to the <see cref="M:PostSharp.Serialization.ReferenceTypeSerializer.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)"/> method during deserialization.</param>
            <param name="initializationArguments">Gives access to arguments that will be passed to the <see cref="M:PostSharp.Serialization.ReferenceTypeSerializer.DeserializeFields(System.Object,PostSharp.Serialization.IArgumentsReader)"/> method during deserialization.</param>
        </member>
        <member name="M:PostSharp.Serialization.ReferenceTypeSerializer.DeserializeFields(System.Object,PostSharp.Serialization.IArgumentsReader)">
            <summary>
            Completes the second phase of deserialization by setting fields and other properties.
            </summary>
            <param name="obj">The object being deserialized.</param>
            <param name="initializationArguments">Gives access to field values.</param>
        </member>
        <member name="M:PostSharp.Serialization.ReferenceTypeSerializer.Convert(System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Serialization.SerializationServices">
            <summary>
            Provides some utility method for the current namespace.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.SerializationServices.GetSerializationException(System.Reflection.MemberInfo)">
            <summary>
            Checks whether a given <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.FieldInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>,
            <see cref="T:System.Reflection.EventInfo"/> or <see cref="T:System.Type"/> can be safely serialized.
            </summary>
            <param name="memberInfo">The declaration to be serialized.</param>
            <returns><c>null</c> if <paramref name="memberInfo"/> can be safely serialized, otherwise an exception where the text describes
            the reason why the declaration is not serializable.</returns>
        </member>
        <member name="M:PostSharp.Serialization.SerializationServices.GetSerializationException(PostSharp.Reflection.LocationInfo)">
            <summary>
            Checks whether a given <see cref="T:PostSharp.Reflection.LocationInfo"/> can be safely serialized.
            </summary>
            <param name="locationInfo">The declaration to be serialized.</param>
            <returns><c>null</c> if <paramref name="locationInfo"/> can be safely serialized, otherwise an exception where the text describes
            the reason why the declaration is not serializable.</returns>
        </member>
        <member name="M:PostSharp.Serialization.SerializationServices.GetSerializationException(System.Reflection.ParameterInfo)">
            <summary>
            Checks whether a given <see cref="T:System.Reflection.ParameterInfo"/> can be safely serialized.
            </summary>
            <param name="parameterInfo">The declaration to be serialized.</param>
            <returns><c>null</c> if <paramref name="parameterInfo"/> can be safely serialized, otherwise an exception where the text describes
            the reason why the declaration is not serializable.</returns>
        </member>
        <member name="T:PostSharp.Serialization.SerializerAttribute">
            <summary>
            Custom attribute that, when applied to a type, specifies its serializer for use by the <see cref="T:PostSharp.Serialization.PortableFormatter"/>.
            </summary>
            <remarks>
                <para>The use of the <see cref="T:PostSharp.Serialization.SerializerAttribute"/> is optional if the serializer of a type is a nested class of that class named <c>Serializer</c>.</para>
                <para>Windows Phone 7.0 does not allow to assign generic types to parameters of custom attributes.</para>
            </remarks>
            <seealso cref="T:PostSharp.Serialization.ImportSerializerAttribute"/>
        </member>
        <member name="M:PostSharp.Serialization.SerializerAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.SerializerAttribute"/>.
            </summary>
            <param name="serializerType">Serializer type. This type must implement <see cref="T:PostSharp.Serialization.ISerializer"/> or <see cref="T:PostSharp.Serialization.ISerializerFactory"/>,
            and must have a public default constructor. If <paramref name="serializerType"/> is a generic type, if must have the same number
            of generic type parameters as the target type, and have a compatible set of constraints.</param>
        </member>
        <member name="P:PostSharp.Serialization.SerializerAttribute.SerializerType">
            <summary>
            Gets the serializer type.
            </summary>
            <remarks>
            This type must implement <see cref="T:PostSharp.Serialization.ISerializer"/> or <see cref="T:PostSharp.Serialization.ISerializerFactory"/>,
            and must have a public default constructor. If <see cref="P:PostSharp.Serialization.SerializerAttribute.SerializerType"/> is a generic type, if must have the same number
            of generic type parameters as the target type, and have a compatible set of constraints.
            </remarks>
        </member>
        <member name="T:PostSharp.Serialization.SerializerFactoryProvider">
            <summary>
            Provides instances of the <see cref="T:PostSharp.Serialization.ISerializerFactory"/> interface for object types that have been previously registered
            using <see cref="M:PostSharp.Serialization.SerializerFactoryProvider.AddSerializer(System.Type,System.Type)"/>.
            </summary>
        </member>
        <member name="F:PostSharp.Serialization.SerializerFactoryProvider.BuiltIn">
            <summary>
            Gets the <see cref="T:PostSharp.Serialization.SerializerFactoryProvider"/> instance that supports built-in types.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.SerializerFactoryProvider.MakeReadOnly">
            <summary>
            Forbids further changes in the current <see cref="T:PostSharp.Serialization.SerializerFactoryProvider"/>.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.SerializerFactoryProvider.#ctor(PostSharp.Serialization.ISerializerFactoryProvider,PostSharp.Serialization.ActivatorProvider)">
            <summary>
            Initializes a new <see cref="T:PostSharp.Serialization.SerializerFactoryProvider"/>.
            </summary>
            <param name="nextProvider">The next provider in the chain, or <c>null</c> if there is none.</param>
            <param name="activatorProvider"></param>
        </member>
        <member name="P:PostSharp.Serialization.SerializerFactoryProvider.NextProvider">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.SerializerFactoryProvider.AddSerializer``2">
            <summary>
            Maps an object type to a serializer type (using generic type parameters).
            </summary>
            <typeparam name="TObject">Type of the serialized object.</typeparam>
            <typeparam name="TSerializer">Type of the serializer.</typeparam>
        </member>
        <member name="M:PostSharp.Serialization.SerializerFactoryProvider.AddSerializer(System.Type,System.Type)">
            <summary>
            Maps an object type to a serializer type.
            </summary>
            <param name="objectType">Type of the serialized object.</param>
            <param name="serializerType">Type of the serializer (must be derived from <see cref="T:PostSharp.Serialization.ISerializer"/>).</param>
        </member>
        <member name="M:PostSharp.Serialization.SerializerFactoryProvider.GetSurrogateType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.SerializerFactoryProvider.GetSerializerFactory(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:PostSharp.Serialization.Serializers.CultureInfoSerializer">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.CultureInfoSerializer.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.CultureInfoSerializer.SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.CultureInfoSerializer.DeserializeFields(System.Object,PostSharp.Serialization.IArgumentsReader)">
            <exclude/>
        </member>
        <member name="T:PostSharp.Serialization.Serializers.DictionarySerializer`2">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.DictionarySerializer`2.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.DictionarySerializer`2.SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.DictionarySerializer`2.DeserializeFields(System.Object,PostSharp.Serialization.IArgumentsReader)">
            <exclude/>
        </member>
        <member name="T:PostSharp.Serialization.Serializers.ListSerializer`1">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.ListSerializer`1.CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.ListSerializer`1.SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <exclude/>
        </member>
        <member name="M:PostSharp.Serialization.Serializers.ListSerializer`1.DeserializeFields(System.Object,PostSharp.Serialization.IArgumentsReader)">
            <exclude/>
        </member>
        <member name="T:PostSharp.Serialization.ValueTypeSerializer`1">
            <summary>
            Base serializer for all value types.
            </summary>
        </member>
        <member name="M:PostSharp.Serialization.ValueTypeSerializer`1.SerializeObject(`0,PostSharp.Serialization.IArgumentsWriter)">
            <summary>
            Serializes an object
            </summary>
            <param name="obj"></param>
            <param name="constructorArguments">Gives access to arguments that will be passed to the <see cref="M:PostSharp.Serialization.ValueTypeSerializer`1.DeserializeObject(PostSharp.Serialization.IArgumentsReader)"/> method during deserialization.</param>
        </member>
        <member name="M:PostSharp.Serialization.ValueTypeSerializer`1.DeserializeObject(PostSharp.Serialization.IArgumentsReader)">
            <summary>
            Creates an instance of the given type.
            </summary>
            <param name="constructorArguments">Gives access to arguments required to create the instance.</param>
            <returns>An instance of type <typeparamref name="T"/> initialized using <paramref name="constructorArguments"/>.</returns>
        </member>
        <member name="M:PostSharp.Serialization.ValueTypeSerializer`1.PostSharp#Serialization#ISerializer#SerializeObject(System.Object,PostSharp.Serialization.IArgumentsWriter,PostSharp.Serialization.IArgumentsWriter)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.ValueTypeSerializer`1.Convert(System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.ValueTypeSerializer`1.PostSharp#Serialization#ISerializer#CreateInstance(System.Type,PostSharp.Serialization.IArgumentsReader)">
            <inheritdoc />
        </member>
        <member name="M:PostSharp.Serialization.ValueTypeSerializer`1.PostSharp#Serialization#ISerializer#DeserializeFields(System.Object@,PostSharp.Serialization.IArgumentsReader)">
            <inheritdoc />
        </member>
    </members>
</doc>
